

-- @ Examples:

-- -----------------------------------------------------------------------------




-- -----------------------------------------------------------------------------

Focusing on · ⊢ [◇ 1 @ π0] leads to the initial sequent
 
    ----------------------------------
    path(π0 ⋆ π) | · ⊢ [1 @ π0 ⋆ π]
    --------------------------------
    path(π0 ⋆ π) | · ⊢ [◇ 1 @ π0]

path(π0 ⋆ π) | · ⊢ [◇ 1 @ π0]

-- -----------------------------------------------------------------------------

For ↓ □ p ⊃ ↓ □ (↓ p ⊃ q) ⊃ □ q @ π0 we have
e01 as a constant edge, or perhaps the predicate path(π0 ⋆ e01).


    ----------------------------------------------------
     ⊤ | □ p @ π0, □ (↓ p ⊃ q) @ π0 ⊢ · ; q @ π0 ⋆ e01 
    --------------------------------------------
     ⊤ | ↓ □ p, ↓ □ (↓ p ⊃ q) ⊢ □ q @ π0 ; · 
    -------------------------------------------------
     ⊤ | ·  ⊢ ↓ □ p ⊃ ↓ □ (↓ p ⊃ q) ⊃ □ q @ π0 ; · 


The goal is 

  ⊤ | · ⊢ q @ π0 ⋆ e01 

Focusing on  [□ (↓ p ⊃ q) @ π0] ⊢ 

 
                             ⊢ p @ π0 ⋆ π 
    ------------------    -------------------
     [q @ π0 ⋆ π] ⊢         ⊢ [↓ p @ π0 ⋆ π]
    --------------------------------------
     [(↓ p ⊃ q) @ π0 ⋆ π] ⊢ 
    ----------------------------
     [□ (↓ p ⊃ q) @ π0] ⊢ 

Giving rule

            Ψ | · ⊢ p @ π0 ⋆ π
    -------------------------------------
    Ψ ∧ path(π0 ⋆ π) | · ⊢ q @ π0 ⋆ π 

Focusing on [□ p @ π0] ⊢ 

    -----------------------
     [p @ π0 ⋆ π] ⊢ 
    ---------------
     [□ p @ π0] ⊢ 

Giving rule

----------------------------------
 path(π0 ⋆ π1) | · ⊢ p @ π0 ⋆ π1

One step gives

 path(π0 ⋆ π1) ∧ path(π0 ⋆ π1) | · ⊢ q @ π0 ⋆ π1


Unifying with the goal gives

 path(π0 ⋆ e01) ∧ path(π0 ⋆ e01) | · ⊢ q @ π0 ⋆ e01

And path(π0 · e01) is a global constraint.  So we can solve

path(π0 · e01) ⊨ path(π0 ⋆ e01) ∧ path(π0 ⋆ e01)

-} 
