diff -ur 1/TPTP2X/format.bliksem 2/TPTP2X/format.bliksem
--- 1/TPTP2X/format.bliksem	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.bliksem	2012-08-13 14:45:12.000000000 -0400
@@ -76,14 +76,14 @@
    !, blk_printquantifier( '[', ']', L, F ). 
 blk_printfof( ? L : F ) :-
    !, blk_printquantifier( '<', '>', L, F ). 
-blk_printfof( equal( A, B ) ) :-
+blk_printfof( '$tptp_equal'( A, B ) ) :-
    !, blk_printbinary( '=', A, B ). 
 
-blk_printfof($true):-
+blk_printfof('$true'):-
     !,
     write('( && )').
 
-blk_printfof($false):-
+blk_printfof('$false'):-
     !,
     write('( || )').
 
@@ -132,7 +132,7 @@
 
 blk_printfoflist( [ fof( Name, conjecture, F ) | R ] ) :-
 %----Need this for dodgy processing in Ratify
-    write('#----NOTE WELL: conjecture has been negated'),
+    write('#----This is the conjecture with negated conjecture'),
     nl,
    write( '# conjecture (has been negated) '), write( Name ), 
    write( ':' ), nl, !, 
@@ -142,18 +142,18 @@
    blk_printfoflist( R ). 
 
 % Print atoms: An atom can be printed without problems, because bliksem 
-% has the Prolog convention for variables. equal(A,B) has to be replaced 
-% by A = B. 
+% has the Prolog convention for variables. '$tptp_equal'(A,B) has to be 
+% replaced by A = B. 
 
-blk_printatom( equal( A, B ) ) :-
+blk_printatom( '$tptp_equal'( A, B ) ) :-
    write( A = B ),
    !. 
 
-blk_printatom($true):-
+blk_printatom('$true'):-
     !,
     write(' && ').
 
-blk_printatom($false):-
+blk_printatom('$false'):-
     !,
     write(' || ').
 
diff -ur 1/TPTP2X/format.carine 2/TPTP2X/format.carine
--- 1/TPTP2X/format.carine	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/format.carine	2012-08-13 14:45:12.000000000 -0400
@@ -22,11 +22,11 @@
     !,
     write(Variable).
 
-carine_output_term($true):-
+carine_output_term('$true'):-
     !,
     write(true).
 
-carine_output_term($false):-
+carine_output_term('$false'):-
     !,
     write(false).
 
@@ -112,7 +112,7 @@
 carine(carine,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('%----No FOF format available in PTTP'),
+    write('ERROR: No FOF format available in PTTP'),
     nl.
 %------------------------------------------------------------------------------
 %----Provide information about the Otter format
Only in 2/TPTP2X: format.clif
diff -ur 1/TPTP2X/format.clin-s 2/TPTP2X/format.clin-s
--- 1/TPTP2X/format.clin-s	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.clin-s	2012-08-13 14:45:12.000000000 -0400
@@ -7,7 +7,7 @@
 %--------------------------------------------------------------------
 %----Write out an atom.
 write_clin_s_atom(Atom):-
-    (Atom =.. [equal,LHS,RHS] -> (
+    (Atom =.. ['$tptp_equal',LHS,RHS] -> (
         write(LHS),
         write('='),
         write(RHS))
@@ -67,7 +67,7 @@
 clin_s(clin_s,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('%----No FOF format available in CLIN-S'),
+    write('ERROR: No FOF format available in CLIN-S'),
     nl.
 %--------------------------------------------------------------------
 %----Provide information about the CLIN-S format
diff -ur 1/TPTP2X/format.code 2/TPTP2X/format.code
--- 1/TPTP2X/format.code	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.code	2012-08-13 14:45:12.000000000 -0400
@@ -154,13 +154,13 @@
 code(code,Formulalist,_):- 
     tptp_clauses(Formulalist),
     !, 
-    write('#----Not a condensed detachment problem'),
+    write('ERROR: Not a condensed detachment problem'),
     nl.
 
 code(code,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('#----No FOF format available in CoDe'),
+    write('ERROR: No FOF format available in CoDe'),
     nl.
 %------------------------------------------------------------------------------
 %----We chose # for comment. % was not possible because it is allowed in 
diff -ur 1/TPTP2X/format.dedam 2/TPTP2X/format.dedam
--- 1/TPTP2X/format.dedam	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/format.dedam	2012-08-13 14:45:12.000000000 -0400
@@ -39,12 +39,12 @@
     write(' ignoring strange (non-unit?) clause : '), nl,nwrite(C),nl,nl,
     output_dedam_clauses(Rest).
 
-keep('++'(equal(S,T))):- assertz( dedam_save(equal(S,T)) ),!.
-keep('--'(equal(S,T))):- assertz( dedam_save(theorem(S,T)) ),!.
+keep('++'('$tptp_equal'(S,T))):- assertz( dedam_save('$tptp_equal'(S,T)) ),!.
+keep('--'('$tptp_equal'(S,T))):- assertz( dedam_save(theorem(S,T)) ),!.
 keep(X):- write(' ignoring strange literal in problem: '), 
           nl,write(X),nl,nl,!.
 
-write_eqs:- retract(dedam_save(equal(S,T))), nwrite(S=T), write('.'), nl, fail.
+write_eqs:- retract(dedam_save('$tptp_equal'(S,T))), nwrite(S=T), write('.'), nl, fail.
 write_eqs:- retract(dedam_save(theorem(S,T))), write('--'),nwrite(S=T),write('.'),nl, fail.
 write_eqs.
 
diff -ur 1/TPTP2X/format.dfg 2/TPTP2X/format.dfg
--- 1/TPTP2X/format.dfg	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.dfg	2012-08-13 14:45:12.000000000 -0400
@@ -8,6 +8,7 @@
 %----Hacked by Weidenbach, et al., 1996/1997.
 %----Vaguely dehacked by Geoff Sutcliffe, 1997.
 %----Updated (FOF included) by Michael Christen, April, 1997.
+%----List of predefined symbols extended, Thomas Hillenbrand August 08.
 %============================================================================
 %----------------------------------------------------------------------------
 %----List of predefined symbols (may not be a function or predicate symbol)
@@ -24,8 +25,20 @@
     'list_of_general_settings'/_, 'list_of_proof'/_, 'list_of_settings'/_,
 %----Need to () not because op(900,fy,(not)) and op(400,yfx,(/)).
     'list_of_symbols'/_, 'logic'/_, 'name'/_, ('not')/_, 'operators'/_,
-    'or'/_, 'predicate'/_, 'predicates'/_, 'quantifiers'/_, 'resolution'/_,
-    'sorts'/_, 'status'/_, 'subsort'/_, 'true'/_, 'version'/_]).
+    'or'/_, 'and'/_, 'predicate'/_, 'predicates'/_, 'quantifiers'/_, 
+    'resolution'/_, 'sorts'/_, 'status'/_, 'subsort'/_, 'true'/_, 'version'/_,
+%----extension August 08, TH.
+    'DL'/_, 'EML'/_, 'all'/_, 'box'/_, 'by'/_, 'comp'/_, 'concept_formula'/_, 
+    'conv'/_, 'dia'/_, 'div'/_, 'domain'/_,  'domrestr'/_, 'eml'/_, 
+    'freely'/_, 'generated'/_, 'id'/_, 'list_of_special_formulae'/_, 
+    'list_of_terms'/_, 'prop_formula'/_, 'range'/_, 'ranrestr'/_, 
+    'rel_formula'/_, 'role_formula'/_, 'satisfiable'/_, 
+    'set_ClauseFormulaRelation'/_, 'set_DomPred'/_, 'set_flag'/_, 
+    'set_precedence'/_, 'set_selection'/_, 'some'/_, 'sort'/_, 'step'/_, 
+    'sum'/_, 'test'/_, 'translpairs'/_, 'unknown'/_, 'unsatisfiable'/_,
+%----SPASS+T symbols
+    'succ'/_, 'minus'/_, 'plus'/_, 'times'/_, 'greater'/_, 'greatereq'/_,
+    'less'/_, 'lesseq'/_ ]).
 %----------------------------------------------------------------------------
 %----Write identifier; check for collision with reserved predefined symbols
 write_identifier(Ident,Prefix) :-
@@ -61,25 +74,43 @@
 %----Case of no hypothesis clauses
 output_dfg_clause_settings(_).
 %----------------------------------------------------------------------------
-output_dfg_formula_settings(Formulae):-
+output_each_SPASST_setting([]).
+
+output_each_SPASST_setting([Setting|RestOfSettings]):-
+    write('  '),
+    write(Setting),
+    write('.'),nl,
+    output_each_SPASST_setting(RestOfSettings).
+%----------------------------------------------------------------------------
+output_dfg_SPASST_settings([]).
+
+output_dfg_SPASST_settings([One|More]):-
+    write('list_of_settings(SPASS).'),nl,
+    write('{*'),nl,
+    output_each_SPASST_setting([One|More]),
+    write('*}'),nl,
+    write('end_of_list.'),nl.
+%----------------------------------------------------------------------------
+output_dfg_formula_settings(Formulae,SPASSTSettings):-
     findall(HypothesisName,
-        
-tptp2X_member(fof(HypothesisName,hypothesis,_),Formulae),
+(   tptp2X_member(AnnotatedFormula,Formulae),
+    AnnotatedFormula =.. [_,HypothesisName,hypothesis,_|_]),
 %----Check there is at least one name
-        [HypothesisName|RestOfHypothesisNames]),
+[HypothesisName|RestOfHypothesisNames]),
     !,
-    write('list_of_general_settings.'),
-    nl,
+    write('list_of_general_settings.'),nl,
     write('hypothesis'),
     write([HypothesisName|RestOfHypothesisNames]),
-    write('.'),
-    nl,
-    write('end_of_list.'),
+    write('.'),nl,
+    write('end_of_list.'),nl,
+    output_dfg_SPASST_settings(SPASSTSettings),
     nl,
     nl.
 
 %----Case of no hypothesis formulae
-output_dfg_formula_settings(_).
+output_dfg_formula_settings(_,SPASSTSettings):-
+    output_dfg_SPASST_settings(SPASSTSettings),
+    nl.
 %----------------------------------------------------------------------------
 translate_dfg_symbol(Symbol,Arity,NewSymbol,TranslationTable) :-
     tptp2X_member((Symbol/Arity,NewSymbol),TranslationTable),
@@ -102,32 +133,37 @@
     Pos1 is Pos - 1,
     translate_dfg_terms(Pos1,Term,NewTerm,TranslationTable).
 %----------------------------------------------------------------------------
-write_dfg_list_by_hand([One]):-
+write_dfg_list([One]):-
     !,
     write_dfg_term(One).
 
-write_dfg_list_by_hand([One,Two|Rest]):-
+write_dfg_list([One,Two|Rest]):-
     write_dfg_term(One),
     write(','),
-    write_dfg_list_by_hand([Two|Rest]).
+    write_dfg_list([Two|Rest]).
 %----------------------------------------------------------------------------
 write_dfg_term(Variable):-
     looks_like_a_variable(Variable),
     !,
     write(Variable).
 
-write_dfg_term($(false)):-
+write_dfg_term('$tptp_equal'(X,Y)):-
     !,
-    write(false).
+    write_dfg_term(equal(X,Y)).
 
-write_dfg_term($(true)):-
+write_dfg_term('$true'):-
     !,
     write(true).
 
-write_dfg_term($(Reserved)):-
+write_dfg_term('$false'):-
+    !,
+    write(false).
+
+write_dfg_term(Numerator/Denominator):-
     !,
-    write('$'),
-    write(Reserved).
+    write_dfg_term(Numerator),
+    write('/'),
+    write_dfg_term(Denominator).
 
 write_dfg_term(Atom):-
     atomic(Atom),
@@ -138,7 +174,7 @@
     Term =.. [Functor|Arguments],
     write(Functor),
     write('('),
-    write_dfg_list_by_hand(Arguments),
+    write_dfg_list(Arguments),
     write(')').
 %----------------------------------------------------------------------------
 %----Output a term with respect to the translation table
@@ -149,6 +185,17 @@
 write_indent(Indent):-
     output_indent(Indent,0).
 %----------------------------------------------------------------------------
+remove_types_from_dfg_variables([],[]).
+
+remove_types_from_dfg_variables([Variable:_|RestOfVariables],
+[Variable|RestOfUntypedVariables]):-
+    !,
+    remove_types_from_dfg_variables(RestOfVariables,RestOfUntypedVariables).
+
+remove_types_from_dfg_variables([Variable|RestOfVariables],
+[Variable|RestOfUntypedVariables]):-
+    remove_types_from_dfg_variables(RestOfVariables,RestOfUntypedVariables).
+%----------------------------------------------------------------------------
 %----Output a formula, symbols are already translated
 %----Unary Formula
 output_a_dfg_formula(UnaryFormula,Indent):-
@@ -202,7 +249,8 @@
     write_indent(Indent),
     write(DFGQuantifier), 
     write('('),
-    write(Variables),
+    remove_types_from_dfg_variables(Variables,UntypedVariables),
+    write(UntypedVariables),
     write(','),
     nl,
     output_a_dfg_formula(Formula,Indent1),
@@ -213,25 +261,34 @@
     write_indent(Indent),
     write_dfg_term(Atom).
 %----------------------------------------------------------------------------
-output_dfg_symbols([],_).
-
-output_dfg_symbols([Symbol/Arity],TranslationTable):-
-    !,
+output_dfg_symbol(Symbol/Arity,TranslationTable):-
     write('('),
     translate_dfg_symbol(Symbol,Arity,NewSymbol,TranslationTable),
     write(NewSymbol),
     write(','),
     write(Arity),
     write(')').
+%----------------------------------------------------------------------------
+output_dfg_symbols([],_,_).
 
-output_dfg_symbols([Symbol/Arity|RestOfPairs],TranslationTable):-
-    write('('),
-    translate_dfg_symbol(Symbol,Arity,NewSymbol,TranslationTable),
-    write(NewSymbol),
-    write(','),
-    write(Arity),
-    write('), '),
-    output_dfg_symbols(RestOfPairs,TranslationTable).
+%----Suppress '/'/2 because of SPASS+T
+output_dfg_symbols(['/'/2|RestOfPairs],SymbolNumber,TranslationTable):-
+    !,
+    output_dfg_symbols(RestOfPairs,SymbolNumber,TranslationTable).
+
+%----Supperss numbers for SPASS+T
+output_dfg_symbols([Number/0|RestOfPairs],SymbolNumber,TranslationTable):-
+    looks_like_a_number(Number),
+    !,
+    output_dfg_symbols(RestOfPairs,SymbolNumber,TranslationTable).
+
+output_dfg_symbols([Symbol/Arity|RestOfPairs],SymbolNumber,TranslationTable):-
+    (   SymbolNumber > 1
+   ->    write(',')
+    ;    true),
+    output_dfg_symbol(Symbol/Arity,TranslationTable),
+    NextSymbolNumber is SymbolNumber + 1,
+    output_dfg_symbols(RestOfPairs,NextSymbolNumber,TranslationTable).
 %----------------------------------------------------------------------------
 output_dfg_symbol_list(_,[],_):-
     !.
@@ -239,7 +296,7 @@
 output_dfg_symbol_list(Type,Symbols,TranslationTable):-
     write(Type),
     write('['),
-    output_dfg_symbols(Symbols,TranslationTable),
+    output_dfg_symbols(Symbols,1,TranslationTable),
     write('].'),
     nl.
 %----------------------------------------------------------------------------
@@ -334,17 +391,18 @@
 %----------------------------------------------------------------------------
 output_dfg_formulae([],_).
 
-output_dfg_formulae([fof(Name,Type,Form)|RestOfClause],TranslationTable):-
+output_dfg_formulae([AnnotatedFormula|RestOfClause],TranslationTable):-
+    AnnotatedFormula =.. [_,Name,Role,Formula|_],
     !,
     write('formula('),
-    (Type = axiom ->
+    (Role = axiom ->
         true
     ;   (   write('  %('),
-            write(Type),
+            write(Role),
             write(')'))),
     nl,
-    translate_dfg_term(Form,NewForm,TranslationTable),
-    output_a_dfg_formula(NewForm,1),
+    translate_dfg_term(Formula,NewFormula,TranslationTable),
+    output_a_dfg_formula(NewFormula,1),
     write(','),
     nl,
     write_identifier(Name,"dfg_"),
@@ -366,7 +424,7 @@
 %----Output negated formula warning only if conjecture and negated
 output_dfg_negated_conjecture_warning(conjectures,[_|_]):-
     !,
-    write('%----NOTE WELL: conjecture has been negated'),
+    write('%----This is the conjecture with negated conjecture'),
     nl.
 
 output_dfg_negated_conjecture_warning(_,_).
@@ -388,39 +446,30 @@
 %----Lemmas and definitions get converted to axioms
 dfg_clause_separate_axioms([dfg_clause(N,Status,V,L)|RestOfClauses],
 [dfg_clause(N,axiom,V,L)|RestOfAxioms],Others):-
-    tptp2X_member(Status,[initial,axiom,lemma,definition]),
+    tptp2X_member(Status,[axiom,lemma,theorem,definition]),
     !,
     dfg_clause_separate_axioms(RestOfClauses,RestOfAxioms,Others).
 
+dfg_clause_separate_axioms([dfg_clause(N,hypothesis,V,L)|RestOfFormulae],
+[dfg_clause(N,hypothesis,V,L)|RestOfAxioms],Others):-
+    !,
+    dfg_clause_separate_axioms(RestOfFormulae,RestOfAxioms,Others).
+
 dfg_clause_separate_axioms([dfg_clause(N,Status,V,L)|RestOfClauses],
 Axioms,[dfg_clause(N,Status,V,L)|RestOfOthers]):-
     dfg_clause_separate_axioms(RestOfClauses,Axioms,RestOfOthers).
 %----------------------------------------------------------------------------
 dfg_formula_separate_axioms([],[],[]).
 
-dfg_formula_separate_axioms([fof(N,Status,F)|RestOfFormulae],
-[fof(N,axiom,F)|RestOfAxioms],Others):-
-    tptp2X_member(Status,[initial,axiom,lemma,definition]),
-    !,
-    dfg_formula_separate_axioms(RestOfFormulae,RestOfAxioms,Others).
-
-dfg_formula_separate_axioms([fof(N,hypothesis,F)|RestOfFormulae],
-[fof(N,hypothesis,F)|RestOfAxioms],Others):-
-    !,
-    dfg_formula_separate_axioms(RestOfFormulae,RestOfAxioms,Others).
-
-dfg_formula_separate_axioms([fof(N,conjecture,F)|RestOfFormulae],
-Axioms,[fof(N,conjecture,F)|RestOfOthers]):-
+dfg_formula_separate_axioms([AnnotatedFormula|RestOfFormulae],
+Axioms,[AnnotatedFormula|RestOfOthers]):-
+    AnnotatedFormula =.. [_,_,conjecture,_|_],
     !,
     dfg_formula_separate_axioms(RestOfFormulae,Axioms,RestOfOthers).
 
-dfg_formula_separate_axioms([fof(_,Type,_)|RestOfFormulae],
-Axioms,Others):-
-    write('ERROR: Formula type '),
-    write(Type),
-    write(' unknown'),
-    nl,
-    dfg_formula_separate_axioms(RestOfFormulae,Axioms,Others).
+dfg_formula_separate_axioms([AnnotatedFormula|RestOfFormulae],
+[AnnotatedFormula|RestOfAxioms],Others):-
+    dfg_formula_separate_axioms(RestOfFormulae,RestOfAxioms,Others).
 %----------------------------------------------------------------------------
 output_dfg_clause_logical_part(DFGClauses,Predicates,Functions,
 TranslationTable):-
@@ -500,7 +549,6 @@
 %----------------------------------------------------------------------------
 %----Output 'a Problem'
 output_dfg_clause_problem(DFGClauses,Predicates,Functions,TranslationTable,
-
 FileHeader):-
     nl,
     write('begin_problem(TPTP_Problem).'),
@@ -515,7 +563,7 @@
 %----------------------------------------------------------------------------
 %----Output problem in formulae-syntax
 output_dfg_formula_problem(Formulae,Predicates,Functions,TranslationTable,
-FileHeader):-
+SPASSTSettings,FileHeader):-
     nl,
     write('begin_problem(TPTP_Problem).'),
     nl,
@@ -523,7 +571,7 @@
     output_dfg_description(FileHeader),
     output_dfg_formula_logical_part(Formulae,Predicates,Functions,
 TranslationTable),
-    output_dfg_formula_settings(Formulae),
+    output_dfg_formula_settings(Formulae,SPASSTSettings),
     write('end_problem.'),
     nl.
 %----------------------------------------------------------------------------
@@ -565,47 +613,51 @@
     tptp2X_member(Literal,Literals),
     Literal =.. [_,Atom],
 %----Avoid $true and $false
-    \+ (Atom = $_),
+    \+ (atom(Atom),
+        name(Atom,[36|_])),
     functor(Atom,PredicateSymbol,Arity).
 %----------------------------------------------------------------------------
 %----extract an atom from a formula
 %----Unary Formula
-dfg_fof_atom(UnaryFormula,Atom):-
+dfg_fof_atom(UnaryFormula,Atom,AllowDefined):-
     UnaryFormula =.. ['~',Arg],
     !,
-    dfg_fof_atom(Arg,Atom).
+    dfg_fof_atom(Arg,Atom,AllowDefined).
 
 %----Binary Formula
-dfg_fof_atom(BinaryFormula,Atom):-
+dfg_fof_atom(BinaryFormula,Atom,AllowDefined):-
     BinaryFormula =.. [Op,LHS,RHS],
 %----|;BUG
     tptp2X_member(Op,['|', ';', '&', '=>', '<=', '<=>', '<~>', '~|', '~&']),
     !,
     (
-        dfg_fof_atom(LHS,Atom)
+        dfg_fof_atom(LHS,Atom,AllowDefined)
     ;
-        dfg_fof_atom(RHS,Atom)
+        dfg_fof_atom(RHS,Atom,AllowDefined)
     ).
 
 %----Universals
-dfg_fof_atom((! _Variables : Formula),Atom):-
+dfg_fof_atom((! _Variables : Formula),Atom,AllowDefined):-
     !,
-    dfg_fof_atom(Formula,Atom).
+    dfg_fof_atom(Formula,Atom,AllowDefined).
 
 %----Existentials
-dfg_fof_atom((? _Variables : Formula),Atom):-
+dfg_fof_atom((? _Variables : Formula),Atom,AllowDefined):-
     !,
-    dfg_fof_atom(Formula,Atom).
+    dfg_fof_atom(Formula,Atom,AllowDefined).
 
 %----Atomic formulae
-dfg_fof_atom(Atom,Atom):-
-%----Avoid $true and $false
-    \+ (Atom = $_).
+dfg_fof_atom(Atom,Atom,AllowDefined):-
+%----Avoid $true and $false and other $symbols
+    Atom =.. [Symbol|_],
+    \+ ( name(Symbol,[36|_]),
+         AllowDefined == no ).
 %----------------------------------------------------------------------------
 %----Extract predicates from formulae
-dfg_formula_predicate(Formula,PredicateSymbol/Arity):-
-    tptp2X_member(fof(_,_,FOF),Formula),
-    dfg_fof_atom(FOF,Atom),
+dfg_formula_predicate(AnnotatedFormulae,PredicateSymbol/Arity):-
+    tptp2X_member(AnnotatedFormula,AnnotatedFormulae),
+    AnnotatedFormula =.. [_,_,_,FOF|_],
+    dfg_fof_atom(FOF,Atom,no),
     functor(Atom,PredicateSymbol,Arity).
 %----------------------------------------------------------------------------
 %----Extract a functor, knowing it's below the atom level
@@ -625,7 +677,10 @@
 %----Otherwise it's a function (hoorah) unless it's a $VAR
 dfg_clause_functor_extract(Function,Functor/Arity):-
     functor(Function,Functor,Arity),
-    Functor \== '$VAR'.
+%----No variables that have been numbervared
+    Functor \== '$VAR',
+%----No $symbols
+    \+ name(Functor,[36|_]).
 
 %----Extract functors from the arguments
 dfg_clause_functor_extract(Function,Functor):-
@@ -637,14 +692,15 @@
     tptp2X_member(input_clause(_,_,Literals),DFGClauses),
     tptp2X_member(Literal,Literals),
     Literal =.. [_,Atom],
-    \+ (Atom = $_),
     Atom =.. [_|Terms],
+%DEBUG write('extract from '),write(Terms),nl,
     dfg_clause_functor_extract(Terms,Functor).
 %----------------------------------------------------------------------------
 %----Extract functors from formulae
-dfg_formula_functor(Formula,Functor):-
-    tptp2X_member(fof(_,_,FOF),Formula),
-    dfg_fof_atom(FOF,Atom),
+dfg_formula_functor(Formulae,Functor):-
+    tptp2X_member(AnnotatedFormula,Formulae),
+    AnnotatedFormula =.. [_,_,_,FOF|_],
+    dfg_fof_atom(FOF,Atom,yes),
     Atom =.. [_|Terms],
     tptp2X_member(ATerm,Terms),
     dfg_clause_functor_extract(ATerm,Functor).
@@ -679,7 +735,19 @@
 dfg_translation_check([],_,_,[]).
 %----------------------------------------------------------------------------
 %----Create a output translation table for all symbols
-dfg_translation_table(Predicates,Functors,Transl) :-
+dfg_translation_table(Predicates,Functors,[
+('$less'/2,less),
+('$lesseq'/2,lesseq),
+('$greater'/2,greater),
+('$greatereq'/2,greatereq),
+('$uminus'/1,uminus),
+('$sum'/2,plus),
+('$difference'/2,minus),
+('$product'/2,times),
+('$to_int'/1,floor),
+('$is_int'/1,isint),
+('$is_rat'/1,israt)
+|Transl]) :-
     dfg_predefined(Predefined),
     tptp2X_append(Predefined,Functors,PF),
     dfg_translation_check(Predicates,PF,"_p",PredTransl),
@@ -705,8 +773,9 @@
 %----Build translation table to filter predefined symbols
     dfg_translation_table(PredicateStructures,FunctorStructures,
 TranslationTable),
-%----Extract equal
-    (tptp2X_select(equal/2,PredicateStructures,PredicateStructures_we) ->
+%----Extract '$tptp_equal'
+    (tptp2X_select('$tptp_equal'/2,PredicateStructures,
+PredicateStructures_we) ->
         true
     ;   PredicateStructures_we = PredicateStructures),
     output_dfg_clause_problem(DFGClauses,PredicateStructures_we,
@@ -728,22 +797,74 @@
 %----Build translation table to filter predefined symbols
     dfg_translation_table(PredicateStructures,FunctorStructures,
 TranslationTable),
-%----Extract equal
-    (tptp2X_select(equal/2,PredicateStructures,PredicateStructures_we) ->
+%----Extract '$tptp_equal'
+    (tptp2X_select('$tptp_equal'/2,PredicateStructures,
+PredicateStructures_we) ->
         true
     ;   PredicateStructures_we = PredicateStructures),
     output_dfg_formula_problem(Formulae,PredicateStructures_we,
-FunctorStructures,[('$not$'/1,not)|TranslationTable],FileHeader).
+FunctorStructures,[('$not$'/1,not)|TranslationTable],[],FileHeader).
 
-%----unknown format (to be prepared for the future)
+%----Unknown format (to be prepared for the future)
 dfg(dfg,_,_):-
     !,
-    write('%----unknown tptp input format'),
+    write('%----ERROR: No DFG format for that type of file'),
+    nl.
+
+%----Output TFF-dfg-syntax for SPASS+T
+dfgt(dfgt:DpcTheory:DpcProver,Formulae,FileHeader):-
+    tptp_formulae_language(Formulae,[tff,fof]),
+    !,
+%----Extract predicates
+    tptp2X_setof1(Predicate,dfg_formula_predicate(Formulae,Predicate),
+PredicateStructures),
+%----Extract functors
+    tptp2X_setof1(Functor,dfg_formula_functor(Formulae,Functor),
+FunctorStructures),
+%----Check for duplicate arities
+    dfg_consistent(PredicateStructures),
+    dfg_consistent(FunctorStructures),
+%----Build translation table to filter predefined symbols
+    dfg_translation_table(PredicateStructures,FunctorStructures,
+TranslationTable),
+%DEBUG write(PredicateStructures),nl,
+%DEBUG write(FunctorStructures),nl,
+%----Extract '$tptp_equal'
+    (tptp2X_select('$tptp_equal'/2,PredicateStructures,
+PredicateStructures_we) ->
+        true
+    ;   PredicateStructures_we = PredicateStructures),
+    output_dfg_formula_problem(Formulae,
+[greater/2, greatereq/2, less/2, lesseq/2 |PredicateStructures_we],
+[succ/1,uminus/1,minus/2,plus/2,times/2 |FunctorStructures],
+[('$not$'/1,not)| TranslationTable],
+[set_flag('PDer',0),
+ set_flag('PGiven',0),
+ set_flag('PProblem',0),
+ set_flag('PEmptyClause',0),
+ set_flag('Sorts',0),
+ set_flag('RArith',1),
+ set_flag('IThI',0),
+ set_flag('IIOE',0),
+ set_flag('DpcNonGroundExport',1),
+ set_flag('TheoryStandardAxioms',1),
+ set_flag('DocProof',1),
+ set_flag('DpcProver',DpcProver),
+ set_flag('DpcTheory',DpcTheory)],
+FileHeader).
+
+%----Unknown format (to be prepared for the future)
+dfgt(dfgt:_:_,_,_):-
+    !,
+    write('%----ERROR: No DFGT format for that type of file'),
     nl.
+
 %----------------------------------------------------------------------------
 %----Provide information about the DFG format
 dfg_format_information('%','.dfg').
+dfgt_format_information('%','.dfgt').
 %----------------------------------------------------------------------------
 %----Provide information about the DFG file
 dfg_file_information(format,dfg,'DFG format').
+dfg_file_information(format,dfgt:dpcTheory:dpcSolver,'DFG format').
 %----------------------------------------------------------------------------
diff -ur 1/TPTP2X/format.dimacs 2/TPTP2X/format.dimacs
--- 1/TPTP2X/format.dimacs	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.dimacs	2012-08-13 14:45:12.000000000 -0400
@@ -29,6 +29,19 @@
 %----Output each clause, mapping predicates to the integers
 output_dimacs_clauses([],_).
 
+output_dimacs_clauses([input_clause(_,_,[++ '$false'])|RestOfClauses],
+MappedPropositions):-
+    \+ tptp2X_member(input_clause(_,_,[-- '$false']),RestOfClauses),
+    !,
+    output_dimacs_clauses([input_clause(_,_,[++ '$false']),
+input_clause(_,_,[-- '$false'])|RestOfClauses],MappedPropositions).
+
+output_dimacs_clauses([input_clause(_Name,_Status,[++ '$true'])|RestOfClauses],
+MappedPropositions):-
+    !,
+    output_dimacs_clauses([input_clause(_,_,[++ '$true', -- '$true'])|
+RestOfClauses],MappedPropositions).
+
 output_dimacs_clauses([input_clause(_Name,_Status,Literals)|RestOfClauses],
 MappedPropositions):-
 %    write('c '), write(Name), write(' '), write(Status), nl,
@@ -84,14 +97,14 @@
 dimacs(dimacs,Clauses,_):-
     tptp_clauses(Clauses),
     !,
-    write('c----No non-propositional format available in DIMACS'),
+    write('ERROR: No non-propositional format available in DIMACS'),
     nl.
 
 %----Do nothing for FOF - just leave a comment
 dimacs(dimacs,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('%----No FOF format available in DIMACS'),
+    write('ERROR: No FOF format available in DIMACS'),
     nl.
 %----------------------------------------------------------------------------
 %----Provide information about the DFG format
diff -ur 1/TPTP2X/format.eqp 2/TPTP2X/format.eqp
--- 1/TPTP2X/format.eqp	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.eqp	2012-08-13 14:45:12.000000000 -0400
@@ -24,12 +24,12 @@
 %==============================================================================
 %------------------------------------------------------------------------------
 %----Output a literal with - for negative, nothing for positive
-output_eqp_literal(--equal(LHS,RHS)):-
+output_eqp_literal(--'$tptp_equal'(LHS,RHS)):-
     write(LHS),
     write(' != '),
     write(RHS).
 
-output_eqp_literal(++equal(LHS,RHS)):-
+output_eqp_literal(++'$tptp_equal'(LHS,RHS)):-
     write(LHS),
     write(' = '),
     write(RHS).
@@ -134,7 +134,7 @@
 eqp(eqp,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('%----No FOF format available in EQP'),
+    write('ERROR: No FOF format available in EQP'),
     nl.
 %------------------------------------------------------------------------------
 %----Provide information about the EQP format
diff -ur 1/TPTP2X/format.finder 2/TPTP2X/format.finder
--- 1/TPTP2X/format.finder	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.finder	2012-08-13 14:45:12.000000000 -0400
@@ -17,7 +17,7 @@
 % (In this case you should also use the option -t rm_equality:rstfp
 %  when transforming the problems)
 %
-%output_finder_atom(equal(X,Y)):-
+%output_finder_atom('$tptp_equal'(X,Y)):-
 %    !,
 %    write(X),
 %    write('='),
@@ -164,6 +164,11 @@
 %----------------------------------------------------------------------
 declare_finder_constant_list([]).
 
+declare_finder_constant_list([Functor/0|RestOfFunctions]):-
+    name(Functor,[36|_]),
+    !,
+    declare_finder_constant_list(RestOfFunctions).
+
 declare_finder_constant_list([FirstFunction|RestOfFunctions]):-
     declare_finder_constant(FirstFunction),
     declare_finder_constant_list(RestOfFunctions).
@@ -171,6 +176,10 @@
 declare_finder_constants([]):- 
     !.
 
+declare_finder_constants([Functor/0]):- 
+    name(Functor,[36|_]),
+    !.
+
 declare_finder_constants(FunctorStructures) :-
     !,
     write('
@@ -184,6 +193,11 @@
 %----------------------------------------------------------------------
 declare_finder_function_list([]).
 
+declare_finder_function_list([Functor/_|RestOfFunctions]):-
+    name(Functor,[36|_]),
+    !,
+    declare_finder_function_list(RestOfFunctions).
+
 declare_finder_function_list([FirstFunction|RestOfFunctions]):-
     declare_finder_function(FirstFunction),
     declare_finder_function_list(RestOfFunctions).
@@ -191,6 +205,10 @@
 declare_finder_functions([]) :- 
     !.
 
+declare_finder_functions([Functor/_]) :- 
+    name(Functor,[36|_]),
+    !.
+
 declare_finder_functions(FunctorStructures):-
     !,
     write('
@@ -210,8 +228,9 @@
 
 declare_finder_predicate_list([]).
 
-%----Ignore equal, which is built in
-declare_finder_predicate_list([equal/2|RestOfPredicates]):-
+%----Ignore defined
+declare_finder_predicate_list([Predicate/_|RestOfPredicates]):-
+    name(Predicate,[36|_]),
     !,
     declare_finder_predicate_list(RestOfPredicates).
 
@@ -222,7 +241,9 @@
 declare_finder_predicates([]):- 
     !.
 
-declare_finder_predicates([equal/2]):- 
+%----If defined is the only thing, then no list
+declare_finder_predicates([Predicate/_]):- 
+    name(Predicate,[36|_]),
     !.
 
 declare_finder_predicates(UnsignedPredicateStructures):-
@@ -461,7 +482,7 @@
 finder(_,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('%----No FOF format available in FINDER'),
+    write('ERROR: No FOF format available in FINDER'),
     nl, write('end'), nl.
 
 %finder(_,_,_):-
Only in 1/TPTP2X: format.ft
diff -ur 1/TPTP2X/format.ftprolog 2/TPTP2X/format.ftprolog
--- 1/TPTP2X/format.ftprolog	2007-06-21 08:53:36.000000000 -0400
+++ 2/TPTP2X/format.ftprolog	2012-08-13 14:45:12.000000000 -0400
@@ -4,56 +4,25 @@
 %----FOF only
 %----Written by Thomas Raths & Jens Otten, April 2005, adapted Nov 2005
 %========================================================================
-:-set_flag(print_depth,100).
-%----------------------------------------------------------------------
-%----Print out a literal with - for negative, nothing for positive.
-%----Use positive representation
-output_ftprolog_signed_literal(--Atom):-
-    !, write(' '), write(Atom).
 
-output_ftprolog_signed_literal(++Atom):-
-    write('-'), write(Atom).
-%----------------------------------------------------------------------
-%----Print out the literals of a clause in ftprolog format.
-%----Special case of an empty clause
-output_ftprolog_literals([]):-
-    write('[]').
-
-output_ftprolog_literals([OneLiteral]):-
-    !, output_ftprolog_signed_literal(OneLiteral).
-
-output_ftprolog_literals([FirstLiteral|RestOfLiterals]):-
-    output_ftprolog_signed_literal(FirstLiteral),
-    write('  ,'), nl, write(' '),
-    output_ftprolog_literals(RestOfLiterals).
-%----------------------------------------------------------------------
-%----Print out the clauses in ftprolog format.
-output_ftprolog_clauses([]).
+% Syntax von ft:
+%
+% constant, variable, function ::=
+%         sequence of alphabetic, numeric characters and '_' beginning with
+%         a lowercase letter
+% 
+% term ::= constant | variable | function(terms)
+%
+% terms ::= term | term , terms
+%
+% let f, f1, f2 be formulae
+%
+% formula ::= Literal | Var[var list] 
+%          neg f | f1 and f2 | f1 or f2 | f1 imp f2 | f1 iff f2 |
+%          a(var,f) | e(var,f) | 
+%          (f)
 
-output_ftprolog_clauses([input_clause(Name,Status,Literals)|
-RestOfClauses]):-
-    write('% '), write(Name), write(', '),
-    write(Status), write('.'), nl,
-    write('['),
-    output_ftprolog_literals(Literals),
-    write(']'),
-    (RestOfClauses\==[]  ->
-        (nl, nl, write('  ,'), nl, nl);
-         true),
-    output_ftprolog_clauses(RestOfClauses).
-%----------------------------------------------------------------------
-%----Print out the list of input clauses as a formula in ftprolog format.
-output_ftprolog_formula([]):-
-    !.
-
-output_ftprolog_formula(Clauses):-
-    nl,
-    write('f('), nl, nl,
-    output_ftprolog_clauses(Clauses), nl, nl,
-    write(']).'), nl, nl.
-%----------------------------------------------------------------------
 
-%----------------------------------------------------------------------
 %----Print out the connectives, quantifiers, and literals of a formula
 %----in ftprolog format.
 output_ftprolog_fof(~ A):-
@@ -75,25 +44,21 @@
     output_ftprolog_fof(B), write(' )').
 output_ftprolog_fof(! [] : A):- !, output_ftprolog_fof(A).
 output_ftprolog_fof(! [V|L] : A):-
-    !, write('( a(x'), print(V), write(','),
+    !, write('( a(x'), write(V), write(','),
     output_ftprolog_fof(! L : A), write(' ))').
 output_ftprolog_fof(? [] : A):- !, output_ftprolog_fof(A).
 output_ftprolog_fof(? [V|L] : A):-
-    !, write('( e(x'), print(V), write(','),
+    !, write('( e(x'), write(V), write(','),
     output_ftprolog_fof(? L : A), write(' ))').
-output_ftprolog_fof('$true') :- !, write('(true___ imp true___)').
-output_ftprolog_fof($true) :- !, write('(true___ imp true___)').
-output_ftprolog_fof('$false') :- !, write('(false___ and neg false___)').
-output_ftprolog_fof($false) :- !, write('(false___ and neg false___)').
+output_ftprolog_fof('$true') :- !, write('(atom___ imp atom___)').
+output_ftprolog_fof('$false') :- !, write('(false___)').
 output_ftprolog_fof(Atom) :- transpred_ftprolog(Atom).
 
 %%% transform a tptp-variable or constant 'XYZ' into xXYZ
 transpred_ftprolog(A) :- atom(A), !, write(A).
 transpred_ftprolog(A) :- A=..[B|C], 
                          write(B), write('('), transterms_ftprolog(C), write(')').
-transterms_ftprolog([A|T]):- looks_like_a_variable(A), !, write('x'), print(A),
-                             (T\=[] -> (write(','), transterms_ftprolog(T)); true).
-transterms_ftprolog([A|T]):- atom(A), !, write(A),
+transterms_ftprolog([A|T]):- looks_like_a_variable(A), !, write('x'), write(A),
                              (T\=[] -> (write(','), transterms_ftprolog(T)); true).
 % A cannot be a variable
 transterms_ftprolog([A|T]):- A=..[B|C], 
@@ -105,23 +70,46 @@
 output_ftprolog_fo_formulae([]).
 
 % for TPTP-v3.1.0 or later
-output_ftprolog_fo_formulae([fof(Name,Status,Formula)|RestOfFormulae]) :-
-    ((Status==conjecture, RestOfFormulae \= []) -> 
-      (append(RestOfFormulae,[fof(Name,Status,Formula)],Formulae),
-       output_ftprolog_fo_formulae(Formulae))) ;
-      (write('% '), write(Name), write(', '), write(Status), write('.'), nl,
-       write('('), output_ftprolog_fof(Formula), write(')'),
-       (RestOfFormulae == [] -> true;
-        (((RestOfFormulae=[fof(_,conjecture,_)]  ->
-           (nl, nl, write('  imp '), nl, nl)); 
-           (nl, nl, write('  and '), nl, nl)),
-          output_ftprolog_fo_formulae(RestOfFormulae)))).
+output_ftprolog_fo_formulae([fof(Name,Status,Formula)|
+RestOfFormulae]):-
+    write('% '), write(Name), write(', '),
+    write(Status), write('.'), nl,
+    write('('),
+    (Status==conjecture ->
+         output_ftprolog_fof(Formula);
+         output_ftprolog_fof(Formula)),
+    write(')'),
+    ( (RestOfFormulae=[fof(_,axiom,_)|_];
+       RestOfFormulae=[fof(_,lemma,_)|_];
+       RestOfFormulae=[fof(_,definition,_)|_];
+       RestOfFormulae=[fof(_,hypothesis,_)|_])  ->
+        (nl, nl,
+         write(' and '), nl, nl);
+         (RestOfFormulae=[fof(_,conjecture,_)|_]  ->
+             (nl, nl,
+              write(' imp '), nl, nl);
+             true)),
+    output_ftprolog_fo_formulae(RestOfFormulae).
 
 % for TPTP-v2.7.0 or earlier
 output_ftprolog_fo_formulae([input_formula(Name,Status,Formula)|
 RestOfFormulae]):-
-    output_ftprolog_fo_formulae([fof(Name,Status,Formula)|RestOfFormulae]).
-
+    write('% '), write(Name), write(', '),
+    write(Status), write('.'), nl,
+    write('('),
+    (Status==conjecture ->
+         output_ftprolog_fof(Formula);
+         output_ftprolog_fof(Formula)),
+    write(')'),
+    ( (RestOfFormulae=[input_formula(_,axiom,_)|_];
+       RestOfFormulae=[input_formula(_,hypothesis,_)|_])  ->
+        (nl, nl,
+         write(' and '), nl, nl);
+         (RestOfFormulae=[input_formula(_,conjecture,_)|_]  ->
+             (nl, nl,
+              write(' imp '), nl, nl);
+             true)),
+    output_ftprolog_fo_formulae(RestOfFormulae).
 %----------------------------------------------------------------------
 %----Print out the list of input formulae as a first-order formula in
 %----ftprolog format.
@@ -131,14 +119,7 @@
 output_ftprolog_fo_formula(Formulae):-
     nl,
     write('f(('), nl, nl,
-    % negate problems without conjecture
-    (\+ (member(fof(_,conjecture,_),Formulae);
-         member(input_formula(_,conjecture,_),Formulae)) -> 
-                                             (write('neg ('), nl) ; true),
     output_ftprolog_fo_formulae(Formulae), nl, nl,
-    (\+ (member(fof(_,conjecture,_),Formulae);
-         member(input_formula(_,conjecture,_),Formulae)) -> 
-                                             (write(')'), nl); true),
     write(')).'), nl, nl.
 
 %----------------------------------------------------------------------
Only in 1/TPTP2X: format.gandalf
Only in 2/TPTP2X: format.geo
Only in 1/TPTP2X: format.glides
Only in 2/TPTP2X: format.hol
diff -ur 1/TPTP2X/format.ilf 2/TPTP2X/format.ilf
--- 1/TPTP2X/format.ilf	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.ilf	2012-08-13 14:45:12.000000000 -0400
@@ -119,7 +119,7 @@
 ilf(ilf,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('%----No FOF format available in ILF'),
+    write('ERROR: No FOF format available in ILF'),
     nl.
 %-------------------------------------------------------------------
 %----Provide information about the ILF format
Only in 2/TPTP2X: format.isabelle
Only in 1/TPTP2X: format.jprover
diff -ur 1/TPTP2X/format.kif 2/TPTP2X/format.kif
--- 1/TPTP2X/format.kif	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/format.kif	2012-08-13 14:45:12.000000000 -0400
@@ -12,11 +12,11 @@
 %----Generic output
 %==============================================================================
 %----Translate symbols if necessary. Only equal right now
-output_kif_symbol(equal):-
+output_kif_symbol('$tptp_equal'):-
     !,
     write('=').
 
-output_kif_symbol(not_equal):-
+output_kif_symbol('$tptp_not_equal'):-
     !,
     write('/=').
 
@@ -66,11 +66,11 @@
     !,
     write(Term).
 
-output_kif_term($true):-
+output_kif_term('$true'):-
     !,
     write(true).
 
-output_kif_term($false):-
+output_kif_term('$false'):-
     !,
     write(false).
 
@@ -88,7 +88,7 @@
     output_kif_term(Variable).
 %------------------------------------------------------------------------------
 %----Output an atom
-kif_output_atom(Atom):-
+kif_output_atom(_,Atom):-
     output_kif_term(Atom).
 %------------------------------------------------------------------------------
 %==============================================================================
@@ -140,7 +140,7 @@
     write('.'),
     nl,
     (Status==conjecture -> 
-        (   write(';----NOTE WELL: conjecture has been negated'),
+        (   write(';----This is the conjecture with negated conjecture'),
             nl,
             output_generic_prefix_formula(kif,~Formula)
         )
@@ -156,18 +156,18 @@
 %----Output a literal with - for negative, nothing for positive
 %----Special case for negative equality. Done sadly like this for Eclipse
 %----which dies on strange predicates
-output_kif_signed_literal(--equal(LHS,RHS)):-
+output_kif_signed_literal(--'$tptp_equal'(LHS,RHS)):-
     !,
-    output_kif_signed_literal(++not_equal(LHS,RHS)).
+    output_kif_signed_literal(++'$tptp_not_equal'(LHS,RHS)).
 
 output_kif_signed_literal(--Atom):-
     !,
     write('(not '),
-    kif_output_atom(Atom),
+    kif_output_atom(cnf,Atom),
     write(')').
 
 output_kif_signed_literal(++Atom):-
-    kif_output_atom(Atom).
+    kif_output_atom(cnf,Atom).
 %------------------------------------------------------------------------------
 %----Output the literals of the clause in KIF format
 %----Special case of an empty clause
diff -ur 1/TPTP2X/format.leancop 2/TPTP2X/format.leancop
--- 1/TPTP2X/format.leancop	2007-06-19 11:56:32.000000000 -0400
+++ 2/TPTP2X/format.leancop	2012-08-13 14:45:12.000000000 -0400
@@ -1,18 +1,15 @@
-%========================================================================
-%----This outputs TPTP Problem Set clauses and formulae in a format
-%----acceptable to the leanCoP system.
+%======================================================================
+%----This outputs TPTP problem clauses and formulae in a format
+%----acceptable to the leanCoP system (www.leancop.de).
 %----
 %----Written by Jens Otten, November 2000
-%----extended to handle FOF: JO, June 2004
-%========================================================================
-
-%%% Thomas Raths (TR) November, 2005-: changes due to TPTP3.1.0-
-:-set_flag(print_depth,1000). %%% for Eclipse Prolog
-
+%----Extended to handle first-order: Jens Otten, June 2004
+%----Modified to work with TPTP 3.x: Thomas Raths, November 2005
+%======================================================================
 %----------------------------------------------------------------------
-%----Print out a literal with - for negative, nothing for positive.
+%----Print out a literal with '-' for negative, nothing for positive.
 %----Use positive representation
-%%% T.R.
+
 output_leancop_signed_literal(--('$tptp_equal'(X,Y))) :-
     !, write(' (equal('), write(X), write(' , '), write(Y), write('))').
 
@@ -25,14 +22,16 @@
 output_leancop_signed_literal(++('$tptp_not_equal'(X,Y))) :-
     !, write(' (equal('), write(X), write(' , '), write(Y), write('))').
 
-output_leancop_signed_literal(--Atom):-
+output_leancop_signed_literal(--Atom) :-
     !, write(' '), write(Atom).
 
-output_leancop_signed_literal(++Atom):-
+output_leancop_signed_literal(++Atom) :-
     write('-'), write(Atom).
+
 %----------------------------------------------------------------------
 %----Print out the literals of a clause in leanCoP format.
 %----Special case of an empty clause
+
 output_leancop_literals([]):-
     write('[]').
 
@@ -43,24 +42,26 @@
     output_leancop_signed_literal(FirstLiteral),
     write('  ,'), nl, write(' '),
     output_leancop_literals(RestOfLiterals).
+
 %----------------------------------------------------------------------
 %----Print out the clauses in leanCoP format.
+
 output_leancop_clauses([]).
-%%% for TPTP-v3.1.0 or later
-%%% if clause = $true (or ­($false)), then ignore it,
-%%% if clause = $false (or -($true)), then clause set is valid => add e.g. [truexxx], [-(truexxx)]
-%%% for TPTP-v3.2.0: '$true', '$false', for TPTP-v3.1.0: $true, $false
 
-output_leancop_clauses([cnf(Name,Status,[Literal])|
-RestOfClauses]):- 
+%%% for TPTP-v3.1.0 or later:
+%%% if clause = $true (or -($false)), then ignore it
+%%% if clause = $false (or -($true)), then clause set is valid and
+%%%  the clauses [truexxx] and [-(truexxx)] are added
+%%% for TPTP-v3.2.0: '$true', '$false'; for TPTP-v3.1.0: $true, $false
+
+output_leancop_clauses([cnf(_Name,_Status,[Literal])|RestOfClauses]) :-
     (Literal = ++('$true'); 
      Literal = ++($true);
      Literal = --('$false');
      Literal = --($false)), !,
     output_leancop_clauses(RestOfClauses).
 
-output_leancop_clauses([cnf(Name,Status,[Literal])|
-RestOfClauses]) :-
+output_leancop_clauses([cnf(Name,Status,[Literal])|RestOfClauses]) :-
     (Literal = ++('$false'); 
      Literal = ++($false);
      Literal = --('$true');
@@ -68,82 +69,81 @@
     write('% '), write(Name), write(', '),
     write(Status), write('.'), nl,
     write('[truexxx], [-(truexxx)]'),
-    (RestOfClauses\==[]  ->
+    (RestOfClauses\==[] ->
         (nl, nl, write('  ,'), nl, nl);
          true),
     output_leancop_clauses(RestOfClauses).
 
-output_leancop_clauses([cnf(Name,Status,Literals)|
-RestOfClauses]):-
+output_leancop_clauses([cnf(Name,Status,Literals)|RestOfClauses]) :-
     write('% '), write(Name), write(', '),
     write(Status), write('.'), nl,
     write('['),
     output_leancop_literals(Literals),
     write(']'),
-    (RestOfClauses\==[]  ->
+    (RestOfClauses\==[] ->
         (nl, nl, write('  ,'), nl, nl);
          true),
     output_leancop_clauses(RestOfClauses).
 
-%%% for TPTP-v2.7.0 or earlier
-output_leancop_clauses([input_clause(Name,Status,Literals)|
-RestOfClauses]):-
-        output_leancop_clauses([cnf(Name,Status,Literals)|
-    RestOfClauses]).
+%%% for TPTP-v2.7.0 or earlier:
+output_leancop_clauses([input_clause(Name,Status,Literals)|RestOfClauses]) :-
+    output_leancop_clauses([cnf(Name,Status,Literals)|RestOfClauses]).
+
 %----------------------------------------------------------------------
-%----Print out the list of input clauses as a formula in leanCoP format.
-output_leancop_formula([]):-
+%----Print the list of input clauses as a formula in leanCoP format.
+
+output_leancop_formula([]) :-
     !.
 
-output_leancop_formula(Clauses):-
+output_leancop_formula(Clauses) :-
     nl,
     write('f(['), nl, nl,
     output_leancop_clauses(Clauses), nl, nl,
     write(']).'), nl, nl.
-%----------------------------------------------------------------------
 
 %----------------------------------------------------------------------
 %----Print out the connectives, quantifiers, and literals of a formula
 %----in leanCoP format.
-output_leancop_fof((~ A)):-
+
+output_leancop_fof((~ A)) :-
     !, write('( ~ '), output_leancop_fof(A), write(' )').
-output_leancop_fof('|'(A,B) ):-
+output_leancop_fof('|'(A,B)) :-
     !, write('( '), output_leancop_fof(A), write(' ; '),
     output_leancop_fof(B), write(' )').
-output_leancop_fof((A;B)):-
+output_leancop_fof((A;B)) :-
     !, write('( '), output_leancop_fof(A), write(' ; '),
     output_leancop_fof(B), write(' )').
-output_leancop_fof((A & B)):-
+output_leancop_fof((A & B)) :-
     !, write('( '), output_leancop_fof(A), write(' , '),
     output_leancop_fof(B), write(' )').
-output_leancop_fof((A => B)):-
+output_leancop_fof((A => B)) :-
     !, write('( '), output_leancop_fof(A), write(' => '),
     output_leancop_fof(B), write(' )').
-output_leancop_fof((A <=> B)):-
+output_leancop_fof((A <=> B)) :-
     !, write('( '), output_leancop_fof(A), write(' <=> '),
     output_leancop_fof(B), write(' )').
-output_leancop_fof((! [] : A)):- !, output_leancop_fof(A).
-output_leancop_fof((! [V|L] : A)):-
+output_leancop_fof((! [] : A)) :- !, output_leancop_fof(A).
+output_leancop_fof((! [V|L] : A)) :-
     !, write('( all '), print(V), write(' : '),
     output_leancop_fof(! L : A), write(' )').
 output_leancop_fof((? [] : A)):- !, output_leancop_fof(A).
-output_leancop_fof((? [V|L] : A)):-
+output_leancop_fof((? [V|L] : A)) :-
     !, write('( ex '), print(V), write(' : '),
     output_leancop_fof(? L : A), write(' )').
-output_leancop_fof('$true') :- !, write('(true___=>true___)').
-output_leancop_fof($true) :- !, write('(true___=>true___)'). % TPTP 3.1.0
+output_leancop_fof('$true')  :- !, write('(true___=>true___)').
+output_leancop_fof($true)    :- !, write('(true___=>true___)').
 output_leancop_fof('$false') :- !, write('(false___ , ~ false___)').
-output_leancop_fof($false) :- !, write('(false___ , ~ false___)'). % TPTP 3.1.0
-output_leancop_fof('$tptp_equal'(X,Y)) :- !, write('equal('), 
-                                           write(X), write(' , '), write(Y), write(')').
-output_leancop_fof('$tptp_not_equal'(X,Y)) :- !,  write('(~ ( equal('), 
-                                           write(X), write(' , '), write(Y), write(')))').
+output_leancop_fof($false) :- !, write('(false___ , ~ false___)').
+output_leancop_fof('$tptp_equal'(X,Y)) :-
+    !, write('equal('), write(X), write(' , '), write(Y), write(')').
+output_leancop_fof('$tptp_not_equal'(X,Y)) :-
+    !,  write('(~ ( equal('), write(X), write(' , '), write(Y), write(')))').
 output_leancop_fof(Atom) :- print(Atom).
+
 %----------------------------------------------------------------------
 %----Print out the formulae in leanCoP format.
 output_leancop_fo_formulae([]).
 
-%%% for TPTP-v3.1.0 or later
 output_leancop_fo_formulae([fof(Name,Status,Formula)|RestOfFormulae]) :-
     (Status==conjecture, RestOfFormulae \= []) -> 
       (append(RestOfFormulae,[fof(Name,Status,Formula)],Formulae),
@@ -151,50 +151,50 @@
       (write('% '), write(Name), write(', '), write(Status), write('.'), nl,
        write('('), output_leancop_fof(Formula), write(')'),
        (RestOfFormulae == [] -> true;
-        (((RestOfFormulae=[fof(_,conjecture,_)]  ->
-           (nl, nl, write('  =>'), nl, nl)); 
+        (((RestOfFormulae=[fof(_,conjecture,_)] ->
+           (nl, nl, write('  =>'), nl, nl));
            (nl, nl, write('  ,'), nl, nl)),
-          output_leancop_fo_formulae(RestOfFormulae)))).
-
-
+         output_leancop_fo_formulae(RestOfFormulae)))).
 
-
-%%% for TPTP-v2.7.0 or earlier
-output_leancop_fo_formulae([input_formula(Name,Status,Formula)|
-RestOfFormulae]):-
-    output_leancop_fo_formulae([fof(Name,Status,Formula)|RestOfFormulae]).
+%%% for TPTP-v2.7.0 or earlier:
+output_leancop_fo_formulae([input_formula(Name,Status,Fml)|RestOfFml]) :-
+    output_leancop_fo_formulae([fof(Name,Status,Fml)|RestOfFml]).
 
 %----------------------------------------------------------------------
 %----Print out the list of input formulae as a first-order formula in
 %----leanCoP format.
-output_leancop_fo_formula([]):-
+
+output_leancop_fo_formula([]) :-
     !.
 
-output_leancop_fo_formula(Formulae):-
+output_leancop_fo_formula(Formulae) :-
     nl,
     write('f(('), nl, nl,
-    %%% negate problems without conjecture
+    %%%% Negate problems without conjecture (for CASC)
     (\+ (member(fof(_,conjecture,_),Formulae);
-         member(input_formula(_,conjecture,_),Formulae)) -> 
-                                             (write('~ ('), nl) ; true),
-    output_leancop_fo_formulae(Formulae), nl, nl,
+         member(input_formula(_,conjecture,_),Formulae)) ->
+           (write('~ ('), nl) ;       %%%% T.R.  (NEGATED)
+           (nl,write('%----This is the conjecture with negated conjecture'),nl)), 
+    output_leancop_fo_formulae(Formulae), nl, nl, 
     (\+ (member(fof(_,conjecture,_),Formulae);
-         member(input_formula(_,conjecture,_),Formulae)) -> 
-                                             (write(')'), nl); true),
+         member(input_formula(_,conjecture,_),Formulae)) ->
+           (write(')'), nl); true),
     write(')).'), nl, nl.
 
 %----------------------------------------------------------------------
-
-%----------------------------------------------------------------------
 %----Print out all the clauses in leanCoP format.
-leancop(leancop,Clauses,_):-
+
+leancop(leancop,Clauses,_) :-
     tptp_clauses(Clauses),
     output_leancop_formula(Clauses).
 
+%----------------------------------------------------------------------
 %----Print out first-order formula in leanCoP format.
-leancop(leancop,Formulae,_):-
+
+leancop(leancop,Formulae,_) :-
     tptp_formulae(Formulae),
     output_leancop_fo_formula(Formulae).
+
 %----------------------------------------------------------------------
 %----Provide information about the leanCoP format.
 leancop_format_information('%','.leancop').
diff -ur 1/TPTP2X/format.leantap 2/TPTP2X/format.leantap
--- 1/TPTP2X/format.leantap	2007-06-21 08:58:48.000000000 -0400
+++ 2/TPTP2X/format.leantap	2012-08-13 14:45:12.000000000 -0400
@@ -1,153 +1,284 @@
 %========================================================================
-%----This outputs TPTP Problem Set clauses and formulae in a format
-%----acceptable to the leanCoP system.
+%----This outputs TPTP Problem Set clauses in a format acceptable to 
+%----the leanTAP system.
 %----
-%----Written by Jens Otten, November 2000
+%----Written by Karla Geiss, March, 1995.
+%----Minor modifications by Geoff Sutcliffe, May, 1995.
 %========================================================================
+%========================================================================
+%----FOF output
+%========================================================================
+%DEBUG output_leantap_formula(F):-write('OLF--- '),display(F),fail.
 
-%%% adapted for TPTP-v3.1.0 by Thomas Raths in Novermber, 2005
-:-set_flag(print_depth,100).
+output_leantap_formula(?[Variable]:Formula) :-
+	!,
+	write('ex('),
+	write(Variable),
+	write(','),
+	nl,
+	output_leantap_formula(Formula),
+	nl,
+	write(')').
+
+output_leantap_formula(?[Variable|Variables]:Formula) :-
+	!,
+	write('ex('),
+	write(Variable),
+	write(', '),
+	output_leantap_formula(?Variables:Formula),
+	write(')').
+
+output_leantap_formula(![Variable]:Formula) :-
+	!,
+	write('all('),
+	write(Variable),
+	write(','),
+	nl,
+	output_leantap_formula(Formula),
+	nl,
+	write(')').
+
+output_leantap_formula(![Variable|Variables]:Formula) :-
+	!,
+	write('all('),
+	write(Variable),
+	write(', '),
+	output_leantap_formula(!Variables:Formula),
+	write(')').
+
+output_leantap_formula(P & Q) :-
+	!,
+	write('('),
+	output_leantap_formula(P),
+	write(')'),
+	nl,
+	write(' & '),
+	nl,
+	write('('),
+	output_leantap_formula(Q),
+	write(')').
+
+output_leantap_formula(P '|' Q) :-
+	!,
+	write('(('),
+	output_leantap_formula(P),
+	write(')'),
+	nl,
+	write(' v '),
+	nl,
+	write('('),
+	output_leantap_formula(Q),
+	write('))').
+
+output_leantap_formula(P => Q) :-
+	!,
+	write('(('),
+	output_leantap_formula(P),
+	write(')'),
+	nl,
+	write(' => '),
+	nl,
+	write('('),
+	output_leantap_formula(Q),
+	write('))').
+
+output_leantap_formula(P <=> Q) :-
+	!,
+	write('(('),
+	output_leantap_formula(P),
+	write(')'),
+	nl,
+	write(' <=> '),
+	nl,
+	write('('),
+	output_leantap_formula(Q),
+	write('))').
+
+output_leantap_formula(~P) :-
+	!,
+	write('-('),
+	output_leantap_formula(P),
+    write(')').
+
+output_leantap_formula('$true'):-
+    !,
+    write('true__ v -(true__)').
+
+output_leantap_formula('$false'):-
+    !,
+    write('false__ & -(false__)').
+
+output_leantap_formula('$tptp_equal'(LHS,RHS)):-
+    !,
+    output_leantap_formula(equal(LHS,RHS)).
 
-%----------------------------------------------------------------------
+output_leantap_formula(Term) :-
+	write(Term).
+
+%========================================================================
+%----CNF output
+%========================================================================
 %----Print out a literal with - for negative, nothing for positive.
-%----Use positive representation
 output_leantap_signed_literal(--Atom):-
-    !, write(' '), write(Atom).
+    !,
+    write('-'),
+    output_leantap_formula(Atom).
 
 output_leantap_signed_literal(++Atom):-
-    write('-'), write(Atom).
+    write(' '),
+    output_leantap_formula(Atom).
 %----------------------------------------------------------------------
-%----Print out the literals of a clause in leantap format.
+%----Print out the literals of a clause in leanTAP format.
 %----Special case of an empty clause
 output_leantap_literals([]):-
-    write('[]').
+    !,
+    write('dummy & -dummy').
 
 output_leantap_literals([OneLiteral]):-
-    !, output_leantap_signed_literal(OneLiteral).
+    !,
+    output_leantap_signed_literal(OneLiteral).
 
 output_leantap_literals([FirstLiteral|RestOfLiterals]):-
     output_leantap_signed_literal(FirstLiteral),
-    write('  ,'), nl, write(' '),
+    write('  v'),
+    nl,
+    write(' '),
     output_leantap_literals(RestOfLiterals).
 %----------------------------------------------------------------------
-%----Print out the clauses in leantap format.
-output_leantap_clauses([]).
-
-output_leantap_clauses([input_clause(Name,Status,Literals)|
-RestOfClauses]):-
-    write('% '), write(Name), write(', '),
-    write(Status), write('.'), nl,
-    write('['),
+%----Print out the clause in leanTAP format.
+output_leantap_clause([],Literals):-
+    !,
+    write('('),
     output_leantap_literals(Literals),
-    write(']'),
-    (RestOfClauses\==[]  ->
-        (nl, nl, write('  ,'), nl, nl);
-         true),
-    output_leantap_clauses(RestOfClauses).
+    write(')').
+
+output_leantap_clause([FirstVariable|RestOfVariables],Literals):-
+    write('all('),
+    write(FirstVariable),
+    write(','),
+    (RestOfVariables == [] ->
+        nl;
+        true),
+    output_leantap_clause(RestOfVariables,Literals),   
+    write(')'). 
 %----------------------------------------------------------------------
-%----Print out the list of input clauses as a formula in leantap format.
-output_leantap_formula([]):-
+%----Print out the clauses in leanTAP format.
+output_leantap_cf([]):-
     !.
+output_leantap_cf([input_clause(Name,Status,Variables,Literals)|
+RestOfClauses]):-
+    !,
+    write('% '),
+    write(Name),
+    write(', '),
+    write(Status),
+    write('.'),
+    nl,
+    output_leantap_clause(Variables,Literals),
+    (RestOfClauses \== []  ->
+        (nl,
+         nl,
+         write('  &'),
+         nl,
+         nl);
+         true),
+    output_leantap_cf(RestOfClauses).
 
-output_leantap_formula(Clauses):-
+output_leantap_cf([fof(Name,Status,Formula)|RestOfFormulae]):-
+    write('% '),
+    write(Name),
+    write(', '),
+    write(Status),
+    write('.'),
     nl,
-    write('f(['), nl, nl,
-    output_leantap_clauses(Clauses), nl, nl,
-    write(']).'), nl, nl.
-%----------------------------------------------------------------------
-
-%----------------------------------------------------------------------
-%----Print out the connectives, quantifiers, and literals of a formula
-%----in leantap format.
-output_leantap_fof(~ A):-
-    !, write('( - '), output_leantap_fof(A), write(' )').
-output_leantap_fof('|'(A,B) ):- 
-    !, write('( '), output_leantap_fof(A), write(' v '),
-    output_leantap_fof(B), write(' )').
-output_leantap_fof((A ; B)):- 
-    !, write('( '), output_leantap_fof(A), write(' v '),
-    output_leantap_fof(B), write(' )').
-output_leantap_fof(A & B):-
-    !, write('( '), output_leantap_fof(A), write(' & '),
-    output_leantap_fof(B), write(' )').
-output_leantap_fof(A => B):-
-    !, write('( '), output_leantap_fof(A), write(' => '),
-    output_leantap_fof(B), write(' )').
-output_leantap_fof(A <=> B):-
-    !, write('( '), output_leantap_fof(A), write(' <=> '),
-    output_leantap_fof(B), write(' )').
-output_leantap_fof(! [] : A):- !, output_leantap_fof(A).
-output_leantap_fof(! [V|L] : A):-
-    !, write('( all('), print(V), write(' , '),
-    output_leantap_fof(! L : A), write(' ))').
-output_leantap_fof(? [] : A):- !, output_leantap_fof(A).
-output_leantap_fof(? [V|L] : A):-
-    !, write('( ex('), print(V), write(' , '),
-    output_leantap_fof(? L : A), write(' ))').
-output_leantap_fof('$true') :- !, write('(true___=>true___)').
-output_leantap_fof($true) :- !, write('(true___=>true___)').
-output_leantap_fof('$false') :- !, write('(false___ & - false___)').
-output_leantap_fof($false) :- !, write('(false___ & - false___)').
-
-output_leantap_fof(Atom) :-
-    print(Atom).
-%----------------------------------------------------------------------
-%----Print out the formulae in leantap format.
-output_leantap_fo_formulae([]).
-
-% for TPTP-v3.1.0 or later
-output_leantap_fo_formulae([fof(Name,Status,Formula)|RestOfFormulae]) :-
-    ((Status==conjecture, RestOfFormulae \= []) -> 
-      (append(RestOfFormulae,[fof(Name,Status,Formula)],Formulae),
-       output_leantap_fo_formulae(Formulae))) ;
-      (write('% '), write(Name), write(', '), write(Status), write('.'), nl,
-       write('('), output_leantap_fof(Formula), write(')'),
-       (RestOfFormulae == [] -> true;
-        (((RestOfFormulae=[fof(_,conjecture,_)]  ->
-           (nl, nl, write('  =>'), nl, nl)); 
-           (nl, nl, write('  &'), nl, nl)),
-          output_leantap_fo_formulae(RestOfFormulae)))).
-
-% for TPTP-v2.7.0 or earlier
-output_leantap_fo_formulae([input_formula(Name,Status,Formula)|
-RestOfFormulae]):-
-    output_leantap_fo_formulae([fof(Name,Status,Formula)|RestOfFormulae]).
-
-%----------------------------------------------------------------------
-%----Print out the list of input formulae as a first-order formula in
-%----leantap format.
-output_leantap_fo_formula([]):-
+    output_leantap_formula(Formula),
+    (RestOfFormulae \== []  ->
+        (nl,
+         nl,
+         write('  &'),
+         nl,
+         nl);
+         true),
+    output_leantap_cf(RestOfFormulae).
+%----------------------------------------------------------------------
+%----Print out the list of input clauses/formulae as a formula in leanTAP 
+%----format.
+leantap_reorder_cf(L, [fof(Name, conjecture, ~(Formula))| Rest]) :-
+	tptp2X_select(fof(Name, conjecture, Formula), L, Rest),
+	!,
+    write('%----This is the conjecture with negated conjecture'),
+    nl.
+
+leantap_reorder_cf(L, L).
+%----------------------------------------------------------------------
+output_leantap([]):-
     !.
 
-output_leantap_fo_formula(Formulae):-
+output_leantap(CF):-
     nl,
-    write('f(('), nl, nl,
-    % negate problems without conjecture
-    (\+ (member(fof(_,conjecture,_),Formulae);
-         member(input_formula(_,conjecture,_),Formulae)) -> 
-                                             (write('- ('), nl) ; true),
-    output_leantap_fo_formulae(Formulae), nl, nl,
-    (\+ (member(fof(_,conjecture,_),Formulae);
-         member(input_formula(_,conjecture,_),Formulae)) -> 
-                                             (write(')'), nl); true),
-    write(')).'), nl, nl.
-
+    write('fml(t,0,('),
+    nl,
+    nl,
+    leantap_reorder_cf(CF, Reordered),
+    output_leantap_cf(Reordered),
+    nl,
+    nl,
+    write(')).'),
+    nl,
+    nl.    
 %----------------------------------------------------------------------
+%----Search for the variables occurring in the clause.
+%----If atomic, check if a variable (they're all atoms by here, so look
+%----at the first letter).
+leantap_variable(Variable,Variable):-
+    atom(Variable),
+    !,
+    name(Variable,[FirstASCII|_]),
+    FirstASCII >= 65,
+    FirstASCII =< 90.
+
+%----Numbervars variables look like shit.
+leantap_variable('$VAR'(Index),'$VAR'(Index)):-
+    !.
 
+%----If a list then do head and tail
+leantap_variable([FirstTerm|RestOfTerms],Variable):-
+    !,
+    tptp2X_member(Term,[FirstTerm|RestOfTerms]),
+    leantap_variable(Term,Variable).
+
+%----Otherwise it's a function to pull apart
+leantap_variable(Function,Variable):-
+    Function =.. [_|Arguments],
+    leantap_variable(Arguments,Variable).
+%----------------------------------------------------------------------
+%----Extend each input clause, adding the list of variables occurring
+%----in that clause.
+make_leantap_clauses([],[]):-
+    !.
+
+make_leantap_clauses([input_clause(Name,Status,Literals)|
+RestOfClauses],[input_clause(Name,Status,ClauseVariables,Literals)|
+RestOfLeantapClauses]):-
+    tptp2X_setof1(Variable,leantap_variable(Literals,Variable),
+ClauseVariables),
+    make_leantap_clauses(RestOfClauses,RestOfLeantapClauses).
 %----------------------------------------------------------------------
-%----Print out all the clauses in leantap format.
+%----Print out all the clauses in leanTAP format.
 leantap(leantap,Clauses,_):-
     tptp_clauses(Clauses),
-    output_leantap_formula(Clauses).
+    make_leantap_clauses(Clauses,LeantapClauses),
+    output_leantap(LeantapClauses).
 
-%----Print out first-order formula in leantap format.
+%----Print out all the formulae in leanTAP format.
 leantap(leantap,Formulae,_):-
     tptp_formulae(Formulae),
-    output_leantap_fo_formula(Formulae).
+    output_leantap(Formulae).
 %----------------------------------------------------------------------
-%----Provide information about the leantap format.
+%----Provide information about the leanTAP format.
 leantap_format_information('%','.leantap').
 %----------------------------------------------------------------------
-%----Provide information about the TPTP file.
-leantap_file_information(format,leantap).
+%----Provide information about the TPTP file
+leantap_file_information(format,leantap,'LeanTAP format').
 %----------------------------------------------------------------------
+
Only in 2/TPTP2X: format.lf
Only in 2/TPTP2X: format.lf.florian
Only in 1/TPTP2X: format.ljt
Only in 1/TPTP2X: format.mace4
Only in 1/TPTP2X: format.math
Only in 1/TPTP2X: format.meteor
Only in 2/TPTP2X: format.metitarski
diff -ur 1/TPTP2X/format.mgtp 2/TPTP2X/format.mgtp
--- 1/TPTP2X/format.mgtp	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.mgtp	2012-08-13 14:45:12.000000000 -0400
@@ -82,7 +82,7 @@
 mgtp(mgtp,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('%----No FOF format available in MGTP'),
+    write('ERROR: No FOF format available in MGTP'),
     nl.
 %-------------------------------------------------------------------
 %----Provide information about the MGTP format
diff -ur 1/TPTP2X/format.oldtptp 2/TPTP2X/format.oldtptp
--- 1/TPTP2X/format.oldtptp	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.oldtptp	2012-08-13 14:45:12.000000000 -0400
@@ -13,46 +13,72 @@
 %------------------------------------------------------------------------------
 %----Output variables 
 oldtptp_output_variable(Variable):-
+    prolog_dialect(swi),
+    !,
+    write_term(Variable,[numbervars(true)]).
+
+
+oldtptp_output_variable(Variable):-
     write(Variable).
 %------------------------------------------------------------------------------
-oldtptp_output_atom_list_by_hand([One]):-
+oldtptp_output_atom_list(Language,[One]):-
     !,
-    oldtptp_output_atom_by_hand(One).
+    oldtptp_output_atom(Language,One).
 
-oldtptp_output_atom_list_by_hand([One,Two|Rest]):-
-    oldtptp_output_atom_by_hand(One),
+oldtptp_output_atom_list(Language,[One,Two|Rest]):-
+    oldtptp_output_atom(Language,One),
     write(','),
-    oldtptp_output_atom_list_by_hand([Two|Rest]).
+    oldtptp_output_atom_list(Language,[Two|Rest]).
 %------------------------------------------------------------------------------
-oldtptp_output_atom_by_hand(Variable):-
+oldtptp_output_atom(_,Variable):-
     looks_like_a_variable(Variable),
     !,
     oldtptp_output_variable(Variable).
 
-oldtptp_output_atom_by_hand($(Reserved)):-
+oldtptp_output_atom(Language,'$tptp_equal'(X,Y)):-
     !,
-    oldtptp_output_atom_by_hand(Reserved).
+    oldtptp_output_atom(Language,equal(X,Y)).
 
-oldtptp_output_atom_by_hand(Atom):-
+oldtptp_output_atom(Language,'$tptp_not_equal'(X,Y)):-
+    !,
+    write('~ '),
+    oldtptp_output_atom(Language,equal(X,Y)).
+
+oldtptp_output_atom(Language,Reserved):-
+    atom(Reserved),
+    name(Reserved,[36|WordASCII]),
+    !,
+    name(Word,WordASCII),
+    oldtptp_output_atom(Language,Word).
+
+oldtptp_output_atom(_,Atom):-
     atomic(Atom),
     !,
     write(Atom).
 
-oldtptp_output_atom_by_hand(Term):-
+oldtptp_output_atom(Language,Term):-
     Term =.. [Functor|Arguments],
     write(Functor),
     write('('),
-    oldtptp_output_atom_list_by_hand(Arguments),
+    oldtptp_output_atom_list(Language,Arguments),
     write(')').
 %------------------------------------------------------------------------------
-%----Output atoms - remove dumbo spaces from Eclipse output
-oldtptp_output_atom(Atom):-
-    prolog_dialect(eclipse),
+simple_oldtptp_status(Status-_,FinalStatus):-
     !,
-    oldtptp_output_atom_by_hand(Atom).
+    simple_oldtptp_status(Status,FinalStatus).
 
-oldtptp_output_atom(Atom):-
-    write(Atom).
+%----Until systems learn about negated_conjecture
+simple_oldtptp_status(negated_conjecture,conjecture):-
+    !.
+
+%----Until systems learn about lemma
+simple_oldtptp_status(definition,axiom):-
+    !.
+
+simple_oldtptp_status(lemma,axiom):-
+    !.
+
+simple_oldtptp_status(Status,Status).
 %------------------------------------------------------------------------------
 %==============================================================================
 %----FOF format
@@ -73,14 +99,14 @@
 output_oldtptp_formula(Format,fof(Name,Status,Formula)):-
     simple_oldtptp_status(Status,SimpleStatus),
     write('input_formula('),
-    write(Name),
+    writeq(Name),
     write(','),
     write(SimpleStatus),
 %----Bracket formula to avoid confusing with other arguments (esp |
 %----becomes ; of wrong precedence)
     write(',('),
     nl,
-    output_generic_formula(Format,Formula),
+    output_generic_formula(Format,fof,Formula),
     write('   )).'),
     nl.
 %------------------------------------------------------------------------------
@@ -146,11 +172,11 @@
 %----Output oldtptp format literals
 output_oldtptp_literal(++Atom):-
     write('++'),
-    oldtptp_output_atom(Atom).
+    oldtptp_output_atom(cnf,Atom).
 
 output_oldtptp_literal(--Atom):-
     write('--'),
-    oldtptp_output_atom(Atom).
+    oldtptp_output_atom(cnf,Atom).
 %------------------------------------------------------------------------------
 %----Write out the literals, one per line indented by 5
 %----In case there's an empty clause (after my simplification)
@@ -170,25 +196,11 @@
             write('     '))),
     output_oldtptp_literals(RestOfLiterals,OneLineOfLiterals).
 %------------------------------------------------------------------------------
-simple_oldtptp_status(Status-_,FinalStatus):-
-    !,
-    simple_oldtptp_status(Status,FinalStatus).
-
-%----Until systems learn about negated_conjecture
-simple_oldtptp_status(negated_conjecture,conjecture):-
-    !.
-
-%----Until systems learn about lemma
-simple_oldtptp_status(lemma,axiom):-
-    !.
-
-simple_oldtptp_status(Status,Status).
-%------------------------------------------------------------------------------
 %----Write out a TPTP clause, one literal per line
 output_oldtptp_clause(input_clause(Name,Status,Literals),OneLineOfLiterals):-
     simple_oldtptp_status(Status,SimpleStatus),
     write('input_clause('),
-    write(Name),
+    writeq(Name),
     write(','),
     write(SimpleStatus),
     write(','),
diff -ur 1/TPTP2X/format.omdoc 2/TPTP2X/format.omdoc
--- 1/TPTP2X/format.omdoc	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/format.omdoc	2012-08-13 14:45:12.000000000 -0400
@@ -4,150 +4,374 @@
 %----Written by Geoff Sutcliffe, August 2003
 %============================================================================
 %----------------------------------------------------------------------------
-output_omdoc_omv(Variable,Indent):-
+translate_ID_character(Character,Translation):-
+    tptp2X_member(Character-Translation,
+[36-"_dollar_",43-"_plus_",94-"_lambda_",58-"_colon_"]).
+%----------------------------------------------------------------------------
+translate_ID_characters([],[]).
+
+translate_ID_characters([First|Rest],Translated):-
+    translate_ID_character(First,FirstTranslated),
+    !,
+    translate_ID_characters(Rest,RestTranslated),
+    tptp2X_append(FirstTranslated,RestTranslated,Translated).
+
+translate_ID_characters([First|Rest],[First|RestTranslated]):-
+    translate_ID_characters(Rest,RestTranslated).
+%----------------------------------------------------------------------------
+%----Encode to avoid illegal characters
+%----If the first is illegal, start with s
+translate_to_ID_encoded(ID,IDEncoded):-
+    name(ID,[FirstIDASCII|RestIDASCII]),
+    translate_ID_character(FirstIDASCII,FirstTranslatedASCII),
+    !,
+    translate_ID_characters(RestIDASCII,RestTranslatedASCII),
+    tptp2X_append("s",FirstTranslatedASCII,MidTranslatedASCII),
+    tptp2X_append(MidTranslatedASCII,RestTranslatedASCII,AllTranslatedASCII),
+    name(IDEncoded,AllTranslatedASCII).
+
+%----Otherwise do all
+translate_to_ID_encoded(ID,IDEncoded):-
+    name(ID,IDASCII),
+    translate_ID_characters(IDASCII,TranslatedASCII),
+    name(IDEncoded,TranslatedASCII).
+%----------------------------------------------------------------------------
+write_ID_encoded(ID):-
+    translate_to_ID_encoded(ID,IDEncoded),
+    write(IDEncoded).
+%----------------------------------------------------------------------------
+translate_to_omdoc_symbol(Symbol,OmDocSymbol):-
+%----Need the ()s to allow translation of ! and ? - weird Prolog bug
+    tptp2X_member((Symbol)-OmDocSymbol,
+[('~')-not,('|')-or, ('&')-and,('=>')-implies,('<=')-implied,('<=>')-equivalent,
+('<~>')-xor,('~&')-nand,('~|')-nor,('[]')-tuple,
+('!')-forall,('?')-exists,('^')-lambda,('!!')-'forall-op',('??')-'exists-op',
+(':=')-letrec,
+('$tptp_equal')-eq,('$tptp_not_equal')-neq,
+('$true')-true,('$false')-false,
+('$i')-ind,('$o')-bool,('$tType')-type,
+('>')-funtype,('*')-tupletype,('+')-cotupletype]),
+    !.
+
+translate_to_omdoc_symbol(Symbol,Symbol).
+%----------------------------------------------------------------------------
+get_CD_for_symbol(_,IndividualSymbol,_,ind):-
+    tptp2X_member(IndividualSymbol,[ind]),
+    !.
+
+get_CD_for_symbol(_,TruthValueSymbol,_,truthval):-
+    tptp2X_member(TruthValueSymbol,[true,false,bool]),
+    !.
+
+get_CD_for_symbol(_,PL0Symbol,_,pl0):-
+    tptp2X_member(PL0Symbol,[not,and,or,xor,implies,implied,equivalent]),
+    !.
+
+get_CD_for_symbol(fof,PL1Symbol,_,pl1):-
+    tptp2X_member(PL1Symbol,[forall,exists]),
+    !.
+
+get_CD_for_symbol(thf,PL1Symbol,_,sthol):-
+    tptp2X_member(PL1Symbol,[forall,exists]),
+    !.
+
+get_CD_for_symbol(thf,IndEqSymbol,_,sthol):-
+    tptp2X_member(IndEqSymbol,[neq,eq]),
+    !.
+
+get_CD_for_symbol(_,IndEqSymbol,_,indeq):-
+    tptp2X_member(IndEqSymbol,[neq,eq]),
+    !.
+
+get_CD_for_symbol(_,STSymbol,_,simpletypes):-
+    tptp2X_member(STSymbol,[type,funtype,tupletype,cotupletype]),
+    !.
+
+get_CD_for_symbol(_,STLCSymbol,_,stlc):-
+    tptp2X_member(STLCSymbol,[lambda]),
+    !.
+
+get_CD_for_symbol(_,RCSymbol,_,'record-calc'):-
+    tptp2X_member(RCSymbol,[tuple]),
+    !.
+
+get_CD_for_symbol(_,STHOLSymbol,_,sthol):-
+    tptp2X_member(STHOLSymbol,['forall-op','exists-op']),
+    !.
+
+get_CD_for_symbol(_,UCDSymbol,_,unknown_cd):-
+    tptp2X_member(UCDSymbol,[type]),
+    !.
+
+get_CD_for_symbol(_,LetSymbol,_,let):-
+    tptp2X_member(LetSymbol,[letrec,definedas]),
+    !.
+
+get_CD_for_symbol(_,_PL1Symbol,LocalCD,LocalCD).
+%----------------------------------------------------------------------------
+%----Variables with types or as definitions
+output_omdoc_omv(Language,TypeOrDefnForm,LocalCD,Indent):-
+    TypeOrDefnForm =.. [Separator,Variable,TypeOrDefn],
+    tptp2X_member(Separator,[':',':=']),
+    !,
+    (   Separator == ':'
+    ->  Name = type
+    ;   Name = definedas
+    ),
+    output_indent(Indent,0),
+    write('<OMATTR>'),
+    nl,
+    Indent2 is Indent + 2,
+    output_indent(Indent2,0),
+    write('<OMATP>'),
+    nl,
+    Indent4 is Indent + 4,
+    output_omdoc_oms(Language,Name,LocalCD,Indent4),
+    output_a_omdoc_formula(Language,TypeOrDefn,LocalCD,Indent4),
+    output_indent(Indent2,0),
+    write('</OMATP>'),
+    nl,
+    output_omdoc_omv(Language,Variable,LocalCD,Indent2),
+    output_indent(Indent,0),
+    write('</OMATTR>'),
+    nl.
+
+output_omdoc_omv(_Language,Variable,_,Indent):-
     output_indent(Indent,0),
     write('<OMV name="'),
     write(Variable),
     write('"/>'),
     nl.
 %----------------------------------------------------------------------------
-output_omdoc_oms(CD,Connective,Indent):-
+output_omdoc_omvs(_Language,[],_,_).
+
+output_omdoc_omvs(Language,[First|Rest],LocalCD,Indent):-
+    output_omdoc_omv(Language,First,LocalCD,Indent),
+    output_omdoc_omvs(Language,Rest,LocalCD,Indent).
+%----------------------------------------------------------------------------
+output_omdoc_oms(Language,Symbol,LocalCD,Indent):-
+    translate_to_omdoc_symbol(Symbol,OmDocSymbol),
     output_indent(Indent,0),
     write('<OMS cd="'),
+    get_CD_for_symbol(Language,OmDocSymbol,LocalCD,CD),
     write(CD),
     write('" name="'),
-    write(Connective),
+    write(OmDocSymbol),
     write('"/>'),
     nl.
 %----------------------------------------------------------------------------
-output_omdoc_oma(CD,Connective,Formulae,Indent):-
+output_omdoc_oma(Language,Connective,Formulae,LocalCD,Indent):-
     output_indent(Indent,0),
     write('<OMA>'),
     nl,
     Indent2 is Indent + 2,
-    output_omdoc_oms(CD,Connective,Indent2),
-    output_omdoc_formula_list(Formulae,Indent2),
+%----No need to output apply connective
+    (   Connective = '@'
+    ->  true
+    ;   output_omdoc_oms(Language,Connective,LocalCD,Indent2)
+    ),
+    output_omdoc_formula_list(Language,Formulae,LocalCD,Indent2),
     output_indent(Indent,0),
     write('</OMA>'),
     nl.
 %----------------------------------------------------------------------------
-output_omdoc_formula_list([],_).
+output_omdoc_formula_list(_Language,[],_,_).
 
-output_omdoc_formula_list([Formula|RestOfFormulae],Indent):-
-    output_a_omdoc_formula(Formula,Indent),
-    output_omdoc_formula_list(RestOfFormulae,Indent).
+output_omdoc_formula_list(Language,[Formula|RestOfFormulae],LocalCD,Indent):-
+    output_a_omdoc_formula(Language,Formula,LocalCD,Indent),
+    output_omdoc_formula_list(Language,RestOfFormulae,LocalCD,Indent).
 %----------------------------------------------------------------------------
-%----Unary Formula
-output_a_omdoc_formula(UnaryFormula,Indent):-
-    tptp_unary_formula(UnaryFormula,'~',Formula),
+%----Variables done first to avoid being instantiated
+output_a_omdoc_formula(Language,Variable,LocalCD,Indent):-
+    looks_like_a_variable(Variable),
     !,
-    output_omdoc_oma(logic1,not,[Formula],Indent).
-
-%----Binary Formula
-output_a_omdoc_formula(BinaryFormula,Indent):-
-    tptp_binary_formula(BinaryFormula,BinaryConnective,LHS,RHS),
-    !,
-    tptp2X_member((BinaryConnective)-(OmDocConnective),
-[('|')-(or), ('&')-(and), ('=>')-(implies), ('<=')-(implied), ('<=>')-(equiv), 
-('<~>')-(xor), ('~&')-(nand), ('~|')-(nor)]),
-    output_omdoc_oma(logic1,OmDocConnective,[LHS,RHS],Indent).
+    output_omdoc_omv(Language,Variable,LocalCD,Indent).
 
 %----Quantified
-output_a_omdoc_formula(QuantifiedFormula,Indent):-
-    tptp_quantified_formula(QuantifiedFormula,Quantifier,[Variable],Formula),
+output_a_omdoc_formula(Language,QuantifiedFormula,LocalCD,Indent):-
+    tptp_quantified_formula(QuantifiedFormula,Quantifier,Variables,Formula),
     !,
     output_indent(Indent,0),
     write('<OMBIND>'),
     nl,
     Indent2 is Indent + 2,
-    tptp2X_member((Quantifier)-(OmDocQuantifier),
-[('!')-(forall),('?')-(exists)]),
-    output_omdoc_oms(quant1,OmDocQuantifier,Indent2),
+    output_omdoc_oms(Language,Quantifier,LocalCD,Indent2),
     output_indent(Indent2,0),
     write('<OMBVAR>'),
     nl,
     Indent4 is Indent2 + 2,
-    output_omdoc_omv(Variable,Indent4),
+    output_omdoc_omvs(Language,Variables,LocalCD,Indent4),
     output_indent(Indent2,0),
     write('</OMBVAR>'),
     nl,
-    output_a_omdoc_formula(Formula,Indent2),
+    output_a_omdoc_formula(Language,Formula,LocalCD,Indent2),
     output_indent(Indent,0),
     write('</OMBIND>'),
     nl.
 
-%----Multiple variables done one at a time
-output_a_omdoc_formula(QuantifiedFormula,Indent):-
-    tptp_quantified_formula(QuantifiedFormula,Quantifier,[Variable|
-MoreVariables],Formula),
-    !,
-    tptp_quantified_formula(SubFormula,Quantifier,MoreVariables,Formula),
-    tptp_quantified_formula(NewFormula,Quantifier,[Variable],SubFormula),
-    output_a_omdoc_formula(NewFormula,Indent).
+%----Binary Formula
+output_a_omdoc_formula(Language,BinaryFormula,LocalCD,Indent):-
+    tptp_binary_formula(BinaryFormula,BinaryConnective,LHS,RHS),
+    !,
+    output_omdoc_oma(Language,BinaryConnective,[LHS,RHS],LocalCD,Indent).
+
+%----Unary Formula
+output_a_omdoc_formula(Language,UnaryFormula,LocalCD,Indent):-
+    tptp_unary_formula(UnaryFormula,UnaryConnective,Formula),
+    !,
+    output_omdoc_oma(Language,UnaryConnective,[Formula],LocalCD,Indent).
+
+%----Tuple
+output_a_omdoc_formula(Language,[First|Rest],LocalCD,Indent):-
+    !,
+    output_omdoc_oma(Language,'[]',[First|Rest],LocalCD,Indent).
 
 %----Atomic formulae
-output_a_omdoc_formula(Atom,Indent):-
+output_a_omdoc_formula(Language,Atom,LocalCD,Indent):-
     atom(Atom),
     !,
-    output_omdoc_omv(Atom,Indent).
+    output_omdoc_oms(Language,Atom,LocalCD,Indent).
 
-output_a_omdoc_formula(Atom,Indent):-
+output_a_omdoc_formula(Language,Atom,LocalCD,Indent):-
     Atom =.. [Principle|Arguments],
-    output_omdoc_oma(xmp,Principle,Arguments,Indent).
+    output_omdoc_oma(Language,Principle,Arguments,LocalCD,Indent).
 %----------------------------------------------------------------------------
-output_omdoc_fmp(Formula):-
-    write('<FMP>'),
-    nl,
-    write('  <OMOBJ>'),
+output_omdoc_obj(Language,Formula,LocalCD,Indent):-
+    output_indent(Indent,0),
+    write('<OMOBJ xmlns="http://www.openmath.org/OpenMath">'),
     nl,
-    output_a_omdoc_formula(Formula,4),
-    write('  </OMOBJ>'),
+    Indent2 is Indent + 2,
+    output_a_omdoc_formula(Language,Formula,LocalCD,Indent2),
+    output_indent(Indent,0),
+    write('</OMOBJ>'),
+    nl.
+%----------------------------------------------------------------------------
+output_omdoc_fmp(Language,Formula,LocalCD,Indent):-
+    output_indent(Indent,0),
+    write('<FMP>'),
     nl,
+    Indent2 is Indent + 2,
+    output_omdoc_obj(Language,Formula,LocalCD,Indent2),
+    output_indent(Indent,0),
     write('</FMP>'),
     nl.
 %----------------------------------------------------------------------------
-output_omdoc_formulae([]).
+output_omdoc_formulae([],_).
 
-output_omdoc_formulae([fof(Name,conjecture,Formula)|RestOfFormulae]):-
+%----Skip types because they are done in symbol introduction
+output_omdoc_formulae([TypeFormula|RestOfFormulae],LocalCD):-
+    TypeFormula =.. [_,_Name,type,Symbol:_|_],
+    atomic(Symbol),
     !,
-    write('<assertion type="conjecture" id="'),
+    output_omdoc_formulae(RestOfFormulae,LocalCD).
+
+%----Type assertions - for complex case where a non-atomic is typed.
+output_omdoc_formulae([TypeFormula|RestOfFormulae],LocalCD):-
+    TypeFormula =.. [Language,Name,_,Formula:Type|_],
+    !,
+    write('<type xml:id="'),
     write(Name),
-%UNKNOWN USE OF foo    write('" style="foo" generated-by="TSTP">'),
-    write('" generated-by="TSTP">'),
+    write('" system="#simple-types">'),
     nl,
-    output_omdoc_fmp(Formula),
-    write('</'),
-    write(assertion),
-    write('>'),
+    output_omdoc_obj(Language,Formula,LocalCD,2),
+    output_omdoc_obj(Language,Type,LocalCD,2),
+    write('</type>'),
+    nl,
+    nl,
+    output_omdoc_formulae(RestOfFormulae,LocalCD).
+
+%----Top level definitions
+output_omdoc_formulae([DefnFormula|RestOfFormulae],LocalCD):-
+    DefnFormula =.. [Language,_,definition,Name:=Definition|_],
+    !,
+    write('<definition for="'),
+    write(Name),
+    write('" type="simple">'),
     nl,
+    output_omdoc_obj(Language,Definition,LocalCD,2),
+    write('</definition>'),
     nl,
-    output_omdoc_formulae(RestOfFormulae).
+    nl,
+    output_omdoc_formulae(RestOfFormulae,LocalCD).
 
-output_omdoc_formulae([fof(Name,Type,Formula)|RestOfFormulae]):-
+output_omdoc_formulae([Conjecture|RestOfFormulae],LocalCD):-
+    Conjecture =.. [Language,Name,conjecture,Formula|_],
     !,
+    write('<assertion type="conjecture" xml:id="'),
+    write(Name),
+    write('">'),
+    nl,
+    output_omdoc_fmp(Language,Formula,LocalCD,0),
+    write('</assertion>'),
+    nl,
+    nl,
+    output_omdoc_formulae(RestOfFormulae,LocalCD).
+
+%----Regular formulae
+output_omdoc_formulae([NonConjecture|RestOfFormulae],LocalCD):-
+    NonConjecture =.. [Language,Name,Role,Formula|_],
     write('<'),
-    write(Type),
-    write(' id="'),
+    write(Role),
+    write(' xml:id="'),
     write(Name),
-%UNKNONW USE OF foo    write('" style="foo" generated-by="TSTP">'),
-    write('" generated-by="TSTP">'),
+    write('">'),
     nl,
-    output_omdoc_fmp(Formula),
+    output_omdoc_fmp(Language,Formula,LocalCD,0),
     write('</'),
-    write(Type),
+    write(Role),
     write('>'),
     nl,
     nl,
-    output_omdoc_formulae(RestOfFormulae).
+    output_omdoc_formulae(RestOfFormulae,LocalCD).
 %----------------------------------------------------------------------------
-output_omdoc_symbols([]).
+output_omdoc_symbols([],_,_).
 
-output_omdoc_symbols([Symbol/_|RestOfPairs]):-
-    write('<symbol id="'),
-    write(Symbol),
+output_omdoc_symbols([Symbol|RestOfSymbols],AnnotatedFormulae,LocalCD):-
+    translate_to_omdoc_symbol(Symbol,Translated),
+    Symbol \== Translated,
+    !,
+    output_omdoc_symbols(RestOfSymbols,AnnotatedFormulae,LocalCD).
+
+output_omdoc_symbols([Symbol|RestOfSymbols],AnnotatedFormulae,LocalCD):-
+    tptp2X_member(TypeFormulaForSymbol,AnnotatedFormulae),
+    TypeFormulaForSymbol =.. [Language,_,type,Symbol:Type|_],
+%----It must be atomic, but constrast with non-atomic in output_omdoc_formulae
+    atomic(Symbol),
+    !,
+    write('<symbol name="'),
+    write_ID_encoded(Symbol),
+    write('">'),
+    nl,
+    write('  <type system="simpletypes">'),
+    nl,
+    output_omdoc_obj(Language,Type,LocalCD,4),
+    write('  </type>'),
+    nl,
+    write('</symbol>'),
+    nl,
+    output_omdoc_symbols(RestOfSymbols,AnnotatedFormulae,LocalCD).
+
+output_omdoc_symbols([Symbol|RestOfSymbols],AnnotatedFormulae,LocalCD):-
+    write('<symbol name="'),
+    write_ID_encoded(Symbol),
     write('"/>'),
     nl,
-    output_omdoc_symbols(RestOfPairs).
+    output_omdoc_symbols(RestOfSymbols,AnnotatedFormulae,LocalCD).
+%----------------------------------------------------------------------------
+output_omdoc_types([]).
+
+output_omdoc_types([Type|RestOfTypes]):-
+    translate_to_omdoc_symbol(Type,Translated),
+    Type \== Translated,
+    !,
+    output_omdoc_types(RestOfTypes).
+
+output_omdoc_types([Type|RestOfTypes]):-
+    write('<symbol name="'),
+    write_ID_encoded(Type),
+    write(' role="type"/>'),
+    nl,
+    output_omdoc_types(RestOfTypes).
 %----------------------------------------------------------------------------
 %----Extract header info from TPTP header
 extract_omdoc_header_information(FileHeader,ProblemName):-
@@ -162,26 +386,42 @@
 %----If any member failed, return default nothings
 extract_omdoc_header_information(_,unknown).
 %----------------------------------------------------------------------------
-output_omdoc(FileHeader,FunctorStructures,UnsignedPredicateStructures,
-Formulae):-
+output_omdoc(FileHeader,Symbols,AnnotatedFormulae):-
     extract_omdoc_header_information(FileHeader,ProblemName),
+    translate_to_ID_encoded(ProblemName,LocalCD),
 %----Output OmDoc header
     write('<?xml version="1.0"?>'),
     nl,
     write('<!DOCTYPE omdoc PUBLIC "-//OMDoc//DTD OMDoc V1.1//EN" "http://www.mathweb.org/~jzimmer/omdoc1.1.dtd" []>'),
     nl,
-
-    write('<omdoc xmlns="http://www.mathweb.org/omdoc" id="'),
-    write(ProblemName),
+    write('<omdoc xmlns="http://www.mathweb.org/omdoc" xml:id="'),
+    write(LocalCD),
+    write('.omdoc">'),
+    nl,
+    write('<theory xml:id="'),
+    write(LocalCD),
     write('">'),
     nl,
-    write('<theory id="xmp">'),
+    write('<imports from="http://cds.omdoc.org/logics/sthol.omdoc#sthol"/>'),
+    nl,
     nl,
+%    examine_formulae_for_types(AnnotatedFormulae,_,AtomicTypes),
+%    write('<!-- Types -->'),
+%    nl,
+%    output_omdoc_types(AtomicTypes),
+%    nl,
+    examine_formulae_for_definitions(AnnotatedFormulae,DefinedSymbols),
+%DEBUG write('Defined '),write(DefinedSymbols),nl,
+    write('<!-- Defined symbols -->'),
+    nl,
+    output_omdoc_symbols(DefinedSymbols,AnnotatedFormulae,LocalCD),
+%DEBUG write('Symbols '),write(Symbols),nl,
+    write('<!-- Non-defined symbols -->'),
     nl,
-    output_omdoc_symbols(FunctorStructures),
-    output_omdoc_symbols(UnsignedPredicateStructures),
+    output_omdoc_symbols(Symbols,AnnotatedFormulae,LocalCD),
     nl,
-    output_omdoc_formulae(Formulae),
+    translate_to_ID_encoded(ProblemName,LocalCD),
+    output_omdoc_formulae(AnnotatedFormulae,LocalCD),
     write('</theory>'),
     nl,
     write('</omdoc>'),
@@ -205,7 +445,7 @@
 omdoc(omdoc,Clauses,_):-
     tptp_clauses(Clauses),
     !,
-    write('%----No CNF format available in OmDoc'),
+    write('ERROR: No CNF format available in OmDoc'),
     nl.
 
 %----Output FOF-omdoc-syntax
@@ -213,23 +453,22 @@
     tptp_formulae(Formulae),
     !,
 %----Extract predicates and functors
-    examine_formulae_for_predicates(Formulae,_,UnsignedPredicateStructures,_),
-    examine_formulae_for_functors(Formulae,FunctorStructures,_),
+    examine_formulae_for_symbols(Formulae,SymbolStructures,Symbols),
 %----Check for duplicate arities
-    omdoc_consistent(UnsignedPredicateStructures),
-    omdoc_consistent(FunctorStructures),
+    omdoc_consistent(SymbolStructures),
 %----Do translation
-    output_omdoc(FileHeader,FunctorStructures,UnsignedPredicateStructures,
-Formulae).
+    output_omdoc(FileHeader,Symbols,Formulae).
 
 %----unknown format (to be prepared for the future)
 omdoc(omdoc,_,_):-
     !,
-    write('%----unknown tptp input format'),
+    write('ERROR: Unknown tptp input format'),
     nl.
 %----------------------------------------------------------------------------
 %----Provide information about the OmDoc format
-omdoc_format_information('%','.omdoc').
+%----Have to suppress comments because the <?xml must come first
+% omdoc_format_information('<!-- '-' -->','.omdoc').
+omdoc_format_information('','.omdoc').
 %----------------------------------------------------------------------------
 %----Provide information about the OmDoc file
 omdoc_file_information(format,omdoc,'OmDoc format').
diff -ur 1/TPTP2X/format.oscar 2/TPTP2X/format.oscar
--- 1/TPTP2X/format.oscar	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/format.oscar	2012-08-13 14:45:12.000000000 -0400
@@ -92,7 +92,7 @@
     output_oscar_term(Variable).
 %------------------------------------------------------------------------------
 %----Output atoms 
-oscar_output_atom(Atom):-
+oscar_output_atom(_,Atom):-
     output_oscar_term(Atom).
 %------------------------------------------------------------------------------
 %----Write a oscar formula in fof form
@@ -137,7 +137,7 @@
 oscar(oscar,Clauses,_):-
     tptp_clauses(Clauses),
     !,
-    write(';----No CNF format available in OSCAR'),
+    write('ERROR: No CNF format available in OSCAR'),
     nl.
 
 oscar(oscar,Formulae,_):-
diff -ur 1/TPTP2X/format.otter 2/TPTP2X/format.otter
--- 1/TPTP2X/format.otter	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.otter	2012-08-13 14:45:12.000000000 -0400
@@ -43,17 +43,65 @@
 otter_output_variable(Variable):-
     write(Variable).
 %------------------------------------------------------------------------------
+translate_otter_defined(Variable,Variable):-
+    var(Variable),
+    !.
+
+translate_otter_defined([],[]):-
+    !.
+
+translate_otter_defined([First|Rest],[TranslatedFirst|TranslatedRest]):-
+    !,
+    translate_otter_defined(First,TranslatedFirst),
+    translate_otter_defined(Rest,TranslatedRest).
+
+translate_otter_defined(DefinedAtom,OtterDefinedAtom):-
+    tptp2X_member(DefinedAtom-OtterDefinedAtom,[
+'$less'-'$LT',
+'$lesseq'-'$LE',
+'$greater'-'$GT',
+'$greatereq'-'$GE',
+'$sum'-'$SUM',
+'$difference'-'$DIFF',
+'$product'-'$PROD',
+'$is_int'-'$INT'
+]),
+    !.
+
+translate_otter_defined(Atom,Atom):-
+    atomic(Atom),
+    !.
+
+translate_otter_defined('$uminus'(X),- TranslatedX):-
+    !,
+    translate_otter_defined(X,TranslatedX).
+
+translate_otter_defined(Function,TranslatedFunction):-
+    Function =.. FunctionList,
+    translate_otter_defined(FunctionList,TranslatedFunctionList),
+    TranslatedFunction =.. TranslatedFunctionList.
+%------------------------------------------------------------------------------
 %----Generic output of atoms
-otter_output_atom($(true)):-
+otter_output_atom(_,'$true'):-
     !,
     write('$T').
 
-otter_output_atom($(false)):-
+otter_output_atom(_,'$false'):-
     !,
     write('$F').
 
-otter_output_atom(Atom):-
-    write(Atom).
+otter_output_atom(Language,'$tptp_equal'(X,Y)):-
+    !,
+    otter_output_atom(Language,equal(X,Y)).
+
+otter_output_atom(Language,'$tptp_not_equal'(X,Y)):-
+    !,
+    write('- '),
+    otter_output_atom(Language,equal(X,Y)).
+
+otter_output_atom(_,Atom):-
+    translate_otter_defined(Atom,TranslatedAtom),
+    write(TranslatedAtom).
 %------------------------------------------------------------------------------
 %==============================================================================
 %----Output of FOF
@@ -100,7 +148,7 @@
     write(Status),
     write('.'),
     nl,
-    output_generic_formula(otter,Formula),
+    output_generic_formula(otter,fof,Formula),
     write('.'),
     nl.
 %------------------------------------------------------------------------------
@@ -122,11 +170,11 @@
 output_otter_signed_literal(--Atom):-
     !,
     write('-'),
-    otter_output_atom(Atom).
+    otter_output_atom(cnf,Atom).
 
 output_otter_signed_literal(++Atom):-
     write(' '),
-    otter_output_atom(Atom).
+    otter_output_atom(cnf,Atom).
 %------------------------------------------------------------------------------
 %----Output the literals of the clause in Otter format
 %----Special case of an empty clause
@@ -154,7 +202,7 @@
     !.
 
 %----Ignore a single true clause (also if it's the last oe :-()
-output_otter_clauses([input_clause(_Name,_Status,[$(true)])]):-
+output_otter_clauses([input_clause(_Name,_Status,['$true'])]):-
     !.
 
 %----If the clause has an acceptable status then output
@@ -290,13 +338,19 @@
     extract_otter_lists(OtherFormulae,RestOfListNames,RestOfNameListPairs,
 NormalFormulae).
 %------------------------------------------------------------------------------
-%----Negate the conjecture formula (assume there is only one)
+%----Negate the conjecture formula (only one)
+negate_otter_conjecture(Formulae,_):-
+    tptp2X_select(fof(_,conjecture,_),Formulae,OtherFormulae),
+    tptp2X_member(fof(_,conjecture,_),OtherFormulae),
+    !,
+    write('%----ERROR : More than one conjecture'),nl,
+    fail.
+
 negate_otter_conjecture(Formulae,ProofFormulae):-
     tptp2X_select(fof(Name,conjecture,Formula),Formulae,OtherFormulae),
     !,
 %----Need this for dodgy processing in Ratify
-    write('%----NOTE WELL: conjecture has been negated'),
-    nl,
+    write('%----This is the conjecture with negated conjecture'),nl,
     tptp2X_append(OtherFormulae,[fof(Name,negated_conjecture,~(Formula))],
 ProofFormulae).
 
@@ -305,8 +359,11 @@
 %------------------------------------------------------------------------------
 %----Output all the clauses in Otter format
 otter(otter:SoSSpecifier:OtterOptions,Formulae,_):-
+    tptp_formulae_language(Formulae,[fof,cnf,input_clause]),
+    !,
+    tptp_ensure_short_form(Formulae,ShortFormulae),
 %----Negate conjecture if FOF
-    negate_otter_conjecture(Formulae,ProofFormulae),
+    negate_otter_conjecture(ShortFormulae,ProofFormulae),
     tptp2X_member(SoSSpecifier,[conjecture,hypothesis,positive,negative,
 unit,none,all]),
     extract_otter_lists(ProofFormulae,[hints2,passive],NameListPairs,
@@ -315,6 +372,10 @@
     output_otter_header(OtterOptions),
     output_otter_lists([sos-SoS,usable-Usable|NameListPairs]).
 
+otter(otter:_:_,_,_):-
+    write('ERROR: Only FOF and CNF format for Otter'),
+    nl.
+
 %----Short cut for default to auto mode
 otter(otter,Formulae,FileHeader):-
     otter(otter:none:[set(auto)],Formulae,FileHeader).
Only in 1/TPTP2X: format.pitp
diff -ur 1/TPTP2X/format.prefix 2/TPTP2X/format.prefix
--- 1/TPTP2X/format.prefix	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/format.prefix	2012-08-13 14:45:12.000000000 -0400
@@ -7,44 +7,35 @@
 %==============================================================================
 %------------------------------------------------------------------------------
 %----Output variables 
-prefix_output_variable(Variable):-
+prefix_output_variable(_Langauge,Variable):-
     tptp_output_variable(Variable).
 %------------------------------------------------------------------------------
-prefix_output_atom_list_by_hand([One]):-
+prefix_output_atom_list(Langauge,[One]):-
     !,
-    prefix_output_atom_by_hand(One).
+    prefix_output_atom(Langauge,One).
 
-prefix_output_atom_list_by_hand([One,Two|Rest]):-
-    prefix_output_atom_by_hand(One),
+prefix_output_atom_list(Langauge,[One,Two|Rest]):-
+    prefix_output_atom(Langauge,One),
     write(','),
-    prefix_output_atom_list_by_hand([Two|Rest]).
+    prefix_output_atom_list(Langauge,[Two|Rest]).
 %------------------------------------------------------------------------------
-prefix_output_atom_by_hand(Variable):-
+prefix_output_atom(Language,Variable):-
     looks_like_a_variable(Variable),
     !,
-    prefix_output_variable(Variable).
+    prefix_output_variable(Language,Variable).
 
-prefix_output_atom_by_hand($(Reserved)):-
-    !,
-    write('$'),
-    prefix_output_atom_by_hand(Reserved).
-
-prefix_output_atom_by_hand(Atom):-
+prefix_output_atom(_Language,Atom):-
     atomic(Atom),
     !,
     write(Atom).
 
-prefix_output_atom_by_hand(Term):-
+prefix_output_atom(Language,Term):-
     Term =.. [Functor|Arguments],
     write(Functor),
     write('('),
-    prefix_output_atom_list_by_hand(Arguments),
+    prefix_output_atom_list(Language,Arguments),
     write(')').
 %------------------------------------------------------------------------------
-%----Output atoms 
-prefix_output_atom(Atom):-
-    prefix_output_atom_by_hand(Atom).
-%------------------------------------------------------------------------------
 %==============================================================================
 %----FOF format
 %==============================================================================
diff -ur 1/TPTP2X/format.protein 2/TPTP2X/format.protein
--- 1/TPTP2X/format.protein	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.protein	2012-08-13 14:45:12.000000000 -0400
@@ -32,11 +32,11 @@
     write('protein_integer_'),
     write(Integer).
 
-protein_output_atom_by_hand($true):-
+protein_output_atom_by_hand('$true'):-
     !,
     write(true).
     
-protein_output_atom_by_hand($false):-
+protein_output_atom_by_hand('$false'):-
     !,
     write(false).
     
@@ -54,7 +54,7 @@
 %------------------------------------------------------------------------------
 %----Write an atom for PROTEIN
 write_protein_atom(Atom):-
-    (Atom =.. [equal,LHS,RHS] ->
+    (Atom =.. ['$tptp_equal',LHS,RHS] ->
 %----Use the next line for writing equality in prefix notation
 %       write(Atom);
 %----Use the next three lines for writing equality in infix notation
@@ -65,7 +65,7 @@
     protein_output_atom_by_hand(Atom)).
 %----If integers give shit (as previously), change the writes to
 %----protein_output_atom_by_hand
-%-------------------------------------------------------------------
+%------------------------------------------------------------------------------
 %----Output the atoms, separated and terminated as indicated.
 %----First case, there never were any of this sign.
 output_protein_atoms([],_,_,_,To_write_if_none,Terminator,no):-
@@ -119,7 +119,7 @@
     Neg_Template =.. [--, Atom], 
     findall(Atom, tptp2X_member(Neg_Template, Literals), Neg_atoms).
 
-%----
+%------------------------------------------------------------------------------
 output_protein_clause(Name, theorem, Literals) :-
         !,
     (theorem_found
@@ -137,6 +137,17 @@
     output_protein_atoms(Neg_atoms, Next_NL,'    ', ', ', '', '.', _),
     nl, nl.
        
+%----Hack to output $false as a contradiction
+output_protein_clause(Name, Status, [++ '$false']):-
+    !,
+    output_protein_clause(Name,Status,[++dummy_for_contradiction]),
+    output_protein_clause(Name,Status,[--dummy_for_contradiction]).
+
+output_protein_clause(Name, Status, [++ '$true']):-
+    !,
+    output_protein_clause(Name,Status,[++dummy_for_tautology,
+--dummy_for_tautology]).
+
 output_protein_clause(Name, Status, Literals) :-
     output_header_and_sort(Name, Status, Literals, Pos_atoms, Neg_atoms),
     output_protein_atoms(Pos_atoms,no,'','; ','false','',Next_NL),
@@ -156,14 +167,14 @@
 Rest_of_clauses]):-
     output_protein_clause(Name, Status, Literals),
     output_each_protein_clause(Rest_of_clauses).
-%-------------------------------------------------------------------
+%------------------------------------------------------------------------------
 protein_retract_all(Atom):-
     retract(Atom),
     !,
     protein_retract_all(Atom).
 
 protein_retract_all(_).
-%-------------------------------------------------------------------
+%------------------------------------------------------------------------------
 :-dynamic completions_file/1.
 protein(protein, Clauses, _):-
     tptp_clauses(Clauses),
@@ -182,8 +193,8 @@
     write('%----FOF format not yet installed in PROTEIN'),
     nl.
 
-%-------------------------------------------------------------------
+%------------------------------------------------------------------------------
 protein_format_information('%','.tme').
 protein_file_information(format,protein,'PROTEIN format').
-%-------------------------------------------------------------------
+%------------------------------------------------------------------------------
 
diff -ur 1/TPTP2X/format.prover9 2/TPTP2X/format.prover9
--- 1/TPTP2X/format.prover9	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/format.prover9	2012-08-13 14:45:12.000000000 -0400
@@ -23,25 +23,25 @@
     write(Variable).
 %------------------------------------------------------------------------------
 %----Generic output of atoms
-prover9_output_atom($(true)):-
+prover9_output_atom(_,'$true'):-
     !,
     write('$T').
 
-prover9_output_atom($(false)):-
+prover9_output_atom(_,'$false'):-
     !,
     write('$F').
 
-prover9_output_atom(not_equal(X,Y)):-
+prover9_output_atom(_,'$tptp_not_equal'(X,Y)):-
     write(X),
     write(' != '),
     write(Y).
 
-prover9_output_atom(equal(X,Y)):-
+prover9_output_atom(_,'$tptp_equal'(X,Y)):-
     write(X),
     write(' = '),
     write(Y).
 
-prover9_output_atom(Atom):-
+prover9_output_atom(_,Atom):-
     write(Atom).
 %------------------------------------------------------------------------------
 %==============================================================================
@@ -90,8 +90,13 @@
     write('.'),
     nl,
     single_variable_quantification(Formula,NewFormula),
-    output_generic_formula(prover9,NewFormula),
-    write('.'),
+    output_generic_formula(prover9,fof,NewFormula),
+    nl,
+    write('# label('),
+    write(Name),
+    write(') # label('),
+    write(Status),
+    write(').'),
     nl.
 %------------------------------------------------------------------------------
 %----Write out each formula in TPTP format
@@ -109,19 +114,19 @@
 %==============================================================================
 %------------------------------------------------------------------------------
 %----Output a literal with - for negative, nothing for positive
-output_prover9_signed_literal(--equal(X,Y)):-
+output_prover9_signed_literal(--'$tptp_equal'(X,Y)):-
     !,
     write(' '),
-    prover9_output_atom(not_equal(X,Y)).
+    prover9_output_atom(cnf,'$tptp_not_equal'(X,Y)).
 
 output_prover9_signed_literal(--Atom):-
     !,
     write('-'),
-    prover9_output_atom(Atom).
+    prover9_output_atom(cnf,Atom).
 
 output_prover9_signed_literal(++Atom):-
     write(' '),
-    prover9_output_atom(Atom).
+    prover9_output_atom(cnf,Atom).
 %------------------------------------------------------------------------------
 %----Output the literals of the clause in Prover9 format
 %----Special case of an empty clause
@@ -134,7 +139,12 @@
 output_prover9_clause([OneLiteral]):-
     !,
     output_prover9_signed_literal(OneLiteral),
-    write('.'),
+    nl,
+    write('# label('),
+    write(Name),
+    write(') # label('),
+    write(Status),
+    write(').'),
     nl,
     nl.
 
@@ -167,10 +177,9 @@
 output_prover9_list([],_):-
     !.
 
-%----Output the clauses for the given list, selected by status
 output_prover9_list(Clauses):-
     tptp_clauses(Clauses),
-    write('clauses(sos).'),
+    write('formulas(sos).'),
     nl,
     nl,
     output_prover9_clauses(Clauses),
@@ -190,12 +199,20 @@
     nl.
 %------------------------------------------------------------------------------
 %----Negate the conjecture formula (assume there is only one)
+negate_prover9_conjecture(Formulae,_ProofFormulae):-
+    tptp2X_select(fof(_Name,conjecture,_Formula),Formulae,OtherFormulae),
+    tptp2X_member(fof(_,conjecture,_),OtherFormulae),
+    !,
+    write('%----ERROR : More than one conjecture'),
+    nl,
+    fail.
+
 negate_prover9_conjecture(Formulae,ProofFormulae):-
     tptp2X_select(fof(Name,conjecture,Formula),Formulae,
 OtherFormulae),
     !,
-%----Need this for dodgy processing in Ratify
-    write('%----NOTE WELL: conjecture has been negated'),
+%----Need this for dodgy processing in Ratify and SystemOnTPTP
+    write('%----This is the conjecture with negated conjecture'),
     nl,
     tptp2X_append(OtherFormulae,[fof(Name,negated_conjecture,
 ~(Formula))],ProofFormulae).
@@ -206,8 +223,7 @@
 %----Output all the clauses in Prover9 format
 prover9(prover9:Prover9Options,Formulae,_):-
     negate_prover9_conjecture(Formulae,ProofFormulae),
-    output_prover9_options(
-[set(prolog_style_variables)|Prover9Options]),
+    output_prover9_options([set(prolog_style_variables)|Prover9Options]),
     output_prover9_list(ProofFormulae).
 
 prover9(prover9,Formulae,_):-
diff -ur 1/TPTP2X/format.pttp 2/TPTP2X/format.pttp
--- 1/TPTP2X/format.pttp	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.pttp	2012-08-13 14:45:12.000000000 -0400
@@ -25,6 +25,38 @@
     nl.
 %--------------------------------------------------------------------
 %----Output a literal, compiling negation into the name
+output_pttp_literal(++ '$true', '','not_'):-
+    !,
+    write(true).
+
+output_pttp_literal(++ '$false','','not_'):-
+    !,
+    write(false).
+
+output_pttp_literal(-- '$true', '','not_'):-
+    !,
+    write(false).
+
+output_pttp_literal(-- '$false','','not_'):-
+    !,
+    write(true).
+
+output_pttp_literal(++ '$true', 'not_',''):-
+    !,
+    write(false).
+
+output_pttp_literal(++ '$false','not_',''):-
+    !,
+    write(true).
+
+output_pttp_literal(-- '$true', 'not_',''):-
+    !,
+    write(true).
+
+output_pttp_literal(-- '$false','not_',''):-
+    !,
+    write(false).
+
 output_pttp_literal(++Atom,PositivePrefix,_):-
     write(PositivePrefix),
     write(Atom).
@@ -136,7 +168,7 @@
 pttp(pttp,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('%----No FOF format available in PTTP'),
+    write('ERROR: No FOF format available in PTTP'),
     nl.
 %--------------------------------------------------------------------
 %----Provide information about the PTTP format
diff -ur 1/TPTP2X/format.satchmo 2/TPTP2X/format.satchmo
--- 1/TPTP2X/format.satchmo	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/format.satchmo	2012-08-13 14:45:12.000000000 -0400
@@ -159,9 +159,9 @@
 %----Write a satchmo formula in fof form
 output_satchmo_formula(fof(_Name,Status,Formula)) :- 
     (Status = theorem ->
-	output_formula(satchmo,~(Formula),4,0,_)
+	output_formula(satchmo,~(Formula),unknown,4,0,_)
     ;
-	output_formula(satchmo,Formula,4,0,_)
+	output_formula(satchmo,Formula,unknown,4,0,_)
     ),
     write('.').
 	
diff -ur 1/TPTP2X/format.sem 2/TPTP2X/format.sem
--- 1/TPTP2X/format.sem	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.sem	2012-08-13 14:45:12.000000000 -0400
@@ -1,263 +1,276 @@
-%=======================================================================%
-%----This outputs TPTP Problem Set clauses accompanied by function -----%
-%----declarations in a format acceptable to the SEM system. ------------%
-%-----------------------------------------------------------------------%
-%----Written by Nikolay Pelov, Nov,1999.
-%----Based on the module for FINDER.
-%----Updated by Geoff Sutcliffe, October 2002
-%=======================================================================%
-%=======================================================================%
-%----Module to output TPTP Problem Set CLAUSES in a SEM format. --------%
-%----Main entry point :-output_sem_clauses/1.---------------------------%
-%=======================================================================%
-%----------------------------------------------------------------------
-%----Output the atoms
-sem_output_atom(equal(A,B)):-
-    !,
-    write(A),
-    write(' = '),
-    write(B).
-sem_output_atom(Atom):-
-    write(Atom).
-
-output_sem_literal(--equal(A,B)):-
-    !,
-    write(A),
-    write(' != '),
-    write(B).
-output_sem_literal(++Atom):-
-    sem_output_atom(Atom).
-
-output_sem_literal(--Atom):-
-    write('-'),
-    sem_output_atom(Atom).
-
-output_sem_literals([OneAtom]) :-
-    !,
-    output_sem_literal(OneAtom).
-
-output_sem_literals([OneAtom,TwoAtoms|RestAtoms]) :-
-    output_sem_literal(OneAtom),
-    write(' | '),
-    output_sem_literals([TwoAtoms|RestAtoms]).
-
-%----------------------------------------------------------------------
-%----Output the clauses in SEM format.
-
-output_sem_clause([]):-
-    !,
-    write('%---Empty clause---------------------------------------------------'), 
-    nl.
-output_sem_clause(Literals):-
-    write('[ '),
-    output_sem_literals(Literals),
-    write(' ]'),nl,
-    nl.
-%----------------------------------------------------------------------
-output_sem_clause_list([]).
-
-output_sem_clause_list([input_clause(Name,Status,Literals)|
-RestOfClauses]):-
-    !,
-    write('% '),
-    write(Name),
-    write(', '),
-    write(Status),
-    write('.'),
-    nl,
-    output_sem_clause(Literals),
-    output_sem_clause_list(RestOfClauses).
-%----------------------------------------------------------------------
-%----Output clauses as a SEM clause list.
-%----Skip empty list and FOL formulae.
-output_sem_clauses([]):-
-    !,
-    write('%---No clauses to output---------------------------------------------------'), 
-    nl.
-
-output_sem_clauses(ClauseList):-
-    !,
-    write('%---Clauses to model-------------------------------------------------------'),
-    nl,
-    output_sem_clause_list(ClauseList).
-
-%=====================================================================%
-%----Module to output FUNCTION DECLARATIONS for functions occurring --%
-%----in TPTP Problem Set clauses in SEM format. ----------------------%
-%----Main entry point: output_sem_function_declarations/1.------------%
-%=====================================================================%
-%----------------------------------------------------------------------
-%----For each parameter in ParameterList write the default sort 
-%----declaration.
-output_sem_argument_sorts(0):-
-    !.
-
-output_sem_argument_sorts(Arity):-
-    write(' default'),
-    Arity1 is Arity - 1,
-    output_sem_argument_sorts(Arity1).
-
-
-%----------------------------------------------------------------------
-%----Output an appropriate variable declaration for each variable.
-
-declare_sem_variable(Variable):-
-    !,
-    write(' '),
-    write(Variable).
-%----------------------------------------------------------------------
-%----Output an appropriate function declaration for each function symbol.
-%----Don't do integers because SEM knows about them already
-declare_sem_function(Integer/0):-
-    integer(Integer),
-    !.
-
-declare_sem_function(Name/Arity):-
-    !,
-    write('{ '),
-    write(Name),
-    write(':'),
-    output_sem_argument_sorts(Arity),
-    write(' -> default }'),
-    nl.
-%----------------------------------------------------------------------
-%----Output an appropriate predicate declaration for each predicate.
-
-declare_sem_predicate(Name/Arity):-
-    !,
-    write('{ '),
-    write(Name),
-    write(': '),
-    output_sem_argument_sorts(Arity),
-    write(' -> BOOL }'),
-    nl.
-
-%----------------------------------------------------------------------
-declare_sem_function_list([]).
-
-declare_sem_function_list([FirstFunction|RestOfFunctions]):-
-    declare_sem_function(FirstFunction),
-    declare_sem_function_list(RestOfFunctions).
-
-declare_sem_functions([]) :- 
-    !.
-
-declare_sem_functions(FunctorStructures):-
-    !,
-    write('%---Function declarations--------------------------------------------------'),
-    nl,
-    declare_sem_function_list(FunctorStructures),
-    nl.
-
-%----------------------------------------------------------------------
-declare_sem_predicate_list([]).
-
-%----Ignore equal, which is built in
-declare_sem_predicate_list([equal/2|RestOfPredicates]):-
-    !,
-    declare_sem_predicate_list(RestOfPredicates).
-
-declare_sem_predicate_list([FirstPredicate|RestOfPredicates]):-
-    declare_sem_predicate(FirstPredicate),
-    declare_sem_predicate_list(RestOfPredicates).
-
-declare_sem_predicates([]):- 
-    !.
-
-declare_sem_predicates([equal/2]):- 
-    !.
-
-declare_sem_predicates(UnsignedPredicateStructures):-
-    !,
-    write('%---Predicate declarations-------------------------------------------------'),
-    nl,
-    %---- prop constants have to come first
-    declare_sem_predicate_list(UnsignedPredicateStructures),
-    nl.
-
-%----------------------------------------------------------------------
-declare_sem_variable_list([]).
-
-declare_sem_variable_list([FirstVariable|RestOfVariables]):-
-    declare_sem_variable(FirstVariable),
-    declare_sem_variable_list(RestOfVariables).
-
-declare_sem_variables([]) :- 
-    !.
-
-declare_sem_variables(Variables):-
-    !,
-    write('%---Variable declarations--------------------------------------------------'),
-    nl,
-    write('<'),
-    declare_sem_variable_list(Variables),
-    write(': default >'),
-    nl.
-
-%----------------------------------------------------------------------
-%----Output function declarations for each function occurring in the
-%----clause/formula list.
-output_sem_declarations([]):-
-    !,
-    write('%---No functions to declare------------------------------------------------').
-
-%----If the clause list is not empty then there should be at least one
-%----functor other than equality.
-output_sem_declarations(Formulae):-
-%----Do basic syntactic examination
-    examine_formulae_for_predicates(Formulae,_,UnsignedPredicateStructures,_),
-    examine_formulae_for_functors(Formulae,FunctorStructures,_),
-    tptp2X_syntax_extract_variables(Formulae,_,Variables),
-    declare_sem_predicates(UnsignedPredicateStructures),
-    declare_sem_functions(FunctorStructures),
-    declare_sem_variables(Variables).
-
-%=====================================================================%
-%----Module to output the HEADER for a generic SEM input file. -------%
-%----Main entry point: output_sem_header/1. --------------------------%
-%=====================================================================%
-
-%--------------------------------------------------------------------------
-%----Output a default sort declaration
-output_sem_default_sort(Cardinality):-
-%---Default sort-----------------------------------------------------------
-    write('( default ['), 
-    write(Cardinality),
-    write('] )'),
-    nl.
-%=====================================================================%
-%----Main Program Code.-----------------------------------------------%
-%----Calls each of the above modules in succession, and performs some-%
-%----appropriate error checking.--------------------------------------%
-%=====================================================================%
-%----------------------------------------------------------------------
-%----Output all the clauses in SEM format with appropriate function
-%----declarations. We can pick which clauses to declare or convert by 
-%----setting ToModel parameters lists.
-%----(note that empty lists default to 'none'.)
-
-sem(sem:ToModel:Cardinality,InputFormulae,_):-
-    tptp_clauses(InputFormulae),
-    !, 
-%----Otherwise backtrack and output the error message below
-    output_sem_default_sort(Cardinality),
-%----Use code from format.otter for this ...
-    output_sem_declarations(InputFormulae),
-    extract_otter_sos(InputFormulae,[ToModel],ModelFormulae,_),
-    output_sem_clauses(ModelFormulae),
-    nl.
-
-sem(_,Formulae,_):-
-    tptp_formulae(Formulae),
-    !,
-    write('%----No FOF format available in SEM'),
-    nl.
-%----------------------------------------------------------------------
-%----Provide information about the SEM format.
-sem_format_information('%','.sem').
-%----------------------------------------------------------------------
-%----Provide information about the SEM file.
-sem_file_information(format,sem:toModel:cardinality,
-'ToModel is one of conjecture, hypothesis, not_conjecture, axioms, positive, negative, unit, none, all,
- Cardinality is an integer').
-%----------------------------------------------------------------------
+%=======================================================================%
+%----This outputs TPTP Problem Set clauses accompanied by function -----%
+%----declarations in a format acceptable to the SEM system. ------------%
+%-----------------------------------------------------------------------%
+%----Written by Nikolay Pelov, Nov,1999.
+%----Based on the module for FINDER.
+%----Updated by Geoff Sutcliffe, October 2002
+%=======================================================================%
+%=======================================================================%
+%----Module to output TPTP Problem Set CLAUSES in a SEM format. --------%
+%----Main entry point :-output_sem_clauses/1.---------------------------%
+%=======================================================================%
+%----------------------------------------------------------------------
+%----Output the atoms
+sem_output_atom('$tptp_equal'(A,B)):-
+    !,
+    write(A),
+    write(' = '),
+    write(B).
+sem_output_atom(Atom):-
+    write(Atom).
+
+output_sem_literal(--'$tptp_equal'(A,B)):-
+    !,
+    write(A),
+    write(' != '),
+    write(B).
+output_sem_literal(++Atom):-
+    sem_output_atom(Atom).
+
+output_sem_literal(--Atom):-
+    write('-'),
+    sem_output_atom(Atom).
+
+output_sem_literals([OneAtom]) :-
+    !,
+    output_sem_literal(OneAtom).
+
+output_sem_literals([OneAtom,TwoAtoms|RestAtoms]) :-
+    output_sem_literal(OneAtom),
+    write(' | '),
+    output_sem_literals([TwoAtoms|RestAtoms]).
+
+%----------------------------------------------------------------------
+%----Output the clauses in SEM format.
+
+output_sem_clause([]):-
+    !,
+    write('%---Empty clause---------------------------------------------------'), 
+    nl.
+output_sem_clause(Literals):-
+    write('[ '),
+    output_sem_literals(Literals),
+    write(' ]'),nl,
+    nl.
+%----------------------------------------------------------------------
+output_sem_clause_list([]).
+
+output_sem_clause_list([input_clause(Name,Status,Literals)|
+RestOfClauses]):-
+    !,
+    write('% '),
+    write(Name),
+    write(', '),
+    write(Status),
+    write('.'),
+    nl,
+    output_sem_clause(Literals),
+    output_sem_clause_list(RestOfClauses).
+%----------------------------------------------------------------------
+%----Output clauses as a SEM clause list.
+%----Skip empty list and FOL formulae.
+output_sem_clauses([]):-
+    !,
+    write('%---No clauses to output---------------------------------------------------'), 
+    nl.
+
+output_sem_clauses(ClauseList):-
+    !,
+    write('%---Clauses to model-------------------------------------------------------'),
+    nl,
+    output_sem_clause_list(ClauseList).
+
+%=====================================================================%
+%----Module to output FUNCTION DECLARATIONS for functions occurring --%
+%----in TPTP Problem Set clauses in SEM format. ----------------------%
+%----Main entry point: output_sem_function_declarations/1.------------%
+%=====================================================================%
+%----------------------------------------------------------------------
+%----For each parameter in ParameterList write the default sort 
+%----declaration.
+output_sem_argument_sorts(0):-
+    !.
+
+output_sem_argument_sorts(Arity):-
+    write(' default'),
+    Arity1 is Arity - 1,
+    output_sem_argument_sorts(Arity1).
+
+
+%----------------------------------------------------------------------
+%----Output an appropriate variable declaration for each variable.
+
+declare_sem_variable(Variable):-
+    !,
+    write(' '),
+    write(Variable).
+%----------------------------------------------------------------------
+%----Output an appropriate function declaration for each function symbol.
+%----Don't do integers because SEM knows about them already
+declare_sem_function(Integer/0):-
+    integer(Integer),
+    !.
+
+declare_sem_function(Name/Arity):-
+    !,
+    write('{ '),
+    write(Name),
+    write(':'),
+    output_sem_argument_sorts(Arity),
+    write(' -> default }'),
+    nl.
+%----------------------------------------------------------------------
+%----Output an appropriate predicate declaration for each predicate.
+
+declare_sem_predicate(Name/Arity):-
+    !,
+    write('{ '),
+    write(Name),
+    write(': '),
+    output_sem_argument_sorts(Arity),
+    write(' -> BOOL }'),
+    nl.
+
+%----------------------------------------------------------------------
+declare_sem_function_list([]).
+
+declare_sem_function_list([Functor/_|RestOfFunctions]):-
+    name(Functor,[36|_]),
+    !,
+    declare_sem_function_list(RestOfFunctions).
+
+declare_sem_function_list([FirstFunction|RestOfFunctions]):-
+    declare_sem_function(FirstFunction),
+    declare_sem_function_list(RestOfFunctions).
+
+declare_sem_functions([]) :- 
+    !.
+
+%----Ignore defined
+declare_sem_functions([Functor/_]) :- 
+    name(Functor,[36|_]),
+    !.
+
+declare_sem_functions(FunctorStructures):-
+    !,
+    write('%---Function declarations--------------------------------------------------'),
+    nl,
+    declare_sem_function_list(FunctorStructures),
+    nl.
+
+%----------------------------------------------------------------------
+declare_sem_predicate_list([]).
+
+%----Ignore defined
+declare_sem_predicate_list([Predicate/_|RestOfPredicates]):-
+    name(Predicate,[36|_]),
+    !,
+    declare_sem_predicate_list(RestOfPredicates).
+
+declare_sem_predicate_list([FirstPredicate|RestOfPredicates]):-
+    declare_sem_predicate(FirstPredicate),
+    declare_sem_predicate_list(RestOfPredicates).
+
+declare_sem_predicates([]):- 
+    !.
+
+%----Ignore defined
+declare_sem_predicates([Predicate/_]):- 
+    name(Predicate,[36|_]),
+    !.
+
+declare_sem_predicates(UnsignedPredicateStructures):-
+    !,
+    write('%---Predicate declarations-------------------------------------------------'),
+    nl,
+    %---- prop constants have to come first
+    declare_sem_predicate_list(UnsignedPredicateStructures),
+    nl.
+
+%----------------------------------------------------------------------
+declare_sem_variable_list([]).
+
+declare_sem_variable_list([FirstVariable|RestOfVariables]):-
+    declare_sem_variable(FirstVariable),
+    declare_sem_variable_list(RestOfVariables).
+
+declare_sem_variables([]) :- 
+    !.
+
+declare_sem_variables(Variables):-
+    !,
+    write('%---Variable declarations--------------------------------------------------'),
+    nl,
+    write('<'),
+    declare_sem_variable_list(Variables),
+    write(': default >'),
+    nl.
+
+%----------------------------------------------------------------------
+%----Output function declarations for each function occurring in the
+%----clause/formula list.
+output_sem_declarations([]):-
+    !,
+    write('%---No functions to declare------------------------------------------------').
+
+%----If the clause list is not empty then there should be at least one
+%----functor other than equality.
+output_sem_declarations(Formulae):-
+%----Do basic syntactic examination
+    examine_formulae_for_predicates(Formulae,_,UnsignedPredicateStructures,_),
+    examine_formulae_for_functors(Formulae,FunctorStructures,_),
+    tptp2X_syntax_extract_variables(Formulae,_,Variables),
+    declare_sem_predicates(UnsignedPredicateStructures),
+    declare_sem_functions(FunctorStructures),
+    declare_sem_variables(Variables).
+
+%=====================================================================%
+%----Module to output the HEADER for a generic SEM input file. -------%
+%----Main entry point: output_sem_header/1. --------------------------%
+%=====================================================================%
+
+%--------------------------------------------------------------------------
+%----Output a default sort declaration
+output_sem_default_sort(Cardinality):-
+%---Default sort-----------------------------------------------------------
+    write('( default ['), 
+    write(Cardinality),
+    write('] )'),
+    nl.
+%=====================================================================%
+%----Main Program Code.-----------------------------------------------%
+%----Calls each of the above modules in succession, and performs some-%
+%----appropriate error checking.--------------------------------------%
+%=====================================================================%
+%----------------------------------------------------------------------
+%----Output all the clauses in SEM format with appropriate function
+%----declarations. We can pick which clauses to declare or convert by 
+%----setting ToModel parameters lists.
+%----(note that empty lists default to 'none'.)
+
+sem(sem:ToModel:Cardinality,InputFormulae,_):-
+    tptp_clauses(InputFormulae),
+    !, 
+%----Otherwise backtrack and output the error message below
+    output_sem_default_sort(Cardinality),
+%----Use code from format.otter for this ...
+    output_sem_declarations(InputFormulae),
+    extract_otter_sos(InputFormulae,[ToModel],ModelFormulae,_),
+    output_sem_clauses(ModelFormulae),
+    nl.
+
+sem(_,Formulae,_):-
+    tptp_formulae(Formulae),
+    !,
+    write('ERROR: No FOF format available in SEM'),
+    nl.
+%----------------------------------------------------------------------
+%----Provide information about the SEM format.
+sem_format_information('%','.sem').
+%----------------------------------------------------------------------
+%----Provide information about the SEM file.
+sem_file_information(format,sem:toModel:cardinality,
+'ToModel is one of conjecture, hypothesis, not_conjecture, axioms, positive, negative, unit, none, all,
+ Cardinality is an integer').
+%----------------------------------------------------------------------
diff -ur 1/TPTP2X/format.setheo 2/TPTP2X/format.setheo
--- 1/TPTP2X/format.setheo	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.setheo	2012-08-13 14:45:12.000000000 -0400
@@ -72,6 +72,22 @@
     set_setheo_signs(RestOfLiterals,Sign,RestOfFlippedLiterals).
 %-------------------------------------------------------------------
 %----Output clause in format based on its type.
+%----Special case for the empty clause - make a simple problem
+output_setheo_clause(Style,Type,[]):-
+    !,
+    output_setheo_clauses(Style,[input_clause(positive_dummy,Type,[++dummy]),
+input_clause(negative_dummy,Type,[--dummy])]).
+
+%----Semantic constants
+output_setheo_clause(Style,Type,[++ '$false']):-
+    !,
+    output_setheo_clauses(Style,[input_clause(positive_dummy,Type,[++dummy]),
+input_clause(negative_dummy,Type,[--dummy])]).
+
+output_setheo_clause(Style,Type,[++ '$true']):-
+    !,
+    output_setheo_clauses(Style,[input_clause(dummy,Type,[++dummy,--dummy])]).
+
 %----The default sign (sequent) style
 output_setheo_clause(sign,_,Literals):-
     output_setheo_sign_literals(Literals,++,no,'',';',' <- ',NextNL),
@@ -79,7 +95,7 @@
 
 %----type style for negative non-conjectures. Move one literal across.
 output_setheo_clause(type,Type,[FirstLiteral|RestOfLiterals]):-
-    tptp2X_member(Type,[axiom,hypothesis,lemma,definition]),
+    tptp2X_member(Type,[axiom,hypothesis,lemma,theorem,definition]),
     \+ tptp2X_member(++_,[FirstLiteral|RestOfLiterals]),
     !,
     write('# First literal moved to make clause a non-query'),
@@ -90,7 +106,7 @@
 
 %----type style for other non-conjectures
 output_setheo_clause(type,Type,Literals):-
-    tptp2X_member(Type,[axiom,hypothesis,lemma,definition]),
+    tptp2X_member(Type,[axiom,hypothesis,lemma,theorem,definition]),
     output_setheo_clause(sign,Type,Literals).
 
 %----type style for conjectures
@@ -105,22 +121,6 @@
 %----status.
 output_setheo_clauses(_,[]).
 
-%----Special case for the empty clause - make a simple problem
-output_setheo_clauses(Style,[input_clause(_,Type,[])]):-
-    !,
-    output_setheo_clauses(Style,[input_clause(positive_dummy,Type,[++dummy]),
-input_clause(negative_dummy,Type,[--dummy])]).
-
-%----Semantic constants
-output_setheo_clauses(Style,[input_clause(_,Type,[++ $false])]):-
-    !,
-    output_setheo_clauses(Style,[input_clause(positive_dummy,Type,[++dummy]),
-input_clause(negative_dummy,Type,[--dummy])]).
-
-output_setheo_clauses(Style,[input_clause(_,Type,[++ $true])]):-
-    !,
-    output_setheo_clauses(Style,[input_clause(dummy,Type,[++dummy,--dummy])]).
-
 %----Output in sequent format
 output_setheo_clauses(Style,[input_clause(Name,Type,Literals)|
 RestOfClauses]):-
@@ -170,7 +170,7 @@
 setheo(setheo:_,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('#----No FOF format available in SETHEO'),
+    write('ERROR: No FOF format available in SETHEO'),
     nl.
 %-------------------------------------------------------------------
 %----Provide information about the SETHEO format
Only in 2/TPTP2X: format.sex
Only in 2/TPTP2X: format.smt
Only in 2/TPTP2X: format.smt1
diff -ur 1/TPTP2X/format.sprfn 2/TPTP2X/format.sprfn
--- 1/TPTP2X/format.sprfn	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.sprfn	2012-08-13 14:45:12.000000000 -0400
@@ -8,7 +8,7 @@
 %--------------------------------------------------------------------
 %----Write an atom for sprfn
 output_sprfn_atom(Atom):-
-    (Atom =.. [equal,LHS,RHS] ->
+    (Atom =.. ['$tptp_equal',LHS,RHS] ->
 %----Use the next line for writing equality in prefix notation
 %       write(Atom);
 %----Use the next three lines for writing equality in infix notation
@@ -75,7 +75,7 @@
 sprfn(sprfn,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('%----No FOF format available in SPRFN'),
+    write('ERROR: No FOF format available in SPRFN'),
     nl.
 %-------------------------------------------------------------------
 %----Provide information about the SPRFN format
Only in 1/TPTP2X: format.strip
diff -ur 1/TPTP2X/format.tap 2/TPTP2X/format.tap
--- 1/TPTP2X/format.tap	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.tap	2012-08-13 14:45:12.000000000 -0400
@@ -31,7 +31,7 @@
     nl,!.
 
 %----Equal/2 is built in (I guess)
-output_3tap_predicate_declaration([equal/2|RestOfPredicates]):-
+output_3tap_predicate_declaration(['$tptp_equal'/2|RestOfPredicates]):-
     !,
     output_3tap_predicate_declaration(RestOfPredicates).
 
@@ -155,7 +155,7 @@
     !,
     write('-'),
     Atom =.. [Predicate|Terms],
-    (Predicate == equal ->
+    (Predicate == '$tptp_equal' ->
         ( Terms = [LeftTerm,RightTerm],
           write('('),
           output_3tap_terms([LeftTerm],Dictionary),
@@ -176,7 +176,7 @@
 output_3tap_signed_literal(++Atom,Dictionary):-
     write(' '),
     Atom =.. [Predicate|Terms],
-    (Predicate == equal ->
+    (Predicate == '$tptp_equal' ->
         ( Terms = [LeftTerm,RightTerm],
           output_3tap_terms([LeftTerm],Dictionary),
           write(' = '),
@@ -416,7 +416,7 @@
 tap(tap,Formulae,_):-
     tptp_formulae(Formulae),
     !,
-    write('%----No FOF format available in 3TAP'),
+    write('ERROR: No FOF format available in 3TAP'),
     nl.
 %----------------------------------------------------------------------------
 %----Provide information about the 3TAP format.
diff -ur 1/TPTP2X/format.thinker 2/TPTP2X/format.thinker
--- 1/TPTP2X/format.thinker	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/format.thinker	2012-08-13 14:45:12.000000000 -0400
@@ -289,7 +289,7 @@
 %----Write an equality atomic formula
 output_thinker_formula(_Format,Formula,Indent,AlreadyIndented,_,
 PredicateTable,ConstantTable,VariableTable,VariablesList,VariablesList):- 
-    Formula =.. [equal,LeftTerm,RightTerm],
+    Formula =.. ['$tptp_equal',LeftTerm,RightTerm],
     !,
     output_indent(Indent,AlreadyIndented),
     output_thinker_term(LeftTerm,PredicateTable,ConstantTable,VariableTable),
@@ -355,7 +355,7 @@
 thinker(thinker,Clauses,_):-
     tptp_clauses(Clauses),
     !,
-    write('#----No CNF format available in THINKER'),
+    write('ERROR: No CNF format available in THINKER'),
     nl.
 
 %----This checks for functors
@@ -366,7 +366,7 @@
     count_structures_of_arity(FunctorStructures,0,NumberOfConstants),
     NumberOfFunctors \== NumberOfConstants,
     !,
-    write('#----Thinker cannot handle functors.'),
+    write('ERROR: Thinker cannot handle functors.'),
     nl.
 
 thinker(thinker,Formulae,_):-
Only in 2/TPTP2X: format.tps
diff -ur 1/TPTP2X/format.tptp 2/TPTP2X/format.tptp
--- 1/TPTP2X/format.tptp	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/format.tptp	2012-08-13 14:45:12.000000000 -0400
@@ -6,71 +6,243 @@
 %----Generic output
 %==============================================================================
 %------------------------------------------------------------------------------
+tptp_output_separator(':=',_):-
+    !,
+    write(' :=').
+
+tptp_output_separator('<<',_):-
+    !,
+    write(' <<').
+
+tptp_output_separator(Separator,_):-
+    write(Separator).
+%------------------------------------------------------------------------------
 %----Output variables 
 tptp_output_variable(Variable):-
+    prolog_dialect(swi),
+    !,
+    write_term(Variable,[numbervars(true)]).
+
+tptp_output_variable(Variable):-
+    looks_like_a_variable(Variable),
+    !,
     write(Variable).
+
+tptp_output_variable(Language,Variable := Definition,Indent,_):-
+    tptp_flat_binary_formula(Definition,_),
+    !,
+    tptp_output_variable(Variable),
+    write(':= '),
+    output_formula(tptp,Language,Definition,Indent,Indent,none).
+
+tptp_output_variable(Language,Variable : Type,Indent,_):-
+    tptp_flat_type(Type,BinaryTypeConnective),
+    !,
+    tptp_output_variable(Variable),
+    write(': '),
+    (   BinaryTypeConnective == '@'
+    ->  StartLevel = none
+    ;   StartLevel = outermost
+    ),
+    output_formula(tptp,Language,Type,Indent,Indent,StartLevel).
+
+tptp_output_variable(Language,TwoPart,Indent,_):-
+    TwoPart =.. [Separator,Variable,TypeOrDefn],
+    !,
+    tptp_output_variable(Variable),
+    write(Separator),
+    nl,
+    TypeDefIndent is Indent + 2,
+    output_formula(tptp,Language,TypeOrDefn,TypeDefIndent,0,none).
+
+tptp_output_variable(_,Variable,_,_):-
+    tptp_output_variable(Variable).
 %------------------------------------------------------------------------------
-tptp_output_atom_list_by_hand([One]):-
+%----If it starts with a dollar, no quotes (allowed in TPTP)
+tptp_output_functor(Functor):-
+    name(Functor,[36|_]),
+    !,
+    write(Functor).
+
+tptp_output_functor(Functor):-
+    writeq(Functor).
+%------------------------------------------------------------------------------
+tptp_output_complex_equality(Language,LHS,EqualitySymbol,RHS,Indent,
+AlreadyIndented,ConnectiveAbove):-
+    output_indent(Indent,AlreadyIndented),
+    name(EqualitySymbol,ConnectiveASCII),
+    tptp2X_length(ConnectiveASCII,ConnectiveLength),
+%----THF equalities have to be ()ed unless outermost, because p = q | r is 
+%----ambiguous. outermost already have their ()s done
+    (   ConnectiveAbove == outermost
+    ->  (   NewIndent is Indent,
+            ConnectiveIndent is Indent - 1 - ConnectiveLength
+        )
+    ;   (   write('( '),
+            NewIndent is Indent + 2,
+            ConnectiveIndent is Indent + 1 - ConnectiveLength
+        )
+    ),
+%----Extra ()s get around equated binders in the quantified part
+    output_formula(tptp,Language,LHS,NewIndent,NewIndent,'='),
+%----Do atomic all on one line
+    (   (   tptp_atomic_formula(LHS),
+            tptp_atomic_formula(RHS)
+        )
+    ->  write(' ')
+    ;   (   nl,
+            output_indent(ConnectiveIndent,0)
+        )
+    ),
+    write(EqualitySymbol),
+    write(' '),
+    output_formula(tptp,Language,RHS,NewIndent,NewIndent,'='),
+    (   ConnectiveAbove == outermost
+    ->  true
+    ;   write(' )')
+    ).
+%------------------------------------------------------------------------------
+tptp_output_atom_list(_,[]):-
+    !.
+
+tptp_output_atom_list(Language,[One]):-
     !,
-    tptp_output_atom_by_hand(One).
+    tptp_output_atom(Language,One).
 
-tptp_output_atom_list_by_hand([One,Two|Rest]):-
-    tptp_output_atom_by_hand(One),
+tptp_output_atom_list(Language,[One,Two|Rest]):-
+    tptp_output_atom(Language,One),
     write(','),
-    tptp_output_atom_list_by_hand([Two|Rest]).
+    tptp_output_atom_list(Language,[Two|Rest]).
 %------------------------------------------------------------------------------
-tptp_output_atom_by_hand(Variable):-
+%----Variables are also output as atoms.
+%----Only THF should have variable atoms. This is where an atom that should
+%----be 'Quoted' might lose its quotes.
+%DEBUG tptp_output_atom(_,Atom):-write('ATOM '),write(Atom),nl,fail.
+
+tptp_output_atom(_,Variable):-
     looks_like_a_variable(Variable),
     !,
     tptp_output_variable(Variable).
 
-tptp_output_atom_by_hand($(Reserved)):-
+%tptp_output_atom(_,ASCIIList):-
+%    looks_like_a_string(ASCIIList),
+%    !,
+%    name(Atom,ASCIIList),
+%    writeq(Atom).
+
+tptp_output_atom(Language,'$tptp_equal'(X,Y)):-
     !,
-    write('$'),
-    tptp_output_atom_by_hand(Reserved).
+    output_formula(tptp,Language,X,0,0,outermost),
+    write(' = '),
+    output_formula(tptp,Language,Y,0,0,outermost).
 
-tptp_output_atom_by_hand(Atom):-
-    atomic(Atom),
+tptp_output_atom(Language,X = Y):-
     !,
-    write(Atom).
+    output_formula(tptp,Language,X,0,0,outermost),
+    write(' = '),
+    output_formula(tptp,Language,Y,0,0,outermost).
 
-tptp_output_atom_by_hand(Formula):-
-    tptp_non_atomic_formula(Formula),
+tptp_output_atom(Language,'$tptp_not_equal'(X,Y)):-
     !,
-    nl,
-    output_formula(tptp,Formula,2,0,outermost).
+    output_formula(tptp,Language,X,0,0,outermost),
+    write(' != '),
+    output_formula(tptp,Language,Y,0,0,outermost).
 
-%THIS NEEDS FIXING TO AVOID BRACKETS FROM LEFT ASSOC
-tptp_output_atom_by_hand(@(LHS,RHS)) :-
+tptp_output_atom(Language,X != Y):-
     !,
-    write('('),
-    tptp_output_atom_by_hand(LHS),
-    write(' @ '),
-    tptp_output_atom_by_hand(RHS),
-    write(')').
+    output_formula(tptp,Language,X,0,0,outermost),
+    write(' != '),
+    output_formula(tptp,Language,Y,0,0,outermost).
 
-tptp_output_atom_by_hand(equal(LHS,RHS)):-
+tptp_output_atom(_,$(Atom)):-
     !,
-    tptp_output_atom_by_hand(LHS),
-    write(' = '),
-    tptp_output_atom_by_hand(RHS).
+    write('$'),
+    write(Atom).
 
-tptp_output_atom_by_hand(tptp_not_equal(LHS,RHS)):-
+tptp_output_atom(_,DefinedAtom):-
+    atomic(DefinedAtom),
     !,
-    tptp_output_atom_by_hand(LHS),
-    write(' != '),
-    tptp_output_atom_by_hand(RHS).
+    tptp_output_functor(DefinedAtom).
+
+%----Rational terms
+tptp_output_atom(Language,Numerator/Denominator):-
+    tptp_output_atom(Language,Numerator),
+    write('/'),
+    tptp_output_atom(Language,Denominator).
+
+%----TFF and FOF non-atomic don't get a new line
+tptp_output_atom(Language,Formula):-
+    tptp2X_member(Language,[tff,fof]),
+    tptp_non_atomic_formula(Formula),
+    !,
+    output_formula(tptp,Language,Language,0,0,outermost).
 
-tptp_output_atom_by_hand(Term):-
+%----THF get a new line
+tptp_output_atom(Language,Formula):-
+    tptp_non_atomic_formula(Formula),
+    !,
+    nl,
+    output_formula(tptp,Language,Formula,2,0,outermost).
+
+tptp_output_atom(Language,Term):-
     Term =.. [Functor|Arguments],
-    write(Functor),
+    tptp_output_functor(Functor),
     write('('),
-    tptp_output_atom_list_by_hand(Arguments),
+    tptp_output_atom_list(Language,Arguments),
     write(')').
 %------------------------------------------------------------------------------
-%----Output atoms 
-tptp_output_atom(Atom):-
-    tptp_output_atom_by_hand(Atom).
+%----Equalities need to be ()ed for THF, because p = q | r is ambiguous. The
+%----user is responsible for that in tptp2X world, for otherwise CNF output
+%----is broken.
+tptp_output_atom(thf,'$tptp_equal'(LHS,RHS),Indent,AlreadyIndented,
+ConnectiveAbove):-
+    !,
+    tptp_output_complex_equality(thf,LHS,'=',RHS,Indent,AlreadyIndented,
+ConnectiveAbove).
+
+tptp_output_atom(thf,LHS = RHS,Indent,AlreadyIndented,ConnectiveAbove):-
+    !,
+    tptp_output_complex_equality(thf,LHS,'=',RHS,Indent,AlreadyIndented,
+ConnectiveAbove).
+
+tptp_output_atom(thf,LHS != RHS,Indent,AlreadyIndented,ConnectiveAbove):-
+    !,
+    tptp_output_complex_equality(thf,LHS,'!=',RHS,Indent,AlreadyIndented,
+ConnectiveAbove).
+
+tptp_output_atom(Language,'$tptp_equal'(LHS,RHS),_,_,_):-
+    tptp_atomic_formula(LHS),
+    tptp_atomic_formula(RHS),
+    !,
+    tptp_output_atom(Language,'$tptp_equal'(LHS,RHS)).
+
+tptp_output_atom(Language,'$tptp_not_equal'(LHS,RHS),_,_,_):-
+    tptp_atomic_formula(LHS),
+    tptp_atomic_formula(RHS),
+    !,
+    tptp_output_atom(Language,'$tptp_not_equal'(LHS,RHS)).
+
+tptp_output_atom(_Language,_Symbol:_Signature,_Indent,_AlreadyIndented,_):-
+    !,
+    write('IF YOU SEE THIS EMAIL GEOFF SUTCLIFFE'),nl.
+%    tptp_output_atom(Language,Symbol),
+%    write(':'),
+%    (   tptp_flat_type(Signature,_) ->
+%        (   NewIndent is Indent,
+%            NewAlreadyIndented is Indent - 1,
+%            InitialConnectiveAbove = outermost
+%        )
+%    ;   (   nl,
+%            NewIndent is Indent + 2,
+%            NewAlreadyIndented is 0,
+%            InitialConnectiveAbove = none
+%        )
+%    ),
+%    output_formula(tptp,Language,Signature,NewIndent,NewAlreadyIndented,
+%InitialConnectiveAbove).
+
+tptp_output_atom(Language,Atom,_,_,_):-
+    tptp_output_atom(Language,Atom).
 %------------------------------------------------------------------------------
 %==============================================================================
 %----FOF format
@@ -90,7 +262,7 @@
 output_tptp_formula_start(Language,Name,Status):-
     write(Language),
     write('('),
-    write(Name),
+    writeq(Name),
     write(','),
     write(Status),
     write(',').
@@ -103,33 +275,54 @@
     write(','),
     nl,
     write('    '),
-    write(Source),
+    tptp_output_atom(fof,Source),
     write(','),
     nl,
-    write('    '),
-    write(UsefulInfo),
-    write(').'),
+    write('    ['),
+    tptp_output_atom_list(fof,UsefulInfo),
+    write(']).'),
     nl.
 %------------------------------------------------------------------------------
+outer_bracketed_formula(Formula):-
+    tptp_binary_formula(Formula,_,_,_),
+    !.
+
+outer_bracketed_formula('$tptp_equal'(_,_)):-
+    !.
+
+outer_bracketed_formula(~'$tptp_equal'(_,_)):-
+    !.
+
+outer_bracketed_formula('$tptp_not_equal'(_,_)):-
+    !.
+%------------------------------------------------------------------------------
+make_tptp_source_and_usefulinfo([],unknown,[]).
+
+make_tptp_source_and_usefulinfo([Source],Source,[]).
+
+make_tptp_source_and_usefulinfo([Source,UsefulInfo],Source,UsefulInfo).
+%------------------------------------------------------------------------------
 %----Write a tptp formula in fof form
 output_tptp_formula(Format,Length,AnnotatedFormula):-
-    AnnotatedFormula =.. [Language,Name,Status,Formula|_],
+    AnnotatedFormula =.. [Language,Name,Status,Formula|SourceAndUsefulInfo],
+%DEBUG write('OTF--- '),display(Formula),nl,
     output_tptp_formula_start(Language,Name,Status),
-%----Bracket formula to avoid confusing with other arguments (esp |
-%----becomes ; of wrong precedence)
-    (tptp_binary_formula(Formula,_,_,_) -> (
-        nl,
-        write('    ('),
-        output_formula(Format,Formula,6,5,outermost)
-    );(
-        write('('),
-        nl,
-        output_formula(Format,Formula,4,0,outermost)
-    )),
+%----Binary formule and equalities (which are binary in THF) get ( on next line
+    (   outer_bracketed_formula(Formula)
+    ->  (   nl,
+            write('    ('),
+            output_formula(Format,Language,Formula,6,5,outermost)
+        )
+    ;   (   write('('),
+            nl,
+            output_formula(Format,Language,Formula,4,0,outermost)
+        )
+    ),
 %----Old way, but extra brackets around clauses
-%----output_generic_formula(Format,Formula),
+%----output_generic_formula(Format,Language,Formula),
     write(' )'),
-    output_tptp_formula_end(Length,unknown,[]).
+    make_tptp_source_and_usefulinfo(SourceAndUsefulInfo,Source,UsefulInfo),
+    output_tptp_formula_end(Length,Source,UsefulInfo).
 %------------------------------------------------------------------------------
 %----Write out each formula in TSTP format
 output_tptp_formulae(Format,Length,[OneFormula]):-
@@ -141,19 +334,19 @@
     nl,
     output_tptp_formulae(Format,Length,RestOfFormulae).
 %------------------------------------------------------------------------------
-output_tptp_literals_on_one_line(Format,Length,(LHS|RHS)):-
+output_tptp_literals_on_one_line(Format,Language,Length,(LHS|RHS)):-
     !,
-    output_tptp_literals_on_one_line(Format,Length,LHS),
+    output_tptp_literals_on_one_line(Format,Language,Length,LHS),
     write(' | '),
-    output_tptp_literals_on_one_line(Format,Length,RHS).
+    output_tptp_literals_on_one_line(Format,Language,Length,RHS).
 
-output_tptp_literals_on_one_line(Format,_Length,Literal):-
-    output_formula(Format,Literal,0,0,_).
+output_tptp_literals_on_one_line(Format,Language,_Length,Literal):-
+    output_formula(Format,Language,Literal,0,0,'|').
 %------------------------------------------------------------------------------
 %----Write out a TSTP clause, one literal per line
 output_tptp_clause(Format,Clause,Length,no):-
     !,
-    output_tptp_formula(Format,Length,Clause).
+    output_tptp_formula(Format,cnf,Length,Clause).
     
 output_tptp_clause(Format,Clause,Length,yes):-
     Clause =.. [cnf,Name,Status,Literals|_],
@@ -161,7 +354,7 @@
     nl,
     write('    '),
     write('( '),
-    output_tptp_literals_on_one_line(Format,Length,Literals),
+    output_tptp_literals_on_one_line(Format,cnf,Length,Literals),
     write(' )'),
     output_tptp_formula_end(Length,unknown,[]).
 %------------------------------------------------------------------------------
@@ -177,26 +370,38 @@
     nl,
     output_tptp_clauses(Format,RestOfClauses,Length,OneLineOfLiterals).
 %------------------------------------------------------------------------------
+choose_tptp_length([],short).
+
+choose_tptp_length([Formula|_],long):-
+    Formula =.. [_,_,_,_,Source,UsefulInfo],
+    (   Source \== unknown
+    ;   UsefulInfo \== [] ),
+    !.
+
+choose_tptp_length([_|RestOfFormulae],Length):-
+    choose_tptp_length(RestOfFormulae,Length).
+%------------------------------------------------------------------------------
 %----This writes out TSTP format clauses
 tptp(tptp:Length,Clauses,_):-
-%----CHANGE TO tptp_clauses WHEN I CHANGE INTERNAL STRUCTURE
     tptp_clauses(Clauses),
     !,
     convert_clauses_to_tptp(Clauses,TSTPFormulae),
 %----If propositional then literals may be output on one line.
-    (   tptp_propositional(TSTPFormulae) ->
-        output_tptp_clauses(tptp,TSTPFormulae,Length,yes);
-        output_tptp_formulae(tptp,Length,TSTPFormulae) ).
+    (   tptp_propositional(TSTPFormulae)
+    ->  output_tptp_clauses(tptp,TSTPFormulae,Length,yes)
+    ;   output_tptp_formulae(tptp,Length,TSTPFormulae) 
+    ).
 
 tptp(tptp:Length,Formulae,_):-
-%----CHANGE TO tptp_formulae WHEN I HAVE CHANGED INTERNAL DS
     tptp_formulae(Formulae),
+    !,
     convert_formulae_to_tptp(Formulae,TSTPFormulae),
     output_tptp_formulae(tptp,Length,TSTPFormulae).
 
-%----No length - assume short
+%----No length - work out best guess for length
 tptp(tptp,Formulae,FileHeader):-
-    tptp(tptp:short,Formulae,FileHeader).
+    choose_tptp_length(Formulae,Length),
+    tptp(tptp:Length,Formulae,FileHeader).
 %------------------------------------------------------------------------------
 %----Provide information about the TSTP format
 tptp_format_information('%','.tptp').
diff -ur 1/TPTP2X/format.waldmeister 2/TPTP2X/format.waldmeister
--- 1/TPTP2X/format.waldmeister	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/format.waldmeister	2012-08-13 14:45:12.000000000 -0400
@@ -131,6 +131,7 @@
 	output_wm_declare_variables(RestVars).
 %------------------------------------------------------------------------------
 output_wm_declare_all_variables([]):-
+        write('VARIABLES       X: ANY'),
         nl.
 
 output_wm_declare_all_variables(VariableList):-
@@ -174,7 +175,7 @@
 %------------------------------------------------------------------------------
 all_negative_equality_literals([]).
 
-all_negative_equality_literals([--equal(_,_)|RestOfLiterals]):-
+all_negative_equality_literals([--'$tptp_equal'(_,_)|RestOfLiterals]):-
     all_negative_equality_literals(RestOfLiterals).
 %------------------------------------------------------------------------------
 check_theres_one_or_all_ground([_]).
@@ -190,7 +191,7 @@
 %------------------------------------------------------------------------------
 all_positive_unit_equality([]).
 
-all_positive_unit_equality([input_clause(_,_,[++equal(_,_)])|RestOfClauses]):-
+all_positive_unit_equality([input_clause(_,_,[++'$tptp_equal'(_,_)])|RestOfClauses]):-
     all_positive_unit_equality(RestOfClauses).
 %------------------------------------------------------------------------------
 select_wm_equals(Clauses, PositiveEquations, NegativeGoals):-
@@ -240,14 +241,14 @@
 %----Output a clause
 output_wm_clause([],_).
 
-output_wm_clause([--equal(LHS,RHS)], Name):-
+output_wm_clause([--'$tptp_equal'(LHS,RHS)], Name):-
 	!,					% Red Cut
 	write(LHS),
 	write(' = '),
 	write(RHS),
         output_wm_name(Name).
 
-output_wm_clause([++equal(LHS,RHS)], Name):-
+output_wm_clause([++'$tptp_equal'(LHS,RHS)], Name):-
 	!,					% Red Cut
 	write(LHS),
 	write(' = '),
@@ -274,7 +275,7 @@
         true),
         output_wm_clauses(RestClauses).
 %------------------------------------------------------------------------------
-output_wm_all_clauses([]).
+% output_wm_all_clauses([]).
 
 output_wm_all_clauses(ClausesList):-
         write('EQUATIONS       '),
Only in 2/TPTP2X: Old.read
Only in 1/TPTP2X: quickstart.tptp2X
diff -ur 1/TPTP2X/ReadMe 2/TPTP2X/ReadMe
--- 1/TPTP2X/ReadMe	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/ReadMe	2012-08-13 14:45:12.000000000 -0400
@@ -19,6 +19,13 @@
 information.  More information about installing tptp2X can be found in the TPTP 
 technical report.
 
+    WARNING:  For historical  reasons TPTP2X  omits  the quotes around  some 
+    constants and function  symbols that should  be 'Quoted', e.g., as found
+    in PUZ001+2.  I'm really sorry  about this - it's an  artifact of a very 
+    generic printing framework that became overloaded when THF formulae came 
+    into the TPTP.  Changing it would be a HUGE task, and now there's TPTP4X
+    that is better in most respects.
+
 Using tptp2X
 ------------
 The most convenient  way of using the tptp2X utility is  through the tptp2X csh
diff -ur 1/TPTP2X/tptp2X 2/TPTP2X/tptp2X
--- 1/TPTP2X/tptp2X	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/tptp2X	2012-08-13 14:45:12.000000000 -0400
@@ -2,8 +2,8 @@
 #--------------------------------------------------------------------------
 #----These need to be installed
 set TPTPDirectory=/home/graph/tptp/TPTP
-set PrologInterpreter='/usr/local/bin/eclipse'
-set PrologArguments='-l 512000'
+set PrologInterpreter='/usr/local/eclipse5.10_140/bin/i386_linux/eclipse'
+set PrologArguments='-l 1024000 -g 1024000'
 set Gawk=/bin/awk
 #--------------------------------------------------------------------------
 #----Set default values for tptp2X parameters
@@ -466,7 +466,7 @@
 #----domain directory, TPTP directory
 #----NOTE $cwd in csh include full path names (e.g., /home/2/geoff) which
 #----     can mess up Prolog when generator files are reloaded
-                foreach PossiblePath ("" "$cwd" "$TPTPDirectory/Problems/$Domain" "$TPTPDirectory/Generators" "$TPTPDirectory/Problems" "$TPTPDirectory/Axioms" "$TPTPDirectory")
+                foreach PossiblePath ("" "$cwd" "$TPTPDirectory/Problems/$Domain" "$TPTPDirectory/Problems" "$TPTPDirectory/Axioms" "$TPTPDirectory/Generators" "$TPTPDirectory")
 #----If found, then set path
                     if (-f "$PossiblePath/$FilePath$PossibleExtension") then
                         set FilePath="$PossiblePath/$FilePath$PossibleExtension"
diff -ur 1/TPTP2X/tptp2X.config 2/TPTP2X/tptp2X.config
--- 1/TPTP2X/tptp2X.config	2007-03-01 12:01:53.000000000 -0500
+++ 2/TPTP2X/tptp2X.config	2012-08-13 14:45:12.000000000 -0400
@@ -10,21 +10,48 @@
 %----keep working (it looks for that). Do not delete them!
 % prolog_dialect(generic).                %%generic
 
-%----Works with YAP Prolog, with the following
+prolog_dialect(eclipse).                %%eclipse
+%----These lines were supplied by Max Moser from TUM, to get things working.
+:-local(write/1).                       %%eclipse
+write(X):-                              %%eclipse
+    printf("%Dw",[X]).                  %%eclipse
+:-set_flag(print_depth,1000).           %%eclipse
+:-op(0,fy,if).                          %%eclipse
+:-op(0,fy,not).                         %%eclipse
+:-op(0,fy,once).                        %%eclipse
+:-op(0,xfy,^).                          %%eclipse
+:-use_module(library(iso)).             %%eclipse
+%----Override some ISO silliness
+:-set_flag(syntax_option,not(bar_is_no_atom)).   %%eclipse
+:-use_module(library(numbervars)).      %%eclipse
+:-dynamic(tptp2X_file_to_include/1).    %%eclipse
+:-dynamic(tptp2X_unique_value/1).       %%eclipse
+:-dynamic(tptp2X_cwd/1).                %%eclipse
+%----Optimise the compilation
+:-nodbgcomp.                            %%eclipse
+%----Suppress informational output (needed for generators that do a consult
+%----while things are running, so the messages are not filtered by the
+%----tptp2X script).
+:-set_stream(toplevel_output,null).     %%eclipse
+%----These remove error messages and the prompt too, but that's already
+%----taken care of by the tptp2X script. Hence they are not installed.
+% :-set_error_handler(139,true/0).
+% :-set_prompt(toplevel_input,'',null).
+
 % prolog_dialect(yap).                    %%yap
 % :-op(0,fx,not).                         %%yap
 % :-use_module(library(system)).          %%yap
 
-% prolog_dialect(binprolog).              %%binprolog
-%----Undefine not which is an operator in BinProlog
-% :-op(0,fx,not).                         %%binprolog
+% prolog_dialect(gnu).                    %%gnu
 
-% prolog_dialect(swiprolog).              %%swiprolog
-% :-op(0,yfx,xor).                        %%swiprolog
+%----SWI Version 5.3.12 has a bug that affects TPTP2X. Upgrade to 5.3.13
+% prolog_dialect(swi).                    %%swi
+% :-op(0,yfx,xor).                        %%swi
 
 % prolog_dialect(sicstus).                %%sicstus
 % :-use_module(library(system)).          %%sicstus
 % :-use_module(library(random)).          %%sicstus
+% :-use_module(library(file_systems)).    %%sicstus
 %----For old SICStus versions put_code(C):-put(C).
 %----For old SICStus versions get_code(C):-get0(C).
 %----Lines to suppress informational messages
@@ -40,29 +67,10 @@
 %----To suppress informational messages when using tptp2X/5
 % message_hook(_,_,_).
 
-prolog_dialect(eclipse).                %%eclipse
-%----These lines were supplied by Max Moser from TUM, to get things working.
-:-local(write/1).                       %%eclipse
-write(X):-                              %%eclipse
-    printf("%Dw",[X]).                  %%eclipse
-:-op(0,fy,not).                         %%eclipse
-:-op(0,fy,once).                        %%eclipse
-:-use_module(library(iso)).             %%eclipse
-:-use_module(library(numbervars)).      %%eclipse
-:-dynamic(tptp2X_file_to_include/1).    %%eclipse
-:-dynamic(tptp2X_unique_value/1).       %%eclipse
-:-dynamic(tptp2X_cwd/1).                %%eclipse
-:-dynamic(tptp2X_copy/1).               %%eclipse
-%----Optimise the compilation
-:-nodbgcomp.                            %%eclipse
-%----Suppress informational output (needed for generators that do a consult
-%----while things are running, so the messages are not filtered by the
-%----tptp2X script).
-:-set_stream(toplevel_output,null).     %%eclipse
-%----These remove error messages and the prompt too, but that's already
-%----taken care of by the tptp2X script. Hence they are not installed.
-% :-set_error_handler(139,true/0).
-% :-set_prompt(toplevel_input,'',null).
+% prolog_dialect(binprolog).              %%binprolog
+%----Undefine not which is an operator in BinProlog
+% :-op(0,fx,not).                         %%binprolog
+
 %------------------------------------------------------------------------------
 %----This specifies the parent directory of the TPTP Problems, Axioms and
 %----TPTP2X directories. Do not use a ~ in this.
diff -ur 1/TPTP2X/tptp2X.config.uninstalled 2/TPTP2X/tptp2X.config.uninstalled
--- 1/TPTP2X/tptp2X.config.uninstalled	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/tptp2X.config.uninstalled	2012-08-13 14:45:12.000000000 -0400
@@ -10,21 +10,48 @@
 %----keep working (it looks for that). Do not delete them!
 % prolog_dialect(generic).                %%generic
 
-%----Works with YAP Prolog, with the following
+% prolog_dialect(eclipse).                %%eclipse
+%----These lines were supplied by Max Moser from TUM, to get things working.
+% :-local(write/1).                       %%eclipse
+% write(X):-                              %%eclipse
+%     printf("%Dw",[X]).                  %%eclipse
+% :-set_flag(print_depth,1000).           %%eclipse
+% :-op(0,fy,if).                          %%eclipse
+% :-op(0,fy,not).                         %%eclipse
+% :-op(0,fy,once).                        %%eclipse
+% :-op(0,xfy,^).                          %%eclipse
+% :-use_module(library(iso)).             %%eclipse
+%----Override some ISO silliness
+% :-set_flag(syntax_option,not(bar_is_no_atom)).   %%eclipse
+% :-use_module(library(numbervars)).      %%eclipse
+% :-dynamic(tptp2X_file_to_include/1).    %%eclipse
+% :-dynamic(tptp2X_unique_value/1).       %%eclipse
+% :-dynamic(tptp2X_cwd/1).                %%eclipse
+%----Optimise the compilation
+% :-nodbgcomp.                            %%eclipse
+%----Suppress informational output (needed for generators that do a consult
+%----while things are running, so the messages are not filtered by the
+%----tptp2X script).
+% :-set_stream(toplevel_output,null).     %%eclipse
+%----These remove error messages and the prompt too, but that's already
+%----taken care of by the tptp2X script. Hence they are not installed.
+% :-set_error_handler(139,true/0).
+% :-set_prompt(toplevel_input,'',null).
+
 % prolog_dialect(yap).                    %%yap
 % :-op(0,fx,not).                         %%yap
 % :-use_module(library(system)).          %%yap
 
-% prolog_dialect(binprolog).              %%binprolog
-%----Undefine not which is an operator in BinProlog
-% :-op(0,fx,not).                         %%binprolog
+% prolog_dialect(gnu).                    %%gnu
 
-% prolog_dialect(swiprolog).              %%swiprolog
-% :-op(0,yfx,xor).                        %%swiprolog
+%----SWI Version 5.3.12 has a bug that affects TPTP2X. Upgrade to 5.3.13
+% prolog_dialect(swi).                    %%swi
+% :-op(0,yfx,xor).                        %%swi
 
 % prolog_dialect(sicstus).                %%sicstus
 % :-use_module(library(system)).          %%sicstus
 % :-use_module(library(random)).          %%sicstus
+% :-use_module(library(file_systems)).    %%sicstus
 %----For old SICStus versions put_code(C):-put(C).
 %----For old SICStus versions get_code(C):-get0(C).
 %----Lines to suppress informational messages
@@ -40,29 +67,10 @@
 %----To suppress informational messages when using tptp2X/5
 % message_hook(_,_,_).
 
-% prolog_dialect(eclipse).                %%eclipse
-%----These lines were supplied by Max Moser from TUM, to get things working.
-% :-local(write/1).                       %%eclipse
-% write(X):-                              %%eclipse
-%     printf("%Dw",[X]).                  %%eclipse
-% :-op(0,fy,not).                         %%eclipse
-% :-op(0,fy,once).                        %%eclipse
-% :-use_module(library(iso)).             %%eclipse
-% :-use_module(library(numbervars)).      %%eclipse
-% :-dynamic(tptp2X_file_to_include/1).    %%eclipse
-% :-dynamic(tptp2X_unique_value/1).       %%eclipse
-% :-dynamic(tptp2X_cwd/1).                %%eclipse
-% :-dynamic(tptp2X_copy/1).               %%eclipse
-%----Optimise the compilation
-% :-nodbgcomp.                            %%eclipse
-%----Suppress informational output (needed for generators that do a consult
-%----while things are running, so the messages are not filtered by the
-%----tptp2X script).
-% :-set_stream(toplevel_output,null).     %%eclipse
-%----These remove error messages and the prompt too, but that's already
-%----taken care of by the tptp2X script. Hence they are not installed.
-% :-set_error_handler(139,true/0).
-% :-set_prompt(toplevel_input,'',null).
+% prolog_dialect(binprolog).              %%binprolog
+%----Undefine not which is an operator in BinProlog
+% :-op(0,fx,not).                         %%binprolog
+
 %------------------------------------------------------------------------------
 %----This specifies the parent directory of the TPTP Problems, Axioms and
 %----TPTP2X directories. Do not use a ~ in this.
diff -ur 1/TPTP2X/tptp2X.format 2/TPTP2X/tptp2X.format
--- 1/TPTP2X/tptp2X.format	2007-03-01 12:01:53.000000000 -0500
+++ 2/TPTP2X/tptp2X.format	2012-08-13 14:45:12.000000000 -0400
@@ -17,20 +17,50 @@
     ActualIndent is Indent - AlreadyIndented,
     tptp2X_tab(ActualIndent).
 %------------------------------------------------------------------------------
-%----Call format specific code for reformating atoms
-output_atom_for_format(Format,Atom):-
-%----Make query
-    concatenate_atoms([Format,'_output_atom'],FormatAtomPredicate),
-    FormatAtomQuery =.. [FormatAtomPredicate,Atom],
-    FormatAtomQuery.
+%----Output : or := separator for a format
+output_defn_type_separator_for_format(Format,Separator,TypeOrDefn):-
+    concatenate_atoms([Format,'_output_separator'],FormatSeparatorPredicate),
+    FormatSeparatorQuery =.. [FormatSeparatorPredicate,Separator,TypeOrDefn],
+    FormatSeparatorQuery.
 %------------------------------------------------------------------------------
 %----Call format specific code for reformating atoms
+output_variable_for_format(Format,Language,Variable,Indent,AlreadyIndented):-
+    tptp2X_member(Format,[tptp,lf]),
+    !,
+    concatenate_atoms([Format,'_output_variable'],FormatVariablePredicate),
+    FormatVariableQuery =.. [FormatVariablePredicate,Language,Variable,Indent,
+AlreadyIndented],
+    FormatVariableQuery.
+
+output_variable_for_format(Format,_,Variable,_,_):-
+    output_variable_for_format(Format,Variable).
+
 output_variable_for_format(Format,Variable):-
 %----Make query
     concatenate_atoms([Format,'_output_variable'],FormatAtomPredicate),
     FormatAtomQuery =.. [FormatAtomPredicate,Variable],
     FormatAtomQuery.
 %------------------------------------------------------------------------------
+%----Call format specific code for reformating atoms
+%----THF case where formating must continue inside
+output_atom_for_format(Format,Language,Atom,Indent,AlreadyIndented,
+ConnectiveAbove):-
+    tptp2X_member(Format,[tptp,lf]),
+    !,
+    concatenate_atoms([Format,'_output_atom'],FormatAtomPredicate),
+    FormatAtomQuery =.. [FormatAtomPredicate,Language,Atom,Indent,
+AlreadyIndented,ConnectiveAbove],
+    FormatAtomQuery.
+
+output_atom_for_format(Format,Language,Atom,_,_,_):-
+    output_atom_for_format(Format,Language,Atom).
+
+output_atom_for_format(Format,Language,Atom):-
+%----Make query
+    concatenate_atoms([Format,'_output_atom'],FormatAtomPredicate),
+    FormatAtomQuery =.. [FormatAtomPredicate,Language,Atom],
+    FormatAtomQuery.
+%------------------------------------------------------------------------------
 %----Merge variables and lists of variables
 merge_quantified_variables([H1|T1],[H2|T2],Variables):-
     !,
@@ -45,34 +75,69 @@
 
 merge_quantified_variables(V1,V2,[V1,V2]).
 %------------------------------------------------------------------------------
-%----Output the quantified variables
-%----Single variables, maybe var or atomic
-output_quantified_variables(Format,OneVariable,_):-
-    var(OneVariable),
+two_part_variable_not_flat_second_part(Variable):-
+    Variable =.. [_,_,SecondPart],
+    tptp_flat_binary_formula(SecondPart,_),
+    !,
+    fail.
+
+two_part_variable_not_flat_second_part(Variable):-
+    Variable =.. [_,_,Literal],
+    tptp_literal_formula(Literal,_),
+    !,
+    fail.
+
+two_part_variable_not_flat_second_part(Variable):-
+    Variable =.. [_,_,_].
+%------------------------------------------------------------------------------
+output_quantified_variable_separator(FirstVariable,SecondVariable,Separator,
+Indent):-
+    (   two_part_variable_not_flat_second_part(FirstVariable)
+    ;   two_part_variable_not_flat_second_part(SecondVariable)
+    ),
     !,
-    output_variable_for_format(Format,OneVariable).
+    write(Separator),
+    nl,
+    output_indent(Indent,0).
 
-output_quantified_variables(Format,OneVariable,_):-
-    atom(OneVariable),
+output_quantified_variable_separator(_,_,Separator,_):-
+    write(Separator).
+%------------------------------------------------------------------------------
+%----Output the quantified variables
+%----Single variables, maybe var or atomic
+output_quantified_variables(Format,Language,OneVariable,_,Indent,
+AlreadyIndented):-
+    looks_like_a_variable(OneVariable),
     !,
-    output_variable_for_format(Format,OneVariable).
+    output_variable_for_format(Format,Language,OneVariable,Indent,
+AlreadyIndented).
 
 %----List of one variable
-output_quantified_variables(Format,[OneVariable],_):-
+output_quantified_variables(Format,Language,[OneVariable],_,Indent,
+AlreadyIndented):-
     !,
-    output_variable_for_format(Format,OneVariable).
+    output_variable_for_format(Format,Language,OneVariable,Indent,
+AlreadyIndented).
 
 %----List of more variables
-output_quantified_variables(Format,[FirstVariable|RestOfVariables],Separator):-
+output_quantified_variables(Format,Language,[FirstVariable,SecondVariable|
+RestOfVariables],Separator,Indent,AlreadyIndented):-
     !,
-    output_variable_for_format(Format,FirstVariable),
-    write(Separator),
-    output_quantified_variables(Format,RestOfVariables,Separator).
+    output_variable_for_format(Format,Language,FirstVariable,Indent,
+AlreadyIndented),
+    output_quantified_variable_separator(FirstVariable,SecondVariable,
+Separator,Indent),
+    output_quantified_variables(Format,Language,[SecondVariable|
+RestOfVariables],Separator,Indent,Indent).
 
 %----Output quantified variables with formatting
-output_quantified_variables(Format,Prefix,Variables,Separator,Suffix):-
+output_quantified_variables(Format,Language,Prefix,Variables,Separator,Suffix,
+Indent,_):-
     write(Prefix),
-    output_quantified_variables(Format,Variables,Separator),
+    tptp2X_atom_length(Prefix,PrefixLength),
+    NewIndent is Indent + PrefixLength,
+    output_quantified_variables(Format,Language,Variables,Separator,NewIndent,
+NewIndent),
     write(Suffix).
 %------------------------------------------------------------------------------
 %----Check if a quantified formula, in a specified format
@@ -117,8 +182,10 @@
     FormatQuery.
 %------------------------------------------------------------------------------
 %----Simplify quantified formulae
-output_formula(Format,QuantifiedQuantifiedFormula,Indent,AlreadyIndented,
-LastConnective):-
+%DEBUG output_formula(Format,Language,Formula,Indent,AlreadyIndented,ConnectiveAbove):-nl,write('OF--- '),write(Formula),nl,fail.
+
+output_formula(Format,Language,QuantifiedQuantifiedFormula,Indent,
+AlreadyIndented,ConnectiveAbove):-
 %----Check if this format wants merged variables
     tptp2X_member(Format,[tptp,oldtptp,otter]),
 %----Check if there is a nested quantifier the same
@@ -132,11 +199,27 @@
     NewQuantification =.. [Quantifier,Variables],
     NewQuantifiedFormula =.. [:,NewQuantification,Formula],
 %----Try agains with the new formula
-    output_formula(Format,NewQuantifiedFormula,Indent,AlreadyIndented,
-LastConnective).
+    output_formula(Format,Language,NewQuantifiedFormula,Indent,AlreadyIndented,
+ConnectiveAbove).
+
+output_formula(Format,Language,QuantifiedManyVarsFormula,Indent,AlreadyIndented,
+ConnectiveAbove):-
+%----Check if this format wants separated variables
+    tptp2X_member(Format,[lf]),
+%----Check if there is a nested quantifier the same
+    quantified_formula(tptp,QuantifiedManyVarsFormula,Quantifier,
+[OneVariable,TwoVariables|MoreVariables],QuantifiedFormula,_,_,_,_,_),
+    !,
+    InnerQuantifier =.. [Quantifier,[TwoVariables|MoreVariables]],
+    InnerFormula =.. [:,InnerQuantifier,QuantifiedFormula],
+    OuterQuantifier =.. [Quantifier,[OneVariable]],
+    QuantifiedOneVarFormula =.. [:,OuterQuantifier,InnerFormula],
+    output_formula(Format,Language,QuantifiedOneVarFormula,Indent,
+AlreadyIndented,ConnectiveAbove).
 
 %----Write a quantified formula
-output_formula(Format,QuantifiedFormula,Indent,AlreadyIndented,_):-
+output_formula(Format,Language,QuantifiedFormula,Indent,AlreadyIndented,
+ConnectiveAbove):-
 %----Check if a quantified formula
     quantified_formula(tptp,QuantifiedFormula,_,_,_,_,_,_,_,_),
     !,
@@ -145,25 +228,49 @@
 Formula,FormulaPrefix,VariablesPrefix,VariablesSeparator,VariablesSuffix,
 FormulaSuffix),
     output_indent(Indent,AlreadyIndented),
+%----If below an @ or = then ()
+    (   tptp2X_member(ConnectiveAbove,['@','='])
+   ->   (   write('( '),
+            FormulaIndent is Indent + 2
+        )
+    ;   FormulaIndent is Indent
+    ),
     write(FormulaPrefix),
+    tptp2X_atom_length(FormulaPrefix,FormulaPrefixLength),
     write(Quantifier),
+    tptp2X_atom_length(Quantifier,QuantifierLength),
     write(VariablesPrefix),
-    output_quantified_variables(Format,Variables,VariablesSeparator),
+    tptp2X_atom_length(VariablesPrefix,VariablesPrefixLength),
+    VariableIndent is FormulaIndent + FormulaPrefixLength + QuantifierLength +
+VariablesPrefixLength,
+    output_quantified_variables(Format,Language,Variables,VariablesSeparator,
+VariableIndent,VariableIndent),
     write(VariablesSuffix),
 %----If a literal formula then no nl, just output it HMMMM, not so nice
-    (tptp_literal_formula(Formula,_) ->
-        output_formula(Format,Formula,Indent,Indent,Quantifier);
-        (   nl,
+    (   tptp_literal_formula(Formula,_)
+    ->  (   NewIndent is FormulaIndent + 2,
+            output_formula(Format,Language,Formula,NewIndent,NewIndent,
+Quantifier)
+        )
+    ;   (   nl,
 %----If a quantified formula then no extra indent
-            (quantified_formula(Format,Formula,_,_,_,_,_,_,_,_) ->
-                NewIndent is Indent;
-                NewIndent is Indent + 2),
+            (   quantified_formula(Format,Formula,_,_,_,_,_,_,_,_)
+            ->  NewIndent is FormulaIndent
+            ;   NewIndent is FormulaIndent + 2
+            ),
 %----Output the (non-literal) formula
-            output_formula(Format,Formula,NewIndent,0,Quantifier))),
-    write(FormulaSuffix).
+            output_formula(Format,Language,Formula,NewIndent,0,Quantifier)
+        )
+    ),
+    write(FormulaSuffix),
+    (   tptp2X_member(ConnectiveAbove,['@','='])
+   ->   write(' )')
+    ;   true
+    ).
 
 %----Write a binary formula 
-output_formula(Format,BinaryFormula,Indent,AlreadyIndented,LastConnective):-
+output_formula(Format,Language,BinaryFormula,Indent,AlreadyIndented,
+ConnectiveAbove):-
 %----Check if a binary formula
     binary_formula(tptp,BinaryFormula,_,_,_,_,_,_,_),
     !,
@@ -174,47 +281,74 @@
     output_indent(Indent,AlreadyIndented),
     name(Connective,ConnectiveASCII),
     tptp2X_length(ConnectiveASCII,ConnectiveLength),
-%----If in a sequence of and or ors, then no brackets or indent. 
-    (   (   (   Connective == LastConnective,
-%----Omit brackets for AND and OR. Not implications, etc, because it's
-%----not associative
-%----|;BUG
-                tptp2X_member(Connective,[/\,\/,&,'|',';']))
+%----If in a sequence of associative, then no brackets or indent. 
+    (   (   (   Connective == ConnectiveAbove,
+%----Omit brackets for associative operators
+                tptp_associative_binary_connective(Connective)
+            )
 %----Outermost never needs brackets
-            ;   LastConnective == outermost) ->
-        (   ConnectiveIndent is Indent - 2 - ConnectiveLength + 1,
+            ;   ConnectiveAbove == outermost
+        )
+    ->  (   ConnectiveIndent is Indent + 1 - ConnectiveLength - 2,
             NewIndent is Indent,
-            NewAlreadyIndented is Indent);
-        (   write(PrefixBracket),
+            NewAlreadyIndented is Indent
+        )
+    ;   (   write(PrefixBracket),
 %----Indent further if not the same as the last connective
-            ConnectiveIndent is Indent - ConnectiveLength + 1,
+            ConnectiveIndent is Indent + 1 - ConnectiveLength,
             NewIndent is Indent + 2,
-            NewAlreadyIndented is Indent + 2)),
-%DEBUG write('% LHS--- '),write(LHS),nl,
-    output_formula(Format,LHS,NewIndent,NewAlreadyIndented,none),
-%----Write connective on next line
-    nl,
-    output_indent(ConnectiveIndent,0),
+            NewAlreadyIndented is Indent + 2
+        )
+    ),
+%----Use none for left ()ed right associative connectives, to force ()s
+    (   (   tptp_right_associative_binary_connective(Connective),
+            binary_formula(tptp,LHS,Connective,_,_,_,_,_,_)
+        )
+    ->  FakeLHSConnectiveAbove = none
+    ;   FakeLHSConnectiveAbove = Connective
+    ),
+    output_formula(Format,Language,LHS,NewIndent,NewAlreadyIndented,
+FakeLHSConnectiveAbove),
+%----Write connective on next line except for a flat situation
+    (   (   tptp_flat_binary_connnective(Connective),
+            tptp_flat_binary_formula(RHS,_RHSConnective),
+            \+ quantified_formula(tptp,LHS,_,_,_,_,_,_,_,_)
+        )
+    ->  write(' ')
+    ;   (   nl,
+            output_indent(ConnectiveIndent,0))
+    ),
     write(ConnectivePrefix),
     write(Connective),
     write(ConnectiveSuffix),
-    output_formula(Format,RHS,NewIndent,NewAlreadyIndented,Connective),
-    (   (   (   Connective == LastConnective,
-%ZZZZZZZZZZZZZ Won't work for all formats
-%----|;BUG
-                tptp2X_member(Connective,[/\,\/,&,'|',';']))
-            ;   LastConnective == outermost) ->
-        true;
-        write(SuffixBracket)).
-
-%----Infix equality
-output_formula(tptp,~equal(LHS,RHS),Indent,AlreadyIndented,LastConnective):-
+%----Use none for right ()ed left associative connectives, to force ()s
+    (   (   tptp_left_associative_binary_connective(Connective),
+            binary_formula(tptp,RHS,Connective,_,_,_,_,_,_)
+        )
+    ->  FakeRHSConnectiveAbove = none
+    ;   FakeRHSConnectiveAbove = Connective
+    ),
+    output_formula(Format,Language,RHS,NewIndent,NewAlreadyIndented,
+FakeRHSConnectiveAbove),
+    (   (   (   Connective == ConnectiveAbove,
+                tptp_associative_binary_connective(Connective)
+            )
+            ;   ConnectiveAbove == outermost
+        )
+    ->  true
+    ;   write(SuffixBracket)
+    ).
+
+%----Infix negated equality becomes inequality
+output_formula(tptp,Language,~'$tptp_equal'(LHS,RHS),Indent,AlreadyIndented,
+ConnectiveAbove):-
     !,
-    output_formula(tptp,tptp_not_equal(LHS,RHS),Indent,AlreadyIndented,
-LastConnective).
+    output_formula(tptp,Language,'$tptp_not_equal'(LHS,RHS),Indent,
+AlreadyIndented,ConnectiveAbove).
 
 %----Write a unary formula
-output_formula(Format,UnaryFormula,Indent,AlreadyIndented,_):-
+output_formula(Format,Language,UnaryFormula,Indent,AlreadyIndented,
+ConnectiveAbove):-
     unary_formula(tptp,UnaryFormula,_,_,_,_,_),
     !,
 %----Get information for the specified format
@@ -222,35 +356,178 @@
 ConnectiveSuffix,FormulaSuffix),
     output_indent(Indent,AlreadyIndented),
     write(FormulaPrefix),
+    tptp2X_atom_length(FormulaPrefix,FormulaPrefixLength),
+%----If below an @ or = then ()
+    (   tptp2X_member(ConnectiveAbove,['@','='])
+   ->   (   write('( '),
+            FormulaIndent is Indent + 2
+        )
+    ;   FormulaIndent is Indent
+    ),
     write(Connective),
+    tptp2X_atom_length(Connective,ConnectiveLength),
     write(ConnectiveSuffix),
-%----If a quantified formula, then () it
-    (quantified_formula(Format,Formula,_,_,_,_,_,_,_,_) ->
-        (   write('( '),
-            NewIndent is Indent + 4,
-            AlreadyIndented1 is Indent + 4);
-        (   NewIndent is Indent + 2,
-            AlreadyIndented1 is Indent + 2)),
-    output_formula(Format,Formula,NewIndent,AlreadyIndented1,Connective),
-    (quantified_formula(Format,Formula,_,_,_,_,_,_,_,_) ->
-        write(' )');
-        true),
-    write(FormulaSuffix).
+    tptp2X_atom_length(ConnectiveSuffix,ConnectiveSuffixLength),
+%----THF requires all unary formulae to () their bodies, which sucks because
+%----negated atoms are ()ed, which fucks up clauses. Further, my parsers
+%----don't need the ()s for quantified, but some do so put them in.
+%----Put '~' in list for THF
+    (   (   Language == thf
+        ;   quantified_formula(Format,Formula,_,_,_,_,_,_,_,_)
+        )
+    ->  (   write('( '),
+            BracketIndent = 2,
+            FakeConnective = outermost )
+    ;   (   BracketIndent = 0,
+            FakeConnective = Connective
+        )
+    ),
+    NewIndent is FormulaIndent + ConnectiveLength + 1 + BracketIndent,
+    AlreadyIndented1 is FormulaIndent + FormulaPrefixLength + ConnectiveLength +
+ConnectiveSuffixLength + BracketIndent,
+%----Use outermost to suppress inner ()s now that all negated get ()s here
+%----Change Connective back to outermost for THF
+    output_formula(Format,Language,Formula,NewIndent,AlreadyIndented1,
+FakeConnective),
+    write(FormulaSuffix),
+%----See comment above
+    (   (   Language = thf
+        ;   quantified_formula(Format,Formula,_,_,_,_,_,_,_,_)
+        )
+    ->  write(' )')
+    ;   true
+    ),
+    (   tptp2X_member(ConnectiveAbove,['@','='])
+   ->   write(' )')
+    ;   true
+    ).
+
+%----Definitions and types
+%----If the definition is flat, do all on one line
+output_formula(Format,Language,TwoPart,Indent,AlreadyIndented,
+_ConnectiveAbove):-
+    tptp2X_member(Format,[tptp,lf]),
+    nonvar(TwoPart),
+    TwoPart =.. [:=,Symbol,Definition],
+    tptp_flat_binary_formula(Definition,_),
+    !,
+    output_indent(Indent,AlreadyIndented),
+    output_atom_for_format(Format,Language,Symbol),
+    output_defn_type_separator_for_format(Format,':=',Definition),
+    write(' '),
+    NewIndent is Indent + 2,
+    output_formula(Format,Language,Definition,NewIndent,NewIndent,outermost).
+
+%----If the type is flat and it's a constant, do all on one line
+output_formula(Format,Language,TwoPart,Indent,AlreadyIndented,
+_ConnectiveAbove):-
+    tptp2X_member(Format,[tptp,lf]),
+    nonvar(TwoPart),
+    TwoPart =.. [Separator,Symbol,Type],
+    tptp2X_member(Separator,[':','<<']),
+    atomic(Symbol),
+    tptp_flat_type(Type,BinaryTypeConnective),
+    !,
+    output_indent(Indent,AlreadyIndented),
+    output_atom_for_format(Format,Language,Symbol),
+    output_defn_type_separator_for_format(Format,Separator,Type),
+    write(' '),
+    NewIndent is Indent + 2,
+    (   BinaryTypeConnective == '@'
+    ->  StartLevel = none
+    ;   StartLevel = outermost
+    ),
+    output_formula(Format,Language,Type,NewIndent,NewIndent,StartLevel).
+
+%----If a type or definition is not flat, do on next line
+output_formula(Format,Language,TwoPart,Indent,AlreadyIndented,ConnectiveAbove):-
+    tptp2X_member(Format,[tptp,lf]),
+    nonvar(TwoPart),
+    TwoPart =.. [Separator,Symbol,TypeOrDefn],
+    tptp2X_member(Separator,[':=',':','<<']),
+    !,
+%----If after a quantifier then go to new line
+    (   tptp_quantifier(ConnectiveAbove) ->
+        (   nl,
+            output_indent(Indent,0)
+        )
+    ;   output_indent(Indent,AlreadyIndented)
+    ),
+%----Always () non-atomic LHS of a type defn.
+%    (   tptp_atomic_formula(Symbol)
+%    ->  LHRIndent is Indent
+%    ;   (   write('( '),
+%            LHRIndent is Indent + 2
+%        )
+%    ),
+%    output_formula(Format,Language,Symbol,LHRIndent,LHRIndent,Separator),
+%    (   tptp_atomic_formula(Symbol)
+%    ->  true
+%    ;   write(' )')
+%    ),
+    output_formula(Format,Language,Symbol,Indent,Indent,Separator),
+    output_defn_type_separator_for_format(Format,Separator,TypeOrDefn),
+    nl,
+    RHSIndent is Indent + 2,
+    output_formula(Format,Language,TypeOrDefn,RHSIndent,0,none).
+
+%----Tuples
+output_formula(_,_,[],Indent,AlreadyIndented,_):-
+    !,
+    output_indent(Indent,AlreadyIndented),
+    write('[ ]').
+
+output_formula(Format,Language,[FirstFormula|RestOfFormulae],Indent,
+AlreadyIndented,ConnectiveAbove):-
+    (   (   ConnectiveAbove == outermost
+        ;   ConnectiveAbove == none
+        ;   ConnectiveAbove == '-->'
+        )
+    ->  output_indent(Indent,AlreadyIndented)
+    ;   (   nl,
+            output_indent(Indent,0)
+        )
+    ),
+    NewIndent is Indent + 2,
+    write('[ '),
+    output_formula(Format,Language,FirstFormula,NewIndent,NewIndent,none),
+    output_rest_of_tuple(Format,Language,FirstFormula,RestOfFormulae,
+NewIndent,NewIndent),
+    write(' ]').
 
 %----Write an atomic formula
-output_formula(Format,Atom,Indent,AlreadyIndented,_):-
+output_formula(Format,Language,Atom,Indent,AlreadyIndented,ConnectiveAbove):-
     output_indent(Indent,AlreadyIndented),
-    output_atom_for_format(Format,Atom).
+    output_atom_for_format(Format,Language,Atom,Indent,Indent,ConnectiveAbove).
+%------------------------------------------------------------------------------
+output_rest_of_tuple(_,_,_,[],_,_).
+
+output_rest_of_tuple(Format,Language,PrintedFormula,[FirstFormula|
+RestOfFormulae],Indent,AlreadyIndented):-
+    tptp_atomic_formula(PrintedFormula),
+    tptp_atomic_formula(FirstFormula),
+    !,
+    write(', '),
+    output_formula(Format,Language,FirstFormula,Indent,AlreadyIndented,none),
+    output_rest_of_tuple(Format,Language,FirstFormula,RestOfFormulae,Indent,
+AlreadyIndented).
+
+output_rest_of_tuple(Format,Language,_,[FirstFormula|RestOfFormulae],Indent,_):-
+    write(','),
+    nl,
+    output_formula(Format,Language,FirstFormula,Indent,0,none),
+    output_rest_of_tuple(Format,Language,FirstFormula,RestOfFormulae,Indent,
+Indent).
 %------------------------------------------------------------------------------
 %----Output a formula in the genric TPTP form, paramterized for actual
 %----format
-output_generic_formula(Format,Formula):-
+output_generic_formula(Format,Language,Formula):-
 %----Start with no last connective, to omit brackets on binary formulae
-    output_formula(Format,Formula,4,0,_outermost).
+    output_formula(Format,Language,Formula,4,0,none_outermost).
 %------------------------------------------------------------------------------
 %----Simplify quantified formulae
 output_prefix_formula(Format,QuantifiedQuantifiedFormula,Indent,
-AlreadyIndented,LastConnective):-
+AlreadyIndented,ConnectiveAbove):-
 %----Check if this format wants merged variables
     tptp2X_member(Format,[]),
 %----Check if there is a nested quantifier the same
@@ -265,13 +542,13 @@
     NewQuantifiedFormula =.. [:,NewQuantification,Formula],
 %----Try agains with the new formula
     output_prefix_formula(Format,NewQuantifiedFormula,Indent,AlreadyIndented,
-LastConnective).
+ConnectiveAbove).
 
 %----Unsimplify quantified formulae
 output_prefix_formula(Format,QuantifiedFormula,Indent,AlreadyIndented,
-LastConnective):-
+ConnectiveAbove):-
 %----Check if this format wants separated variables
-    tptp2X_member(Format,[oscar]),
+    tptp2X_member(Format,[oscar,smt]),
 %----Check if there are several quantified variables
     quantified_formula(tptp,QuantifiedFormula,Quantifier,[V1,V2|
 RestOfVariables],Formula,_,_,_,_,_),
@@ -283,7 +560,7 @@
     NewQuantifiedFormula =.. [:,NewQuantification,InnerQuantifiedFormula],
 %----Try agains with the new formula
     output_prefix_formula(Format,NewQuantifiedFormula,Indent,AlreadyIndented,
-LastConnective).
+ConnectiveAbove).
 
 %----Write a quantified formula
 output_prefix_formula(Format,QuantifiedFormula,Indent,AlreadyIndented,_):-
@@ -296,55 +573,85 @@
 FormulaSuffix),
     output_indent(Indent,AlreadyIndented),
     write(FormulaPrefix),
+    tptp2X_atom_length(FormulaPrefix,FormulaPrefixLength),
     write(Quantifier),
+    tptp2X_atom_length(Quantifier,QuantifierLength),
     write(VariablesPrefix),
-    output_quantified_variables(Format,Variables,VariablesSeparator),
+    tptp2X_atom_length(VariablesPrefix,VariablesPrefixLength),
+    NewAlreadyIndented is Indent + FormulaPrefixLength + QuantifierLength +
+VariablesPrefixLength,
+    output_quantified_variables(Format,unknown,Variables,VariablesSeparator,
+Indent,NewAlreadyIndented),
     write(VariablesSuffix),
 %----If a literal formula then no nl, just output it HMMMM, not so nice
-    (tptp_literal_formula(Formula,_) ->
-        output_prefix_formula(Format,Formula,Indent,Indent,Quantifier);
-        (   nl,
+    (   tptp_literal_formula(Formula,_)
+    ->  output_prefix_formula(Format,Formula,Indent,Indent,Quantifier)
+    ;   (   nl,
 %----If a quantified formula then no extra indent
-            (quantified_formula(Format,Formula,_,_,_,_,_,_,_,_) ->
-                NewIndent is Indent;
-                NewIndent is Indent + 2),
+            (   quantified_formula(tptp,Formula,_,_,_,_,_,_,_,_)
+            ->  NewIndent is Indent
+            ; NewIndent is Indent + 2
+            ),
 %----Output the (non-literal) formula
             output_prefix_formula(Format,Formula,NewIndent,0,Quantifier))),
     write(FormulaSuffix).
 
 %----Write a binary formula 
-output_prefix_formula(Format,BinaryFormula,Indent,AlreadyIndented,_):-
+output_prefix_formula(Format,BinaryFormula,Indent,AlreadyIndented,
+ConnectiveAbove):-
 %----Check if it is binary
-    binary_formula(tptp,BinaryFormula,_,_,_,_,_,_,_),
+    binary_formula(tptp,BinaryFormula,TPTPConnective,_,_,_,_,_,_),
     !,
 %----Get data for this format
     binary_formula(Format,BinaryFormula,Connective,LHS,RHS,PrefixBracket,
 ConnectivePrefix,ConnectiveSuffix,SuffixBracket),
-    output_indent(Indent,AlreadyIndented),
-    write(PrefixBracket),
-    write(ConnectivePrefix),
+    (   (   ConnectiveAbove == Connective,
+            tptp_associative_binary_connective(TPTPConnective)
+        ) ->
+        (   output_indent(Indent,AlreadyIndented),
+            output_prefix_formula(Format,LHS,Indent,Indent,none),
+            nl,
+            output_prefix_formula(Format,RHS,Indent,0,Connective)
+        )
+    ;   (   output_indent(Indent,AlreadyIndented),
+            NewIndent is Indent + 4,
+            Connective == '' ->
+                (   output_prefix_formula(Format,LHS,NewIndent,NewIndent,none),
+                    NewAlreadyIndented is NewIndent - 1,
+                    output_prefix_formula(Format,RHS,NewIndent,
+NewAlreadyIndented,Connective)
+                )
+            ;   (   write(PrefixBracket),
+                    write(ConnectivePrefix),
 %----No connective prefix now, do by length
-    name(Connective,ConnectiveASCII),
-    tptp2X_length(ConnectiveASCII,ConnectiveLength),
-    (ConnectiveLength == 3 ->
-        (   ConnectivePreSpace = 0,
-            ConnectivePostSpace = 1);
-        (ConnectiveLength == 2 ->
-            (   ConnectivePreSpace = 0,
-                ConnectivePostSpace = 1);
-            (   ConnectivePreSpace = 1,
-                ConnectivePostSpace = 1))),
-    tptp2X_tab(ConnectivePreSpace),
-    write(Connective),
-    tptp2X_tab(ConnectivePostSpace),
-%----No suffix at the moment
-    write(ConnectiveSuffix),
-%DEBUG write('% LHS--- '),write(LHS),nl,
-    NewIndent is Indent + 4,
-    output_prefix_formula(Format,LHS,NewIndent,NewIndent,none),
-    nl,
-    output_prefix_formula(Format,RHS,NewIndent,0,Connective),
-    write(SuffixBracket).
+                    tptp2X_atom_length(Connective,ConnectiveLength),
+                    (   ConnectiveLength >= 3 ->
+                        (   ConnectivePreSpace = 0,
+                            ConnectivePostSpace = 1
+                        )
+                        ;   (   ConnectiveLength == 2 ->
+                                (   ConnectivePreSpace = 0,
+                                    ConnectivePostSpace = 1
+                                )
+                            ;   (   ConnectivePreSpace = 1,
+                                    ConnectivePostSpace = 1
+                                )
+                            )
+                    ),
+                    tptp2X_tab(ConnectivePreSpace),
+                    write(Connective),
+                    tptp2X_tab(ConnectivePostSpace),
+                    write(ConnectiveSuffix),
+                    NewIndent is Indent + 4,
+                    output_prefix_formula(Format,LHS,NewIndent,NewIndent,none),
+                    nl,
+                    NewAlreadyIndented = 0,
+                    output_prefix_formula(Format,RHS,NewIndent,
+NewAlreadyIndented,Connective),
+                    write(SuffixBracket)
+                )
+        )
+    ).
 
 %----Write a unary formula
 output_prefix_formula(Format,UnaryFormula,Indent,AlreadyIndented,_):-
@@ -365,10 +672,9 @@
 %----Write an atomic formula
 output_prefix_formula(Format,Atom,Indent,AlreadyIndented,_):-
     output_indent(Indent,AlreadyIndented),
-    output_atom_for_format(Format,Atom).
+    output_atom_for_format(Format,unknown,Atom).
 %------------------------------------------------------------------------------
-%----Output a formula in the generic OSCAR form, paramterized for actual
-%----format
+%----Output a formula in the generic form, paramterized for actual format
 output_generic_prefix_formula(Format,Formula):-
     output_prefix_formula(Format,Formula,4,0,outermost).
 %------------------------------------------------------------------------------
diff -ur 1/TPTP2X/tptp2X_install 2/TPTP2X/tptp2X_install
--- 1/TPTP2X/tptp2X_install	2007-03-01 12:01:53.000000000 -0500
+++ 2/TPTP2X/tptp2X_install	2012-08-13 14:45:12.000000000 -0400
@@ -1,84 +1,127 @@
 #!/bin/csh
 #--------------------------------------------------------------------------
-clear
+#----If -default flag is specified, just take what happens and report
+if ("$1" == "-default") then
+    set Defaults = "yes"
+else
+    set Defaults = "no"
+endif
+
 echo "--------------------------------------------------------------------"
 echo "                This is the tptp2X installation"
 echo ""
-echo "All paths must be absolute."
-echo "Press return to accept the default values in []s"
+if ($Defaults == "yes") then
+    echo "Taking all defaults - you should check them!"
+else
+    echo "All paths must be absolute."
+    echo "Press return to accept the default values in []s"
+endif
 echo "--------------------------------------------------------------------"
 #--------------------------------------------------------------------------
-#----adapted to ILTP library, JO, January '06
+#----TPTP directory
+#----Look for TPTP environment variable
+set TPTPDirectory = `printenv TPTP`
+#----Look for TPTP_HOME environment variable
+if ("$TPTPDirectory" == "") then
+    set TPTPDirectory = `printenv TPTP_HOME`
+    if ("$TPTPDirectory" != "") then
+#----Look for TPTP-v*
+        set LSOutput = `ls -d $TPTPDirectory/TPTP-v*`
+        if ("$LSOutput" != "" && (-d "$LSOutput")) then
+            set TPTPDirectory = $LSOutput
+        else
+#----Look for TPTP* (for me)
+            set LSOutput = `ls -d $TPTPDirectory/TPTP*`
+            if ("$LSOutput" != "" && (-d "$LSOutput")) then
+                set TPTPDirectory = $LSOutput
+            else
+                set TPTPDirectory = ""
+            endif
+        endif
+    endif
+endif
 
-#----ILTP directory
-#----Look for being in or below ILTP-v*
-set TPTPDirectory=`expr "$cwd" : "\(.*ILTP-v[0-9\.]*-firstorder\).*"`
-#----Look for being below ILTP (for me)
+#----Look for being in or below TPTP-v*
 if ("$TPTPDirectory" == "") then
-    set TPTPDirectory=`expr "$cwd" : "\(.*ILTP\)\/.*"`
+    set TPTPDirectory=`expr "$cwd" : "\(.*TPTP-v[0-9\.]*\).*"`
 endif
-#----Look for being in ILTP (for me)
+#----Look for being below TPTP (for me)
 if ("$TPTPDirectory" == "") then
-    set TPTPDirectory=`expr "$cwd" : "\(.*ILTP\)"`
+    set TPTPDirectory=`expr "$cwd" : "\(.*TPTP\)\/.*"`
 endif
-#----Look for being above ILTP-v* (for installation)
+#----Look for being in TPTP (for me)
 if ("$TPTPDirectory" == "") then
-    set LSOutput=`ls -d ILTP-v?.?`
+    set TPTPDirectory=`expr "$cwd" : "\(.*TPTP\)"`
+endif
+#----Look for being above TPTP-v* (for installation)
+if ("$TPTPDirectory" == "") then
+    set LSOutput=`ls -d TPTP-v*.*.*`
     if ("$LSOutput" != "" && (-d "$LSOutput")) then
-        set TPTPDirectory="$cwd/"`expr "$LSOutput" : "\(.*ILTP-v[0-9\.]*-firstorder\).*"`
+        set TPTPDirectory="$cwd/"`expr "$LSOutput" : "\(.*TPTP-v[0-9\.]*\).*"`
     endif
 endif
 
-#----Now ask the user
-set LegalResponse=no
-echo "The ILTP directory must contain the TPTP2X directory."
-while ($LegalResponse != yes)
-    echo -n "ILTP directory        [$TPTPDirectory] : "
-    set Response=$<
-    if ($Response == "") then
-        set Response=$TPTPDirectory
+if ($Defaults == "yes") then
+    if ($TPTPDirectory != "") then
+        echo "TPTP directory     : $TPTPDirectory"
+    else
+        echo "ERROR: TPTP directory not found"
+        exit 1;
     endif
+else
+#----Ask the user
+    set LegalResponse=no
+    echo "The TPTP directory must contain the TPTP2X directory."
+    while ($LegalResponse != yes)
+        echo -n "TPTP directory        [$TPTPDirectory] : "
+        set Response=$<
+        if ($Response == "") then
+            set Response=$TPTPDirectory
+        endif
 #----Check for non empty response
-    if ("$Response" != "") then
-#----Check that the ILTP directory exists
-        if (!(-d $Response)) then
-            echo "Cannot find the ILTP directory."
-            continue
+        if ("$Response" != "") then
+#----Check that the TPTP directory exists
+            if (!(-d "$Response")) then
+                echo "$Response is not a directory"
+            else
+                set LegalResponse=yes
+                set TPTPDirectory=$Response
+            endif
         endif
-        set TPTP2XDirectory=$Response/TPTP2X
+    end
+    echo "--------------------------------------------------------------------"
+endif
+#--------------------------------------------------------------------------
 #----Check that the TPTP2X directory exists
-        if (!(-d $TPTP2XDirectory)) then
-            echo "Cannot find the TPTP2X directory."
-            continue
-        endif
+set TPTP2XDirectory=$TPTPDirectory/TPTP2X
+if (!(-d $TPTP2XDirectory)) then
+    echo "ERROR: $TPTPDirectory does not contain the TPTP2X directory"
+    exit 1
+endif
 #----Check that tptp2X.config exists (rough check of the directory)
-        if (!(-f $TPTP2XDirectory/tptp2X.config)) then
-            echo "Cannot find the tptp2X.config file."
-            continue
-        endif
-        set LegalResponse=yes
-        set TPTPDirectory=$Response
-    endif
-end
-echo "--------------------------------------------------------------------"
+if (!(-f $TPTP2XDirectory/tptp2X.config)) then
+    echo "ERROR: $TPTP2XDirectory does not contain the tptp2X.config"
+    exit 1
+endif
 #--------------------------------------------------------------------------
-#----PrologDialect
+#----PrologDialect 
+#----GNU does not work due to lack of compile/1 or consult/1 as a directive
 #----Look for a reasonable default 
 set PrologDialect=""
-if ("`which sicstus`" =~ /*) then
-    set PrologDialect=sicstus
+if ("`which eclipse`" =~ /*) then
+    set PrologDialect=eclipse
 else 
-    if ("`which quintus`" =~ /*) then
-        set PrologDialect=quintus
-    else 
-        if ("`which eclipse`" =~ /*) then
-            set PrologDialect=eclipse
-        else
-            if ("`which pl`" =~ /* || "`which swipl`" =~ /*) then
-                set PrologDialect=swi
+    if ("`which yap`" =~ /*) then
+        set PrologDialect=yap
+    else
+        if ("`which pl`" =~ /* || "`which swipl`" =~ /*) then
+            set PrologDialect=swi
+        else 
+            if ("`which sicstus`" =~ /*) then
+                set PrologDialect=sicstus
             else 
-                if ("`which yap`" =~ /*) then
-                    set PrologDialect=yap
+                if ("`which quintus`" =~ /*) then
+                    set PrologDialect=quintus
                 else 
                     set PrologDialect=generic
                 endif
@@ -86,24 +129,34 @@
         endif
     endif
 endif
-#----Check with the user
-set LegalResponse=no
-echo "The Prolog dialect must be one of :"
-echo "    generic, swi, sicstus, yap, quintus, eclipse"
-while ($LegalResponse != yes)
-    echo -n "Prolog dialect        [$PrologDialect] : "
-    set Response=$<
-    if ($Response == "") then
-        set Response=$PrologDialect
-    endif
-    if (_generic_swi_yap_sicstus_quintus_eclipse_ =~ *_${Response}_*) then
-        set LegalResponse=yes
-        set PrologDialect=$Response
+
+if ($Defaults == "yes") then
+    if ($PrologDialect != "") then
+        echo "Prolog dialect     : $PrologDialect"
     else
-        echo $Response is not a valid Prolog dialect.
+        echo "ERROR: Prolog dialect not found"
+        exit 1;
     endif
-end
-echo "--------------------------------------------------------------------"
+else
+#----Check with the user
+    set LegalResponse=no
+    echo "The Prolog dialect must be one of :"
+    echo "    eclipse, yap, swi, sicstus, quintus, generic"
+    while ($LegalResponse != yes)
+        echo -n "Prolog dialect        [$PrologDialect] : "
+        set Response=$<
+        if ($Response == "") then
+            set Response=$PrologDialect
+        endif
+        if (_eclipse_yap_swi_sicstus_quintus_generic_ =~ *_${Response}_*) then
+            set LegalResponse=yes
+            set PrologDialect=$Response
+        else
+            echo $Response is not a valid Prolog dialect.
+        endif
+    end
+    echo "--------------------------------------------------------------------"
+endif
 #--------------------------------------------------------------------------
 #----PrologInterpreter
 #----Look for a reasonable default executable
@@ -112,14 +165,17 @@
     case generic:
         set AbsolutePath=`which prolog`
         breaksw
-    case bin:
-        set AbsolutePath=`which bp`
+    case eclipse
+        set AbsolutePath=`which eclipse`
         breaksw
     case yap:
         set AbsolutePath=`which yap`
         breaksw
+    case gnu:
+        set AbsolutePath=`which gprolog`
+        breaksw
     case swi:
-        set AbsolutePath=`which swipl pl | grep "^/" | head -1`
+        set AbsolutePath=`which swipl | grep "^/" | head -1`
         breaksw
     case sicstus:
         set AbsolutePath=`which sicstus`
@@ -127,8 +183,8 @@
     case quintus:
         set AbsolutePath=`which quintus`
         breaksw
-    case eclipse
-        set AbsolutePath=`which eclipse`
+    case bin:
+        set AbsolutePath=`which bp`
         breaksw
 endsw
 #----Check that the Prolog interpreter can be found
@@ -139,40 +195,52 @@
 #----Not found, no default
         set PrologInterpreter=""
     endif
-set LegalResponse=no
-echo "The Prolog interpreter must be an executable."
-while ($LegalResponse != yes)
-    echo -n "Prolog interpreter    [$PrologInterpreter] : "
-    set Response=$<
-    if ("$Response" == "") then
-        set Response=$PrologInterpreter
+
+if ($Defaults == "yes") then
+    if ($PrologInterpreter != "") then
+        echo "Prolog interpreter : $PrologInterpreter"
+    else
+        echo "ERROR: Prolog interpreter not found"
+        exit 1;
     endif
+else
+#----Ask the user
+    set LegalResponse=no
+    echo "The Prolog interpreter must be an executable."
+    while ($LegalResponse != yes)
+        echo -n "Prolog interpreter    [$PrologInterpreter] : "
+        set Response=$<
+        if ("$Response" == "") then
+            set Response=$PrologInterpreter
+        endif
 #----An empty default is possible, so check that is was not taken
-    if ("$Response" != "") then
+        if ("$Response" != "") then
 #----Check that the Prolog interpreter can be found
-        set AbsolutePath=`which $Response`
+            set AbsolutePath=`which $Response`
 #----Have to do this in two steps so -x check lives
-        if ("$AbsolutePath" !~ /* || "$AbsolutePath" =~ *"not found") then
-            set AbsolutePath=very_unlikely_file_name
-        endif
-        if (-x $AbsolutePath) then
-            set LegalResponse=yes
-            set PrologInterpreter=$AbsolutePath
-        else
-            echo $Response does not lead to an executable.
+            if ("$AbsolutePath" !~ /* || "$AbsolutePath" =~ *"not found") then
+                set AbsolutePath=very_unlikely_file_name
+            endif
+            if (-x $AbsolutePath) then
+                set LegalResponse=yes
+                set PrologInterpreter=$AbsolutePath
+            else
+                echo $Response does not lead to an executable.
+            endif
         endif
-    endif
-end
+    end
 
 #---Simple sanity check on the interpreter
-$PrologInterpreter < /dev/null |& grep -i $PrologDialect >& /dev/null
-if ($status != 0) then
-    echo "WARNING: $PrologInterpreter does not look like $PrologDialect"
-    echo -n "Do you want to continue? [n] : "
-    set Continue=$<
-    if ("$Continue" !~ Y* && "$Continue" !~ y*) then
-        exit
+    $PrologInterpreter < /dev/null |& grep -i $PrologDialect >& /dev/null
+    if ($status != 0 && $PrologDialect != "generic") then
+        echo "WARNING: $PrologInterpreter does not look like $PrologDialect"
+        echo -n "Do you want to continue? [n] : "
+        set Continue=$<
+            if ("$Continue" !~ Y* && "$Continue" !~ y*) then
+            exit 1
+        endif
     endif
+    echo "--------------------------------------------------------------------"
 endif
 
 #----Set flags to keep things quiet, etc
@@ -180,29 +248,31 @@
     case generic:
         set PrologArguments=''
         breaksw
-    case bin:
-#----Larger heap (required for generators) and larger trail and larger
-#----hash table (for doing many files in batch)
-        set PrologArguments='-h25000 -s2000 -t5000 -d20 -a18'
-        breaksw
-    case swi:
-        set PrologArguments='-A0 -L0 -T0 -G128M'
+    case eclipse
+#----Larger stack for those SYNs with DFG
+        set PrologArguments='-l 1024000 -g 1024000'
         breaksw
     case yap:
         set PrologArguments=''
         breaksw
+    case gnu:
+        set PrologArguments=''
+        breaksw
+    case swi:
+        set PrologArguments='-G0 -L0 -T0 -G256M'
+        breaksw
     case sicstus:
         set PrologArguments=''
         breaksw
     case quintus:
         set PrologArguments=''
         breaksw
-    case eclipse
-#----Larger stack for those SYNs with DFG
-        set PrologArguments='-l 512000'
+    case bin:
+#----Larger heap (required for generators) and larger trail and larger
+#----hash table (for doing many files in batch)
+        set PrologArguments='-h25000 -s2000 -t5000 -d20 -a18'
         breaksw
 endsw
-echo "--------------------------------------------------------------------"
 #--------------------------------------------------------------------------
 #----Shell
 #----Check that the Prolog interpreter can be found
@@ -224,9 +294,8 @@
     set Shell=`which csh`
 else
     set Shell=$AbsolutePath
-    echo "tcsh shell path is $Shell"
+    echo "tcsh shell         : $Shell"
 endif
-echo "--------------------------------------------------------------------"
 #--------------------------------------------------------------------------
 #----Gawk/awk
 #----Check that gawk or awk can be found
@@ -238,34 +307,45 @@
         set GawkPath=""
     endif
 endif
-set LegalResponse=no
-echo "gawk or awk is required for quietness modes 1 and 2."
-while ($LegalResponse != yes)
-    echo -n "gawk or awk path      [$GawkPath] : "
-    set Response=$<
-    if ("$Response" == "") then
-        set Response=$GawkPath
+
+if ($Defaults == "yes") then
+    if ($GawkPath != "") then
+        echo "awk or gawk        : $GawkPath"
+    else
+        echo "ERROR: awk and gawk not found"
+        exit 1
     endif
+else
+#----Ask the user
+    set LegalResponse=no
+    while ($LegalResponse != yes)
+        echo "gawk or awk is required for quietness modes 1 and 2."
+        echo -n "gawk or awk path      [$GawkPath] : "
+        set Response=$<
+        if ("$Response" == "") then
+            set Response=$GawkPath
+        endif
 #----An empty default is possible, so check that is was not taken
-    if ("$Response" != "") then
+        if ("$Response" != "") then
 #----Check that gawk/awk can be found
-        set AbsolutePath=`which $Response`
+            set AbsolutePath=`which $Response`
 #----Have to do this in two steps so -x check lives
-        if ("$AbsolutePath" !~ /*) then
-            set AbsolutePath=very_unlikely_file_name
-        endif
-        if (-x $AbsolutePath) then
-            set LegalResponse=yes
-            set GawkPath=$AbsolutePath
+            if ("$AbsolutePath" !~ /*) then
+                set AbsolutePath=very_unlikely_file_name
+            endif
+            if (-x $AbsolutePath) then
+                set LegalResponse=yes
+                set GawkPath=$AbsolutePath
+            else
+                echo $Response does not lead to an executable.
+            endif
         else
-            echo $Response does not lead to an executable.
-        endif
-    else
 #----Accept the empty string
-        set LegalResponse=yes
-    endif
-end
-echo "--------------------------------------------------------------------"
+            set LegalResponse=yes
+        endif
+    end
+    echo "--------------------------------------------------------------------"
+endif
 #--------------------------------------------------------------------------
 #----Choose format files
 #----Make list of available formats
@@ -274,8 +354,12 @@
 #----for [] style compilation
 set noglob
 #----Select available formats from tptp2X.main
-set AllYes = "n"
-echo "Answer y for formats you want, n you don't, or a if you want all"
+if ($Defaults == "yes") then
+    set AllYes = "y"
+else
+    set AllYes = "n"
+    echo "Answer y for formats you want, n you don't, or a if you want all"
+endif
 foreach FormatLine (`grep ":-.*format\.[a-zA-Z0-9]" $TPTP2XDirectory/tptp2X.main.uninstalled`)
     set FormatName = `expr "$FormatLine" : ".*format\.\([a-zA-Z0-9]*\).*"`
 #----Check with user unless tptp
@@ -300,7 +384,7 @@
 echo Installing tptp2X.config
 #----Remove the leading % in lines that refer to the specific dialect.
 #----Set the tptp_directory/1 fact
-sed -e "/\%\%$PrologDialect/s/^\% //" -e "/\%\%$PrologDialect/s/^\%//" -e "/^tptp_directory/s?.*?tptp_directory('$TPTPDirectory').?" $TPTP2XDirectory/tptp2X.config.uninstalled >$TPTP2XDirectory/tptp2X.config
+sed -e "/\%\%$PrologDialect/s/^\% //" -e "/\%\%$PrologDialect/s/^\%//" -e "/^tptp_directory/s?.*?tptp_directory('$TPTPDirectory').?" $TPTP2XDirectory/tptp2X.config.uninstalled >! $TPTP2XDirectory/tptp2X.config
 
 #----Set the mode 
 chmod 644 $TPTP2XDirectory/tptp2X.config
@@ -308,22 +392,27 @@
 #----Install tptp2X.main
 echo Installing tptp2X.main
 #----If a dialect that supports compile then convert the []s to compiles.
-if (_yap_swi_sicstus_quintus_eclipse_ =~ *_${PrologDialect}_*) then
-    sed -e "/:-\[/s/\[\(.*\)\]/compile(\1)/" $TPTP2XDirectory/tptp2X.main.uninstalled >$TPTP2XDirectory/tptp2X.main
+if (_yap_sicstus_quintus_eclipse_ =~ *_${PrologDialect}_*) then
+    set PrologsCompile = "compile"
+    sed -e "/:-\[/s/\[\(.*\)\]/compile(\1)/" $TPTP2XDirectory/tptp2X.main.uninstalled >! $TPTP2XDirectory/tptp2X.main
+else if (_gnu_swi_ =~ *_${PrologDialect}_*) then
+    set PrologsCompile = "consult"
+    sed -e "/:-\[/s/\[\(.*\)\]/consult(\1)/" $TPTP2XDirectory/tptp2X.main.uninstalled >! $TPTP2XDirectory/tptp2X.main
 else
-    echo "It is unknown if $PrologDialect Prolog supports compile/1."
+    set PrologsCompile = "consult"
+    echo "Unknown if $PrologDialect Prolog supports compile/1 or consult/1."
     echo "Source files will be loaded using []/1, in tptp2X.main"
     cp -f $TPTP2XDirectory/tptp2X.main.uninstalled $TPTP2XDirectory/tptp2X.main
 endif
 
 #----Comment all format modules out
-sed -e "/format\.[a-zA-Z0-9]/s/^[\%]*/\%/" $TPTP2XDirectory/tptp2X.main > $TPTP2XDirectory/tptp2X.main.noformats
-mv $TPTP2XDirectory/tptp2X.main.noformats $TPTP2XDirectory/tptp2X.main
+sed -e "/format\.[a-zA-Z0-9]/s/^[\%]*/\%/" $TPTP2XDirectory/tptp2X.main >! $TPTP2XDirectory/tptp2X.main.noformats
+/bin/mv $TPTP2XDirectory/tptp2X.main.noformats $TPTP2XDirectory/tptp2X.main
 #----Uncomment the required formats
 foreach Format ($RequiredFormats)
     echo "   Installing $Format format module"
-    sed -e "/format\.$Format/s/^\%//" $TPTP2XDirectory/tptp2X.main > $TPTP2XDirectory/tptp2X.main.noformats
-    mv $TPTP2XDirectory/tptp2X.main.noformats $TPTP2XDirectory/tptp2X.main
+    sed -e "/format\.$Format/s/^\%//" $TPTP2XDirectory/tptp2X.main >! $TPTP2XDirectory/tptp2X.main.noformats
+    /bin/mv $TPTP2XDirectory/tptp2X.main.noformats $TPTP2XDirectory/tptp2X.main
 end
 
 #----Set the mode 
@@ -333,7 +422,7 @@
 #----Install tptp2X: 
 echo Installing tptp2X
 #----Have to use ? as the separator as there are /s in the substitutions
-sed -e "1s?.*?#\!$Shell?" -e "/set TPTPDirectory/s?.*?set TPTPDirectory=$TPTPDirectory?" -e "/set PrologInterpreter/s?.*?set PrologInterpreter='$PrologInterpreter'?" -e "/set PrologArguments/s/.*/set PrologArguments='$PrologArguments'/" -e "/set Gawk=/s?.*?set Gawk=$GawkPath?" $TPTP2XDirectory/tptp2X.uninstalled >$TPTP2XDirectory/tptp2X
+sed -e "s/COMPILE/$PrologsCompile/" -e "1s?.*?#\!$Shell?" -e "/set TPTPDirectory/s?.*?set TPTPDirectory=$TPTPDirectory?" -e "/set PrologInterpreter/s?.*?set PrologInterpreter='$PrologInterpreter'?" -e "/set PrologArguments/s/.*/set PrologArguments='$PrologArguments'/" -e "/set Gawk=/s?.*?set Gawk=$GawkPath?" $TPTP2XDirectory/tptp2X.uninstalled >! $TPTP2XDirectory/tptp2X
 
 #----Set the mode to executable
 chmod 755 $TPTP2XDirectory/tptp2X
@@ -341,4 +430,5 @@
 echo "--------------------------------------------------------------------"
 echo "                tptp2X installation complete"
 echo "--------------------------------------------------------------------"
+exit 0
 #--------------------------------------------------------------------------
Only in 1/TPTP2X: ._tptp2X.main
diff -ur 1/TPTP2X/tptp2X.main 2/TPTP2X/tptp2X.main
--- 1/TPTP2X/tptp2X.main	2007-03-01 12:01:53.000000000 -0500
+++ 2/TPTP2X/tptp2X.main	2012-08-13 14:45:12.000000000 -0400
@@ -14,79 +14,111 @@
 %----Extensions for FOF by Geoff Sutcliffe, October 1996.
 %==============================================================================
 %------------------------------------------------------------------------------
+%----Load the configuration file
+:-compile('tptp2X.config').
+%------------------------------------------------------------------------------
 %----These are used in the TPTP and need to exist before the 
 %----transformations and formats are loaded. They are also declared at 
 %----runtime in tptp2X/4.
-%----$ binds more than -- to allow -- $(false)
-:-op(99,fx,'$').
+:-op(70,fx,'$$').
+:-op(80,fx,'$').
+:-op(90,xfx,/).     %----Rationals need to bind tighter than =
 :-op(100,fx,++).
 :-op(100,fx,--).
 %----Postfix for !=
 :-op(100,xf,'!').
-%----= must bind more tightly that quantifiers for ! [X] : a = X. That means
-%----for thof it is necessary to bracket formula terms, e.g., a = (! [X] : p(X))
+%---- .. used for range in tptp2X. Needs to be stronger than :
+:-op(400,xfx,'..').
+%----! and ? are of higher precedence than : so ![X]:p(X) is :(![X],p(X))
+%----Otherwise ![X]:![Y]:p(X,Y) cannot be parsed.
+%----! is fy so Prolog can read !! (blah) as !(!(blah)) and it gets fixed
+:-op(400,fy,!).
+:-op(400,fx,?).
+:-op(400,fx,^).
+:-op(400,fx,'!>').
+:-op(400,fx,'?*').
+:-op(400,fx,'@-').
+:-op(400,fx,'@+').
+%----= must bind more tightly than : for ! [X] : a = X. = must binder looser
+%----than quantifiers for otherwise X = ! [Y] : ... is a syntax error (the =
+%----grabs the quantifier). That means for thf it is necessary to bracket 
+%----formula terms, e.g., a = (! [X] : p(X))
 :-op(405,xfx,'=').
 %---!= not possible because ! is special - see postfix cheat :-op(405,xfx,'!=').
-:-op(410,fy,~).
+:-op(440,xfy,>).     %----Type arrow
+:-op(450,xfx,'<<').     %----Subtype arrow
+%----Need : stronger than binary connectives for ! [X] : p(X) <=> !Y ...
+%----Need ~ and : equal and right-assoc for ![X] : ~p and for ~![X] : ...
+:-op(450,xfy,:).
+:-op(450,fx,:=).
+:-op(450,fx,'!!').
+:-op(450,fx,'??').
+:-op(450,fy,~).
+:-op(480,yfx,*).     %----X product
+:-op(480,yfx,+).     %----Union
 :-op(501,yfx,@).
 :-op(502,xfy,'|').
-:-op(502,xfy,'~|').
+%FOR SWI 5.10.2 :-(system_mode(true),op(502,xfy,'|'),system_mode(false)).
+:-op(502,xfx,'~|').
 :-op(503,xfy,&).
-:-op(503,xfy,~&).
-:-op(504,xfy,=>).
-:-op(504,xfy,<=).
-:-op(505,xfy,<=>).
-:-op(505,xfy,<~>).
-%----! and ? are of higher precedence than : so !X:p(X) is :(!(X),p(X))
-%----Otherwise !X:!Y:p(X,Y) cannot be parsed.
-:-op(400,fx,!).
-:-op(400,fx,?).
-:-op(400,fx,^).
-%----Type arrow
-:-op(440,xfy,>).
-%----Need : weaker than ~ for !X : ~p. This means bracketing in ~ (! X ...)
-%----Need : stronger than binary connectives for !X : p(X) <=> !Y ...
-:-op(450,xfy,:).
-%---- .. used for range in tptp2X. Needs to be stronger than :
-:-op(400,xfx,'..').
+:-op(503,xfx,~&).
+:-op(504,xfx,=>).
+:-op(504,xfx,<=).
+:-op(505,xfx,<=>).
+:-op(505,xfx,<~>).
+:-op(510,xfx,-->).
+%----Must be weak to allow any formulae on RHS
+:-op(550,xfx,:=).
 %------------------------------------------------------------------------------
 %----Runtime version of operators
 declare_TPTP_operators:-
-    op(99,fx,'$'),
+    op(70,fx,'$$'),
+    op(80,fx,'$'),
+    op(90,xfx,/),
     op(100,fx,++),
     op(100,fx,--),
     op(100,xf,'!'),
-    op(405,xfx,'='),
-    op(405,xfx,'~='),
-    op(410,fy,~),
-    op(501,yfx,@),
-    op(502,xfy,'|'),
-    op(502,xfy,'~|'),
-    op(503,xfy,&),
-    op(503,xfy,~&),
-    op(504,xfy,=>),
-    op(504,xfy,<=),
-    op(505,xfy,<=>),
-    op(505,xfy,<~>),
-    op(400,fx,!),
+    op(400,xfx,'..'),
+    op(400,fy,!),
     op(400,fx,?),
     op(400,fx,^),
+    op(400,fx,'!>'),
+    op(400,fx,'?*'),
+    op(400,fx,'@-'),
+    op(400,fx,'@+'),
+    op(400,fx,:=),
+    op(405,xfx,'='),
     op(440,xfy,>),
+    op(450,xfx,'<<'),
     op(450,xfy,:),
-    op(400,xfx,'..').
-%------------------------------------------------------------------------------
-%----Load the configuration file
-:-compile('tptp2X.config').
+    op(450,fx,'!!'),
+    op(450,fx,'??'),
+    op(450,fy,~),
+    op(480,yfx,*),
+    op(480,yfx,+),
+    op(501,yfx,@),
+    op(502,xfy,'|'),
+%FOR SWI 5.10.2    (system_mode(true),op(502,xfy,'|'),system_mode(false)),
+    op(502,xfx,'~|'),
+    op(503,xfy,&),
+    op(503,xfx,~&),
+    op(504,xfx,=>),
+    op(504,xfx,<=),
+    op(505,xfx,<=>),
+    op(505,xfx,<~>),
+    op(510,xfx,-->),
+    op(550,xfx,:=).
 %------------------------------------------------------------------------------
 %----This specifies the transformations that will be loaded. Currently
 %----all are loaded, but you comment out any you don't want. 
 :-compile('transform.arrange').
 :-compile('transform.equality').
+:-compile('transform.expand').
 :-compile('transform.fofify').
 :-compile('transform.magic').
 :-compile('transform.reform').
-:-compile('transform.rfof').
 :-compile('transform.shorten').
+:-compile('transform.xdb').
 %------------------------------------------------------------------------------
 %----This specifies the output formats that will be loaded. Currently
 %----all are loaded, but you comment out any you don't want. Don't
@@ -94,46 +126,41 @@
 %----confuse tptp2X_install
 :-compile('format.bliksem').
 :-compile('format.carine').
-:-compile('format.code').
+% NO LONGER USED ['format.clif'].
+% NO LONGER USED ['format.code'].
 :-compile('format.dedam').
 :-compile('format.dimacs').
 :-compile('format.dfg').
 :-compile('format.eqp').
-:-compile('format.finder').
-:-compile('format.gandalf').
-:-compile('format.glides').
-:-compile('format.ilf').
-:-compile('format.kif').
-:-compile('format.tap').
+% NO LONGER USED ['format.finder'].
+:-compile('format.geo').
+% NO LONGER USED ['format.ilf'].
+:-compile('format.isabelle').
+% NO LONGER USED ['format.kif'].
+:-compile('format.leancop').
+:-compile('format.lf').
+% NO LONGER USED ['format.tap'].
 :-compile('format.leantap').
-:-compile('format.mace4').
-:-compile('format.math').
-:-compile('format.meteor').
-:-compile('format.mgtp').
-:-compile('format.omdoc').
-:-compile('format.oscar').
+:-compile('format.metitarski').
+% NO LONGER USED ['format.omdoc'].
+% NO LONGER USED ['format.oscar'].
 :-compile('format.otter').
 :-compile('format.protein').
 :-compile('format.prover9').
-:-compile('format.pttp').
-:-compile('format.satchmo').
-:-compile('format.scott').
-:-compile('format.sem').
+% NO LONGER USED ['format.pttp'].
+% NO LONGER USED ['format.satchmo'].
+% NO LONGER USED ['format.scott'].
+% NO LONGER USED ['format.sem'].
 :-compile('format.setheo').
-:-compile('format.sprfn').
-:-compile('format.thinker').
+% NO LONGER USED format.sex'].
+:-compile('format.smt').
+% NO LONGER USED ['format.sprfn'].
+% NO LONGER USED ['format.thinker'].
+:-compile('format.tps').
 :-compile('format.oldtptp').
 :-compile('format.tptp').
 :-compile('format.prefix').
 :-compile('format.waldmeister').
-:-compile('format.ft').
-:-compile('format.ftprolog').
-:-compile('format.intprop').
-:-compile('format.jprover').
-:-compile('format.leancop').
-:-compile('format.ljt').
-:-compile('format.pitp').
-:-compile('format.strip').
 %------------------------------------------------------------------------------
 %----Use the standard TPTP read code. 
 :-compile('tptp2X.read').
@@ -166,7 +193,7 @@
 %----Use consult for BinProlog, which has a different compiling attitude.
 tptp2X_load_one_file(TPTPFileName):-
     prolog_dialect(PrologDialect),
-    tptp2X_member(PrologDialect,[binprolog,gnuprolog,generic]),
+    tptp2X_member(PrologDialect,[binprolog,gnu,generic]),
     !,
     tptp_path_name(TPTPFileName,TPTPPathName),
     consult(TPTPPathName).
@@ -182,11 +209,6 @@
         tptp2X_load(FileToInclude)
     ;   true).
 %------------------------------------------------------------------------------
-%----Make a copy of something with new variables
-tptp2X_copy(Old,New):-
-    asserta(tptp2X_copy(Old)),
-    retract(tptp2X_copy(New)).
-%------------------------------------------------------------------------------
 %----Make a subset of a list
 tptp2X_subset([],[]).
 
@@ -254,6 +276,10 @@
     tptp2X_length(Tail,TailLength),
     Length is TailLength + 1.
 %------------------------------------------------------------------------------
+tptp2X_atom_length(Atom,AtomLength):-
+     name(Atom,AtomASCII),
+     tptp2X_length(AtomASCII,AtomLength).
+%------------------------------------------------------------------------------
 %----Setof1 does setof, but allows empty list to be returned
 tptp2X_setof1(Variable,Goal,List):-
     setof(Variable,Goal,List),
@@ -385,8 +411,8 @@
     Random is Lowest + (BigRandom mod (Highest - Lowest + 1)).
 
 %----SWI prolog
-tptp2X_random_integer_for_dialect(swiprolog,Lowest,Highest,Random):-
-    Range is Highest-Lowest + 1,
+tptp2X_random_integer_for_dialect(swi,Lowest,Highest,Random):-
+    Range is (Highest-Lowest) + 1,
     RandomInRange is random(Range),
     Random is Lowest + RandomInRange.
 
@@ -400,7 +426,7 @@
     random(Lowest,HighestPlus1,Random).
 
 %----GNU Prolog version.
-tptp2X_random_integer_for_dialect(gnuprolog,Lowest,Highest,Random):-
+tptp2X_random_integer_for_dialect(gnu,Lowest,Highest,Random):-
     HighestPlus1 is Highest + 1,
     random(Lowest,HighestPlus1,Random).
 
@@ -408,7 +434,7 @@
 tptp2X_random_integer_for_dialect(eclipse,Lowest,Highest,Random):-
 %----Integer in range 0 to (2^32 - 1)
     random(BigRandom),
-    Random is Lowest + (BigRandom mod (Highest - Lowest + 1)).
+    Random is Lowest + (BigRandom mod (1+ Highest - Lowest)).
 
 %----Quintus version - Integer in specified range
 tptp2X_random_integer_for_dialect(quintus,Lowest,Highest,Random):-
@@ -694,25 +720,65 @@
     InformationQuery =.. [InformationQueryPredicate,transform,AFormat,_],
     findall(AFormat,InformationQuery,ListOfFormats).
 %------------------------------------------------------------------------------
+%----If no comment atom then suppress
+output_comment_line(_,''):-
+    !.
+
+output_comment_line(Content,Start-End):-
+    !,
+    write(Start),
+    write(Content),
+    write(End),
+    nl.
+
+output_comment_line(Content,Start):-
+    write(Start),
+    write(Content),
+    nl.
+%------------------------------------------------------------------------------
+comment_atom_length(Start-End,Length):-
+    !,
+    tptp2X_atom_length(Start,StartLength),
+    tptp2X_atom_length(End,EndLength),
+    Length is StartLength + EndLength.
+
+comment_atom_length(Start,Length):-
+    tptp2X_atom_length(Start,Length).
+%------------------------------------------------------------------------------
+generate_separator_list(0,[]).
+
+generate_separator_list(Length,[45|RestOfSeparatorList]):-
+    Length > 0,
+    Length1 is Length - 1,
+    generate_separator_list(Length1,RestOfSeparatorList).
+%------------------------------------------------------------------------------
+generate_separator(Length,Separator):-
+    generate_separator_list(Length,SeparatorList),
+    name(Separator,SeparatorList).
+%------------------------------------------------------------------------------
 %----Write a comment line
 output_separator_line(CommentAtom):-
-    write(CommentAtom),
-    write('------------------------------------------------------------------------------'),
-    nl.
+    comment_atom_length(CommentAtom,CommentAtomLength),
+    SeparatorLength is 79 - CommentAtomLength,
+    generate_separator(SeparatorLength,Separator),
+    output_comment_line(Separator,CommentAtom).
 %------------------------------------------------------------------------------
 %----Output field lines one by one.
 output_field_lines([],_).
 
 output_field_lines([FirstLine|RestOfLines],CommentAtom):-
-    write(CommentAtom),
-    write(FirstLine),
-    nl,
+    output_comment_line(FirstLine,CommentAtom),
     output_field_lines(RestOfLines,CommentAtom).
 %------------------------------------------------------------------------------
 %----Output the file header using the given comment atom
 output_file_header([],_):-
     !.
 
+%----Suppress if no comment atom
+output_file_header([_|RestOfHeaderLines],''):-
+    !,
+    output_file_header(RestOfHeaderLines,'').
+
 %----No leading comment char for empty lines
 output_file_header(['Blank'-_|RestOfHeaderLines],CommentAtom):-
     !,
@@ -723,6 +789,15 @@
     output_field_lines(FieldLines,CommentAtom),
     output_file_header(RestOfHeaderLines,CommentAtom).
 %------------------------------------------------------------------------------
+%----If no header then nothing
+possibly_output_file_header([],_):-
+    !.
+
+%----If some header then header and separator line
+possibly_output_file_header(Header,CommentAtom):-
+    output_file_header(Header,CommentAtom),
+    output_separator_line(CommentAtom).
+%------------------------------------------------------------------------------
 %----Output each of the include directives
 output_each_include_directive([]).
 
@@ -798,29 +873,14 @@
 output_formulae_in_format([],[],[],_,_,_):-
     !.
 
-%----Strange case for schulz
-output_formulae_in_format(Header,[],OutputFormulae,schulz,schulz,_):-
-    !,
-    tptp2X_member('File'-[FileLine],Header),
-    name(FileLine,FileASCII),
-    tptp2X_append(" File     : ",Bit1,FileASCII),
-    tptp2X_append(NameASCII,[32,58,32|_],Bit1),
-    name(Name,NameASCII),
-    write(Name),
-    write(' : '),
-    output_formulae(OutputFormulae,Header,schulz,schulz).
-
-%%% no comments
 output_formulae_in_format(FileHeader,IncludeDirectives,OutputFormulae,
 OutputFormat,FormatName,CommentAtom):-
-%----Output the file header
-%    output_separator_line(CommentAtom),
-%    output_file_header(FileHeader,CommentAtom),
-%    output_separator_line(CommentAtom),
+    output_separator_line(CommentAtom),
+    possibly_output_file_header(FileHeader,CommentAtom),
     output_include_directives(IncludeDirectives,CommentAtom,FormatName),
     output_formulae(OutputFormulae,FileHeader,OutputFormat,FormatName),
 %----Put a comment line
-%    output_separator_line(CommentAtom),
+    output_separator_line(CommentAtom),
     !.
 
 %----Error case. Don't fail - the file still has to be closed.
@@ -833,6 +893,14 @@
     write(' format failed.'),
     nl.
 %------------------------------------------------------------------------------
+%----Reject variable formats
+output_formulae_in_format_to_file(_,_,_,Variable,_,_,_,_):-
+    var(Variable),
+    !,
+    write(
+'%----ERROR : The output format is invalid (it looks like a variable).'),nl,
+    fail.
+
 %----Allow multiple output formats (useful for the competition). Done
 %----by backtracking over formats specified.
 output_formulae_in_format_to_file(FileHeader,IncludeDirectives,
@@ -888,13 +956,13 @@
 tptp2X_delete_file_for_dialect(yap,FileName):-
     delete_file(FileName).
 
-tptp2X_delete_file_for_dialect(swiprolog,FileName):-
+tptp2X_delete_file_for_dialect(swi,FileName):-
     delete_file(FileName).
 
 tptp2X_delete_file_for_dialect(quintus,FileName):-
     delete_file(FileName).
 
-tptp2X_delete_file_for_dialect(gnuprolog,FileName):-
+tptp2X_delete_file_for_dialect(gnu,FileName):-
     delete_file(FileName).
 
 tptp2X_delete_file_for_dialect(sicstus,FileName):-
@@ -937,6 +1005,14 @@
 %----Delete the temporary file
     tptp2X_delete_file(OutputFileName).
 %------------------------------------------------------------------------------
+%----Reject variable transformations
+transform_formulae(_,_,_,_,Variable,_,_,_,_,_):-
+    var(Variable),
+    !,
+    write(
+'%----ERROR : The transformation is invalid (it looks like a variable).'),nl,
+    fail.
+
 %----If a list of transformations, then do each one. Use member due
 %----to backtracking approach
 transform_formulae(FileHeader,InputFormulae,InputName,Dictionary,
@@ -954,14 +1030,41 @@
 OutputFormulae,OutputName,NewDictionary,
 FirstTransformationDone+RestOfTransformationsDone):-
     !,
+%DEBUG write('DO TRANFORM '),write(FirstTransformation),nl,
+%DEBUG write('InputFormulae'),nl,write(InputFormulae),nl,
+%DEBUG write('Dictionary'),nl,write(Dictionary),nl,
     transform_formulae(FileHeader,InputFormulae,InputName,Dictionary,
 FirstTransformation,IntermediateFileHeader,IntermediateFormulae,
 IntermediateName,IntermediateDictionary,FirstTransformationDone),
+%DEBUG write('DONE TRANFORM '),write(FirstTransformation),nl,
+%DEBUG write('IntermediateFormulae'),nl,write(IntermediateFormulae),nl,
+%DEBUG write('IntermediateDictionary'),nl,write(IntermediateDictionary),nl,
     transform_formulae(IntermediateFileHeader,IntermediateFormulae,
 IntermediateName,IntermediateDictionary,RestOfTransformations,
 TransformedFileHeader,OutputFormulae,OutputName,NewDictionary,
 RestOfTransformationsDone).
 
+%----The syntax transformation is internal, to force recomputing syntax
+transform_formulae(FileHeader,Formulae,Name,Dictionary,syntax,FileHeader,
+Formulae,Name,Dictionary,syntax):-
+    !.
+
+%----If a backtrackable transformation, then do them
+transform_formulae(FileHeader,InputFormulae,InputName,Dictionary,
+Transformation,FileHeader,OutputFormulae,OutputName,NewDictionary,
+TransformationAtom):-
+    tptp2X_member(Transformation,[expand:conjectures]),
+    !,
+%----Extract the main name of the transformation
+    get_format_or_transform_name(Transformation,TransformationName,
+TransformationAtom),
+%----Make the transformation query
+    TransformationQuery =.. [TransformationName,InputFormulae,Dictionary,
+Transformation,OutputFormulae,NewDictionary,FileNameSuffix],
+%----Do the transformation
+    TransformationQuery,
+    concatenate_atoms([InputName,FileNameSuffix],OutputName).
+
 %----If a single transformation, then do it
 transform_formulae(FileHeader,InputFormulae,InputName,Dictionary,
 Transformation,FileHeader,OutputFormulae,OutputName,NewDictionary,
@@ -1000,9 +1103,8 @@
 %----CNF case
 make_syntax_header_field(SyntaxReplacements,[ClausesLine,LiteralsLine,
 ClauseSizeLine,PredicateLine,FunctionLine,VariablesLine,TermDepthLine]):-
-%----Make clauses line. Leave the CommentAtom off the front as that is
-%----added on output.
-    tptp2X_member('CLSS'-Clauses,SyntaxReplacements),
+    tptp2X_member('CNFF'-Clauses,SyntaxReplacements),
+    !,
     tptp2X_member('NNHN'-NonHornClauses,SyntaxReplacements),
     tptp2X_member('UNIT'-UnitClauses,SyntaxReplacements),
     tptp2X_member('RARE'-RangeRestrictedClauses,SyntaxReplacements),
@@ -1039,7 +1141,7 @@
     tptp2X_member('VARS'-Variables,SyntaxReplacements),
     tptp2X_member('SGTN'-Singletons,SyntaxReplacements),
     concatenate_atoms(['            Number of variables  : ',
-Variables,' (',Singletons,' singleton)'],VariablesLine),
+Variables,' (',Singletons,' sgn)'],VariablesLine),
 %----Make term depth line
     tptp2X_member('TMDP'-MaximalTermDepth,SyntaxReplacements),
     tptp2X_member('TMAD'-AverageTermDepth,SyntaxReplacements),
@@ -1052,7 +1154,8 @@
 PredicateLine,FunctionLine,VariablesLine,TermDepthLine]):-
 %----Make formulae line. Leave the CommentAtom off the front as that is
 %----added on output.
-    tptp2X_member('FORM'-NumberOfFormulae,SyntaxReplacements),
+    tptp2X_member('FOFF'-NumberOfFormulae,SyntaxReplacements),
+    !,
     tptp2X_member('UNIT'-NumberOfUnitFormulae,SyntaxReplacements),
     concatenate_atoms([' Syntax   : Number of formulae    : ',
 NumberOfFormulae,' (',NumberOfUnitFormulae,' unit)'],FormulaeLine),
@@ -1072,22 +1175,21 @@
     tptp2X_member('ORSS'-NumberOfORs,SyntaxReplacements),
     tptp2X_member('ANDS'-NumberOfANDs,SyntaxReplacements),
     concatenate_atoms(['            Number of connectives : ',
-NumberOfConnectives,' (',NumberOfNOTs,' ~  ;',NumberOfORs,'  |;',
-NumberOfANDs,'  &)'],ConnectivesLine1),
+NumberOfConnectives,' (',NumberOfNOTs,'   ~;',NumberOfORs,'   |;',
+NumberOfANDs,'   &)'],ConnectivesLine1),
 %----2nd connectives line
     tptp2X_member('EQVS'-NumberOfEQUIVs,SyntaxReplacements),
     tptp2X_member('IMPS'-NumberOfIMPLYs,SyntaxReplacements),
     tptp2X_member('PMIS'-NumberOfIMPLIEDs,SyntaxReplacements),
+    tptp2X_member('XORS'-NumberOfXORs,SyntaxReplacements),
     concatenate_atoms(['                                         (',
-NumberOfEQUIVs,' <=>;',NumberOfIMPLYs,' =>;',NumberOfIMPLIEDs,' <=)'],
-ConnectivesLine2),
+NumberOfEQUIVs,' <=>;',NumberOfIMPLYs,'  =>;',NumberOfIMPLIEDs,'  <=;',
+NumberOfXORs,' <~>)'],ConnectivesLine2),
 %----3rd connectives line
-    tptp2X_member('XORS'-NumberOfXORs,SyntaxReplacements),
     tptp2X_member('NORS'-NumberOfNORs,SyntaxReplacements),
     tptp2X_member('NANS'-NumberOfNANDs,SyntaxReplacements),
     concatenate_atoms(['                                         (',
-NumberOfXORs,' <~>;',NumberOfNORs,' ~|;',NumberOfNANDs,' ~&)'],
-ConnectivesLine3),
+NumberOfNORs,'  ~|;',NumberOfNANDs,'  ~&)'],ConnectivesLine3),
 %----Predicates line
     tptp2X_member('PRED'-NumberOfPredicateSymbols,SyntaxReplacements),
     tptp2X_member('PROP'-NumberOfPropositions,SyntaxReplacements),
@@ -1110,13 +1212,201 @@
     tptp2X_member('UNIV'-NumberOfUniversals,SyntaxReplacements),
     tptp2X_member('EXIS'-NumberOfExistentials,SyntaxReplacements),
     concatenate_atoms(['            Number of variables   : ',
-NumberOfVariables,' (',NumberOfSingletons,' singleton;',NumberOfUniversals,
-' !;',NumberOfExistentials,' ?)'],VariablesLine),
+NumberOfVariables,' (',NumberOfSingletons,' sgn;',NumberOfUniversals,
+'   !;',NumberOfExistentials,'   ?)'],VariablesLine),
 %----Term depth line
     tptp2X_member('TMDP'-MaximalTermDepth,SyntaxReplacements),
     tptp2X_member('TMAD'-AverageTermDepth,SyntaxReplacements),
     concatenate_atoms(['            Maximal term depth    : ',
 MaximalTermDepth,' (',AverageTermDepth,' average)'],TermDepthLine).
+
+%----TFF case
+make_syntax_header_field(SyntaxReplacements,[FormulaeLine,AtomsLine,
+FormulaDepthLine,ConnectivesLine1,ConnectivesLine2,ConnectivesLine3,
+TypeConnectivesLine,PredicateLine,FunctionLine,VariablesLine,TermDepthLine|
+ArithmeticList]):-
+%----Make formulae line. Leave the CommentAtom off the front as that is
+%----added on output.
+    tptp2X_member('TFFF'-NumberOfFormulae,SyntaxReplacements),
+    !,
+    tptp2X_member('UNIT'-NumberOfUnitFormulae,SyntaxReplacements),
+    tptp2X_member('TFRM'-NumberOfTypeDecs,SyntaxReplacements),
+    concatenate_atoms([' Syntax   : Number of formulae    : ',
+NumberOfFormulae,' (',NumberOfUnitFormulae,' unit;',NumberOfTypeDecs,' type)'],
+FormulaeLine),
+%----Atoms line
+    tptp2X_member('ATOM'-NumberOfAtoms,SyntaxReplacements),
+    tptp2X_member('EQAT'-NumberOfEqualityAtoms,SyntaxReplacements),
+    concatenate_atoms(['            Number of atoms       : ',
+NumberOfAtoms,' (',NumberOfEqualityAtoms,' equality)'],AtomsLine),
+%----Formula depth line
+    tptp2X_member('FMDP'-MaximalFormulaDepth,SyntaxReplacements),
+    tptp2X_member('FMAD'-AverageFormulaDepth,SyntaxReplacements),
+    concatenate_atoms(['            Maximal formula depth : ',
+MaximalFormulaDepth,' (',AverageFormulaDepth,' average)'],FormulaDepthLine),
+%----1st connectives line
+    tptp2X_member('CONN'-NumberOfConnectives,SyntaxReplacements),
+    tptp2X_member('NOTS'-NumberOfNOTs,SyntaxReplacements),
+    tptp2X_member('ORSS'-NumberOfORs,SyntaxReplacements),
+    tptp2X_member('ANDS'-NumberOfANDs,SyntaxReplacements),
+    concatenate_atoms(['            Number of connectives : ',
+NumberOfConnectives,' (',NumberOfNOTs,'   ~;',NumberOfORs,'   |;',
+NumberOfANDs,'   &)'],ConnectivesLine1),
+%----2nd connectives line
+    tptp2X_member('EQVS'-NumberOfEQUIVs,SyntaxReplacements),
+    tptp2X_member('IMPS'-NumberOfIMPLYs,SyntaxReplacements),
+    tptp2X_member('PMIS'-NumberOfIMPLIEDs,SyntaxReplacements),
+    tptp2X_member('XORS'-NumberOfXORs,SyntaxReplacements),
+    concatenate_atoms(['                                         (',
+NumberOfEQUIVs,' <=>;',NumberOfIMPLYs,'  =>;',NumberOfIMPLIEDs,'  <=;',
+NumberOfXORs,' <~>)'],ConnectivesLine2),
+%----3rd connectives line
+    tptp2X_member('NORS'-NumberOfNORs,SyntaxReplacements),
+    tptp2X_member('NANS'-NumberOfNANDs,SyntaxReplacements),
+    concatenate_atoms(['                                         (',
+NumberOfNORs,'  ~|;',NumberOfNANDs,'  ~&)'],ConnectivesLine3),
+%----Type connectives line
+    tptp2X_member('TCON'-NumberOfTypeConnectives,SyntaxReplacements),
+    tptp2X_member('MAPS'-NumberOfMaps,SyntaxReplacements),
+    tptp2X_member('XPRO'-NumberOfXProds,SyntaxReplacements),
+    tptp2X_member('UNIO'-NumberOfUnions,SyntaxReplacements),
+    tptp2X_member('SUBT'-NumberOfSubtypes,SyntaxReplacements),
+    concatenate_atoms(['            Number of type conns  : ',
+NumberOfTypeConnectives,' (',NumberOfMaps,'   >;',NumberOfXProds,'   *;',
+NumberOfUnions,'   +;',NumberOfSubtypes,'  <<)'],TypeConnectivesLine),
+%----Predicates line
+    tptp2X_member('PRED'-NumberOfPredicateSymbols,SyntaxReplacements),
+    tptp2X_member('PROP'-NumberOfPropositions,SyntaxReplacements),
+    tptp2X_member('MINP'-MinimalPredicateArity,SyntaxReplacements),
+    tptp2X_member('MAXP'-MaximalPredicateArity,SyntaxReplacements),
+    concatenate_atoms(['            Number of predicates  : ',
+NumberOfPredicateSymbols,' (',NumberOfPropositions,' propositional; ',
+MinimalPredicateArity,'-',MaximalPredicateArity,' arity)'],PredicateLine),
+%----Functors line
+    tptp2X_member('FUNC'-NumberOfFunctors,SyntaxReplacements),
+    tptp2X_member('CNST'-NumberOfConstants,SyntaxReplacements),
+    tptp2X_member('MINF'-MinimalFunctorArity,SyntaxReplacements),
+    tptp2X_member('MAXF'-MaximalFunctorArity,SyntaxReplacements),
+    concatenate_atoms(['            Number of functors    : ',
+NumberOfFunctors,' (',NumberOfConstants,' constant; ',MinimalFunctorArity,
+'-',MaximalFunctorArity,' arity)'],FunctionLine),
+%----Variables line
+    tptp2X_member('VARS'-NumberOfVariables,SyntaxReplacements),
+    tptp2X_member('SGTN'-NumberOfSingletons,SyntaxReplacements),
+    tptp2X_member('UNIV'-NumberOfUniversals,SyntaxReplacements),
+    tptp2X_member('EXIS'-NumberOfExistentials,SyntaxReplacements),
+    concatenate_atoms(['            Number of variables   : ',
+NumberOfVariables,' (',NumberOfSingletons,' sgn;',NumberOfUniversals,
+'   !;',NumberOfExistentials,'   ?)'],VariablesLine),
+%----Term depth line
+    tptp2X_member('TMDP'-MaximalTermDepth,SyntaxReplacements),
+    tptp2X_member('TMAD'-AverageTermDepth,SyntaxReplacements),
+    concatenate_atoms(['            Maximal term depth    : ',
+MaximalTermDepth,' (',AverageTermDepth,' average)'],TermDepthLine),
+    tptp2X_member('MATT'-NumberOfArithmeticSymbols,SyntaxReplacements),
+    (   NumberOfArithmeticSymbols == '   0'
+   ->   ArithmeticList = []
+    ;   (   tptp2X_member('MATP'-NumberOfMathPredicates,SyntaxReplacements),
+            tptp2X_member('MATF'-NumberOfMathFunctions,SyntaxReplacements),
+            tptp2X_member('MATN'-NumberOfNumbers,SyntaxReplacements),
+            concatenate_atoms(['            Arithmetic symbols    : ',
+NumberOfArithmeticSymbols,' (',NumberOfMathPredicates,' pred;',
+NumberOfMathFunctions,' func;',NumberOfNumbers,' numbers)'],
+ArithmeticLine),
+            ArithmeticList = [ArithmeticLine]
+        )
+    ).
+
+%----THF case
+make_syntax_header_field(SyntaxReplacements,[FormulaeLine,AtomsLine,
+FormulaDepthLine,ConnectivesLine1,ConnectivesLine2,ConnectivesLine3,
+TypeConnectivesLine,SymbolsLine,VariablesLine1,VariablesLine2]):-
+%----Make formulae line. Leave the CommentAtom off the front as that is
+%----added on output.
+    tptp2X_member('THFF'-NumberOfFormulae,SyntaxReplacements),
+    !,
+    tptp2X_member('UNIT'-NumberOfUnitFormulae,SyntaxReplacements),
+    tptp2X_member('TFRM'-NumberOfTypeFormulae,SyntaxReplacements),
+    tptp2X_member('DFRM'-NumberOfDefnFormulae,SyntaxReplacements),
+    concatenate_atoms([' Syntax   : Number of formulae    : ',
+NumberOfFormulae,' (',NumberOfUnitFormulae,' unit;',NumberOfTypeFormulae,
+' type;',NumberOfDefnFormulae,' defn)'],FormulaeLine),
+%----Atoms line
+    tptp2X_member('ATOM'-NumberOfAtoms,SyntaxReplacements),
+    tptp2X_member('EQAT'-NumberOfEqualityAtoms,SyntaxReplacements),
+    tptp2X_member('VAAT'-NumberOfVariableAtoms,SyntaxReplacements),
+    concatenate_atoms(['            Number of atoms       : ',
+NumberOfAtoms,' (',NumberOfEqualityAtoms,' equality;',NumberOfVariableAtoms,
+' variable)'],AtomsLine),
+%----Formula depth line
+    tptp2X_member('FMDP'-MaximalFormulaDepth,SyntaxReplacements),
+    tptp2X_member('FMAD'-AverageFormulaDepth,SyntaxReplacements),
+    concatenate_atoms(['            Maximal formula depth : ',
+MaximalFormulaDepth,' (',AverageFormulaDepth,' average)'],FormulaDepthLine),
+%----1st connectives line
+    tptp2X_member('CONN'-NumberOfConnectives,SyntaxReplacements),
+    tptp2X_member('NOTS'-NumberOfNOTs,SyntaxReplacements),
+    tptp2X_member('ORSS'-NumberOfORs,SyntaxReplacements),
+    tptp2X_member('ANDS'-NumberOfANDs,SyntaxReplacements),
+    tptp2X_member('APPY'-NumberOfAPPLYs,SyntaxReplacements),
+    concatenate_atoms(['            Number of connectives : ',
+NumberOfConnectives,' (',NumberOfNOTs,'   ~;',NumberOfORs,'   |;',
+NumberOfANDs,'   &;',NumberOfAPPLYs,'   @)'],ConnectivesLine1),
+%----2nd connectives line
+    tptp2X_member('EQVS'-NumberOfEQUIVs,SyntaxReplacements),
+    tptp2X_member('IMPS'-NumberOfIMPLYs,SyntaxReplacements),
+    tptp2X_member('PMIS'-NumberOfIMPLIEDs,SyntaxReplacements),
+    tptp2X_member('XORS'-NumberOfXORs,SyntaxReplacements),
+    concatenate_atoms(['                                         (',
+NumberOfEQUIVs,' <=>;',NumberOfIMPLYs,'  =>;',NumberOfIMPLIEDs,'  <=;',
+NumberOfXORs,' <~>)'],ConnectivesLine2),
+%----3rd connectives line
+    tptp2X_member('NORS'-NumberOfNORs,SyntaxReplacements),
+    tptp2X_member('NANS'-NumberOfNANDs,SyntaxReplacements),
+    tptp2X_member('PIPI'-NumberOfPis,SyntaxReplacements),
+    tptp2X_member('SIGM'-NumberOfSigmas,SyntaxReplacements),
+    concatenate_atoms(['                                         (',
+NumberOfNORs,'  ~|;',NumberOfNANDs,'  ~&;',NumberOfPis,'  !!;',
+NumberOfSigmas,'  ??)'],ConnectivesLine3),
+%----Type connectives line
+    tptp2X_member('TCON'-NumberOfTypeConnectives,SyntaxReplacements),
+    tptp2X_member('MAPS'-NumberOfMaps,SyntaxReplacements),
+    tptp2X_member('XPRO'-NumberOfXProds,SyntaxReplacements),
+    tptp2X_member('UNIO'-NumberOfUnions,SyntaxReplacements),
+    tptp2X_member('SUBT'-NumberOfSubtypes,SyntaxReplacements),
+    concatenate_atoms(['            Number of type conns  : ',
+NumberOfTypeConnectives,' (',NumberOfMaps,'   >;',NumberOfXProds,'   *;',
+NumberOfUnions,'   +;',NumberOfSubtypes,'  <<)'],TypeConnectivesLine),
+%----Symbols line
+    tptp2X_member('FUNC'-NumberOfSymbols,SyntaxReplacements),
+    tptp2X_member('GTYP'-NumberOfGlobalTypeDecs,SyntaxReplacements),
+%NOT USED    tptp2X_member('GDEF'-NumberOfGlobalDefns,SyntaxReplacements),
+    concatenate_atoms(['            Number of symbols     : ',
+NumberOfSymbols,' (',NumberOfGlobalTypeDecs,'   :)'],SymbolsLine),
+%NOT USED (printing definitions) ;',NumberOfGlobalDefns,'  :=)'],SymbolsLine),
+%NOT USED tptp2X_member('CNST'-NumberOfConstants,SyntaxReplacements),
+%NOT USED tptp2X_member('MINF'-MinimalSymbolArity,SyntaxReplacements),
+%NOT USED tptp2X_member('MAXF'-MaximalSymbolArity,SyntaxReplacements),
+%NOT USED ,' (',NumberOfConstants,' constant; ',MinimalSymbolArity,
+%NOT USED '-',MaximalSymbolArity,' arity)'],SymbolsLine),
+%----1st variables line
+    tptp2X_member('VARS'-NumberOfVariables,SyntaxReplacements),
+    tptp2X_member('SGTN'-NumberOfSingletons,SyntaxReplacements),
+    tptp2X_member('UNIV'-NumberOfUniversals,SyntaxReplacements),
+    tptp2X_member('EXIS'-NumberOfExistentials,SyntaxReplacements),
+    tptp2X_member('LMDA'-NumberOfLambdas,SyntaxReplacements),
+    concatenate_atoms(['            Number of variables   : ',
+NumberOfVariables,' (',NumberOfSingletons,' sgn;',NumberOfUniversals,
+'   !;',NumberOfExistentials,'   ?;',NumberOfLambdas,'   ^)'],VariablesLine1),
+%----2nd variables line
+    tptp2X_member('TYPE'-NumberOfTypeDecs,SyntaxReplacements),
+%NOT USED    tptp2X_member('DEFN'-NumberOfDefns,SyntaxReplacements),
+    tptp2X_member('BIPI'-NumberOfPIs,SyntaxReplacements),
+    tptp2X_member('BISI'-NumberOfSIGMAs,SyntaxReplacements),
+    concatenate_atoms(['                                         (',
+NumberOfTypeDecs,'   :;',
+%NOT USED (printing definitions) NumberOfDefns,'  :=;',
+NumberOfPIs,'  !>;',NumberOfSIGMAs,'  ?*)'],VariablesLine2).
 %------------------------------------------------------------------------------
 %----Put leading blanks to get an atom in a field of 4
 integer_to_4_digit_atom(Number,Atom):-
@@ -1167,7 +1457,7 @@
 UpdatedFileHeader).
 
 %----Default, do nothing
-update_syntax_field(_,_Formulae,FileHeader,FileHeader).
+update_syntax_field(_,_,FileHeader,FileHeader).
 %------------------------------------------------------------------------------
 %----Extract the base name and type, one of clauses or generator
 base_filename_and_type(TPTPFileName,BaseInputName,_FormulaFormat,
@@ -1191,67 +1481,15 @@
     nl,
     fail.
 %------------------------------------------------------------------------------
-extract_conjecture_dictionary_pairs([],[],[],[],[]).
-
-extract_conjecture_dictionary_pairs([fof(Name,conjecture,LogicFormula)|
-RestOfRawFormulae],[ConjectureDictionary|RestOfRawDictionary],
-NonConjectureFormulae,NonConjectureDictionary,
-[fof(Name,conjecture,LogicFormula)-ConjectureDictionary|
-RestOfConjectureDictionaryPairs]):-
-    !,
-    extract_conjecture_dictionary_pairs(RestOfRawFormulae,RestOfRawDictionary,
-NonConjectureFormulae,NonConjectureDictionary,RestOfConjectureDictionaryPairs).
-
-extract_conjecture_dictionary_pairs([FirstFormula|RestOfRawFormulae],
-[FirstDictionary|RestOfRawDictionary],[FirstFormula|
-RestOfNonConjectureFormulae],[FirstDictionary|RestfNonConjectureDictionary],
-ConjectureDictionaryPairs):-
-    extract_conjecture_dictionary_pairs(RestOfRawFormulae,RestOfRawDictionary,
-RestOfNonConjectureFormulae,RestfNonConjectureDictionary,
-ConjectureDictionaryPairs).
-%------------------------------------------------------------------------------
-add_a_conjecture(NonConjectureFormulae,NonConjectureDictionary,
-[Conjecture-ConjectureDictionary|_],BaseInputName,Index,Formulae,Dictionary,
-UpdatedBaseInputName):-
-    tptp2X_append(NonConjectureFormulae,[Conjecture],Formulae),
-    tptp2X_append(NonConjectureDictionary,[ConjectureDictionary],Dictionary),
-    concatenate_atoms([BaseInputName,'_',Index],UpdatedBaseInputName).
-
-add_a_conjecture(NonConjectureFormulae,NonConjectureDictionary,
-[_|RestOfConjectureDictionaryPairs],BaseInputName,Index,Formulae,Dictionary,
-UpdatedBaseInputName):-
-    NextIndex is Index + 1,
-    add_a_conjecture(NonConjectureFormulae,NonConjectureDictionary,
-RestOfConjectureDictionaryPairs,BaseInputName,NextIndex,Formulae,Dictionary,
-UpdatedBaseInputName).
-%------------------------------------------------------------------------------
-expand_multiple_conjectures(RawFormulae,RawDictionary,BaseInputName,Formulae,
-Dictionary,UpdatedBaseInputName):-
-    tptp_formulae(RawFormulae),
-    tptp2X_select(fof(_,conjecture,_),RawFormulae,OtherRawFormulae),
-    tptp2X_member(fof(_,conjecture,_),OtherRawFormulae),
-    !,
-    extract_conjecture_dictionary_pairs(RawFormulae,RawDictionary,
-NonConjectureFormulae,NonConjectureDictionary,ConjectureDictionaryPairs),
-    add_a_conjecture(NonConjectureFormulae,NonConjectureDictionary,
-ConjectureDictionaryPairs,BaseInputName,1,Formulae,Dictionary,
-UpdatedBaseInputName).
-
-expand_multiple_conjectures(Formulae,Dictionary,BaseInputName,Formulae,
-Dictionary,BaseInputName).
-%------------------------------------------------------------------------------
 %----Get the clauses from file or by generation
 get_header_and_formulae(TPTPFileName,BaseInputName,FileHeader,Extension,_,
-UpdatedBaseInputName,CommentedFileHeader,Formulae,Dictionary):-
+BaseInputName,CommentedFileHeader,Formulae,Dictionary):-
 %----Check for problem and axiom files
     tptp2X_member(Extension,['.p','.ax','.eq']),
 %----Read in the formulae
-    read_formulae_from_file(TPTPFileName,RawFormulae,RawDictionary),
-%----Expand multiple FOF conjectures
-    expand_multiple_conjectures(RawFormulae,RawDictionary,BaseInputName,
-Formulae,Dictionary,UpdatedBaseInputName),
+    read_formulae_from_file(TPTPFileName,Formulae,Dictionary),
 %----Make indicator of source
-    concatenate_atoms([UpdatedBaseInputName,Extension],ReadingText),
+    concatenate_atoms([BaseInputName,Extension],ReadingText),
     add_tptp2X_comment(old,FileHeader,ReadingText,CommentedFileHeader).
 
 get_header_and_formulae(TPTPFileName,BaseInputName,RawFileHeader,'.g',
@@ -1278,23 +1516,25 @@
     numbervars(Formula,0,_),
     numbervars_each_formula(RestOfFormulae).
 %------------------------------------------------------------------------------
-%----Syntax needed for non-TPTP system recommendations
-has_changed_for_syntax(_,_,FileHeader,changed):-
-    tptp2X_member('Syntax'-[_],FileHeader),
+%----Check if the formulae have changed, in which case statistics are computed
+%----This one for dubugging - forces it to happen
+%DEBUG has_changed_for_syntax(_,_,_,_,changed):-!.
+
+%----Needed if specified as the transformation
+has_changed_for_syntax(_,_,syntax,_,changed):-
     !.
 
-%----Not needed if existing syntac field is unchanged
-has_changed_for_syntax(Formulae,OutputFormulae,_,unchanged):-
+%----Not needed if existing syntax field is unchanged
+has_changed_for_syntax(Formulae,OutputFormulae,_,_,unchanged):-
     Formulae == OutputFormulae,
     !.
 
-%----Can't recall why I had this, but now I need the syntax for system
-%----recommendations, so I've added that above
-has_changed_for_syntax(_,_,FileHeader,unchanged):-
+%----For problems that never had any syntax - do nothing
+has_changed_for_syntax(_,_,_,FileHeader,unchanged):-
     \+ tptp2X_member('Syntax'-_,FileHeader),
     !.
 
-has_changed_for_syntax(_,_,_,changed).
+has_changed_for_syntax(_,_,_,_,changed).
 %------------------------------------------------------------------------------
 %----Do this in all possible ways by backtracking
 make_all_outputs(TPTPFileName,BaseInputName,Extension,GenerationSpecification,
@@ -1312,11 +1552,13 @@
 Dictionary,Transformation,TransformedFileHeader,OutputFormulae,BaseOutputName,
 NewDictionary,TransformationDone),
 %----Add comment about transformations done if not none
-    (TransformationDone == none ->
-        TransformCommentedFileHeader = TransformedFileHeader;
-        (   concatenate_atoms(['-t ',TransformationDone],TransformationText),
+    (TransformationDone == none
+    ->  TransformCommentedFileHeader = TransformedFileHeader
+    ;   (   concatenate_atoms(['-t ',TransformationDone],TransformationText),
             add_tptp2X_comment(old,TransformedFileHeader,TransformationText,
-TransformCommentedFileHeader))),
+TransformCommentedFileHeader)
+        )
+    ),
 %----If shorten transformation, then clobber the header
     shorten_header(TransformationDone,TransformCommentedFileHeader,
 ShortenedFileHeader),
@@ -1328,8 +1570,8 @@
     instantiate_variables_from_dictionary(NewDictionary),
     numbervars_each_formula(OutputFormulae),
 %----Check if header needs syntax update (avoid where possible)
-    has_changed_for_syntax(Formulae,OutputFormulae,ShortenedFileHeader,
-ChangedOrNot),
+    has_changed_for_syntax(Formulae,OutputFormulae,TransformationDone,
+ShortenedFileHeader,ChangedOrNot),
 %----Update the Syntax field in the header for the new clauses
     update_syntax_field(ChangedOrNot,OutputFormulae,ShortenedFileHeader,
 SyntaxFileHeader),
@@ -1338,7 +1580,9 @@
 OutputFormat,BaseOutputName,OutputDirectory,_OutputFormatUsed,
 OutputFileName),
     (OutputDirectory \== user ->
-        (   write(BaseInputName),
+        (   write(TPTPFileName),
+%----Need the full name for SystemOnTPTP processing
+%----        (   write(BaseInputName),
             write(' -> '),
             write(OutputFileName),
             nl)
Only in 1/TPTP2X: tptp2X.main.no_comments
diff -ur 1/TPTP2X/tptp2X.main.uninstalled 2/TPTP2X/tptp2X.main.uninstalled
--- 1/TPTP2X/tptp2X.main.uninstalled	2007-03-01 12:01:53.000000000 -0500
+++ 2/TPTP2X/tptp2X.main.uninstalled	2013-03-10 18:37:17.948948000 -0400
@@ -14,79 +14,111 @@
 %----Extensions for FOF by Geoff Sutcliffe, October 1996.
 %==============================================================================
 %------------------------------------------------------------------------------
+%----Load the configuration file
+:-['tptp2X.config'].
+%------------------------------------------------------------------------------
 %----These are used in the TPTP and need to exist before the 
 %----transformations and formats are loaded. They are also declared at 
 %----runtime in tptp2X/4.
-%----$ binds more than -- to allow -- $(false)
-:-op(99,fx,'$').
+:-op(70,fx,'$$').
+:-op(80,fx,'$').
+:-op(90,xfx,/).     %----Rationals need to bind tighter than =
 :-op(100,fx,++).
 :-op(100,fx,--).
 %----Postfix for !=
 :-op(100,xf,'!').
-%----= must bind more tightly that quantifiers for ! [X] : a = X. That means
-%----for thof it is necessary to bracket formula terms, e.g., a = (! [X] : p(X))
+%---- .. used for range in tptp2X. Needs to be stronger than :
+:-op(400,xfx,'..').
+%----! and ? are of higher precedence than : so ![X]:p(X) is :(![X],p(X))
+%----Otherwise ![X]:![Y]:p(X,Y) cannot be parsed.
+%----! is fy so Prolog can read !! (blah) as !(!(blah)) and it gets fixed
+:-op(400,fy,!).
+:-op(400,fx,?).
+:-op(400,fx,^).
+:-op(400,fx,'!>').
+:-op(400,fx,'?*').
+:-op(400,fx,'@-').
+:-op(400,fx,'@+').
+%----= must bind more tightly than : for ! [X] : a = X. = must binder looser
+%----than quantifiers for otherwise X = ! [Y] : ... is a syntax error (the =
+%----grabs the quantifier). That means for thf it is necessary to bracket 
+%----formula terms, e.g., a = (! [X] : p(X))
 :-op(405,xfx,'=').
 %---!= not possible because ! is special - see postfix cheat :-op(405,xfx,'!=').
-:-op(410,fy,~).
+:-op(440,xfy,>).     %----Type arrow
+:-op(450,xfx,'<<').     %----Subtype arrow
+%----Need : stronger than binary connectives for ! [X] : p(X) <=> !Y ...
+%----Need ~ and : equal and right-assoc for ![X] : ~p and for ~![X] : ...
+:-op(450,xfy,:).
+:-op(450,fx,:=).
+:-op(450,fx,'!!').
+:-op(450,fx,'??').
+:-op(450,fy,~).
+:-op(480,yfx,*).     %----X product
+:-op(480,yfx,+).     %----Union
 :-op(501,yfx,@).
 :-op(502,xfy,'|').
-:-op(502,xfy,'~|').
+%FOR SWI 5.10.2 :-(system_mode(true),op(502,xfy,'|'),system_mode(false)).
+:-op(502,xfx,'~|').
 :-op(503,xfy,&).
-:-op(503,xfy,~&).
-:-op(504,xfy,=>).
-:-op(504,xfy,<=).
-:-op(505,xfy,<=>).
-:-op(505,xfy,<~>).
-%----! and ? are of higher precedence than : so !X:p(X) is :(!(X),p(X))
-%----Otherwise !X:!Y:p(X,Y) cannot be parsed.
-:-op(400,fx,!).
-:-op(400,fx,?).
-:-op(400,fx,^).
-%----Type arrow
-:-op(440,xfy,>).
-%----Need : weaker than ~ for !X : ~p. This means bracketing in ~ (! X ...)
-%----Need : stronger than binary connectives for !X : p(X) <=> !Y ...
-:-op(450,xfy,:).
-%---- .. used for range in tptp2X. Needs to be stronger than :
-:-op(400,xfx,'..').
+:-op(503,xfx,~&).
+:-op(504,xfx,=>).
+:-op(504,xfx,<=).
+:-op(505,xfx,<=>).
+:-op(505,xfx,<~>).
+:-op(510,xfx,-->).
+%----Must be weak to allow any formulae on RHS
+:-op(550,xfx,:=).
 %------------------------------------------------------------------------------
 %----Runtime version of operators
 declare_TPTP_operators:-
-    op(99,fx,'$'),
+    op(70,fx,'$$'),
+    op(80,fx,'$'),
+    op(90,xfx,/),
     op(100,fx,++),
     op(100,fx,--),
     op(100,xf,'!'),
-    op(405,xfx,'='),
-    op(405,xfx,'~='),
-    op(410,fy,~),
-    op(501,yfx,@),
-    op(502,xfy,'|'),
-    op(502,xfy,'~|'),
-    op(503,xfy,&),
-    op(503,xfy,~&),
-    op(504,xfy,=>),
-    op(504,xfy,<=),
-    op(505,xfy,<=>),
-    op(505,xfy,<~>),
-    op(400,fx,!),
+    op(400,xfx,'..'),
+    op(400,fy,!),
     op(400,fx,?),
     op(400,fx,^),
+    op(400,fx,'!>'),
+    op(400,fx,'?*'),
+    op(400,fx,'@-'),
+    op(400,fx,'@+'),
+    op(400,fx,:=),
+    op(405,xfx,'='),
     op(440,xfy,>),
+    op(450,xfx,'<<'),
     op(450,xfy,:),
-    op(400,xfx,'..').
-%------------------------------------------------------------------------------
-%----Load the configuration file
-:-['tptp2X.config'].
+    op(450,fx,'!!'),
+    op(450,fx,'??'),
+    op(450,fy,~),
+    op(480,yfx,*),
+    op(480,yfx,+),
+    op(501,yfx,@),
+    op(502,xfy,'|'),
+%FOR SWI 5.10.2    (system_mode(true),op(502,xfy,'|'),system_mode(false)),
+    op(502,xfx,'~|'),
+    op(503,xfy,&),
+    op(503,xfx,~&),
+    op(504,xfx,=>),
+    op(504,xfx,<=),
+    op(505,xfx,<=>),
+    op(505,xfx,<~>),
+    op(510,xfx,-->),
+    op(550,xfx,:=).
 %------------------------------------------------------------------------------
 %----This specifies the transformations that will be loaded. Currently
 %----all are loaded, but you comment out any you don't want. 
 :-['transform.arrange'].
 :-['transform.equality'].
+:-['transform.expand'].
 :-['transform.fofify'].
 :-['transform.magic'].
 :-['transform.reform'].
-:-['transform.rfof'].
 :-['transform.shorten'].
+:-['transform.xdb'].
 %------------------------------------------------------------------------------
 %----This specifies the output formats that will be loaded. Currently
 %----all are loaded, but you comment out any you don't want. Don't
@@ -94,46 +126,42 @@
 %----confuse tptp2X_install
 %:-['format.bliksem'].
 %:-['format.carine'].
-%:-['format.code'].
+% NO LONGER USED ['format.clif'].
+% NO LONGER USED ['format.code'].
 %:-['format.dedam'].
 %:-['format.dimacs'].
 %:-['format.dfg'].
 %:-['format.eqp'].
-%:-['format.finder'].
-%:-['format.glides'].
-%:-['format.ilf'].
-%:-['format.kif'].
-%:-['format.tap'].
+% NO LONGER USED ['format.finder'].
+%:-['format.geo'].
+% NO LONGER USED ['format.ilf'].
+%:-['format.isabelle'].
+% NO LONGER USED ['format.kif'].
+%:-['format.leancop'].
+%:-['format.lf'].
+% NO LONGER USED ['format.tap'].
 %:-['format.leantap'].
-%:-['format.mace4'].
-%:-['format.math'].
-%:-['format.meteor'].
-%:-['format.mgtp'].
-%:-['format.omdoc'].
-%:-['format.oscar'].
+%:-['format.metitarski'].
+% NO LONGER USED ['format.omdoc'].
+% NO LONGER USED ['format.oscar'].
 %:-['format.otter'].
+%:-['format.imogen'].
 %:-['format.protein'].
 %:-['format.prover9'].
-%:-['format.pttp'].
-%:-['format.satchmo'].
-%:-['format.scott'].
-%:-['format.sem'].
+% NO LONGER USED ['format.pttp'].
+% NO LONGER USED ['format.satchmo'].
+% NO LONGER USED ['format.scott'].
+% NO LONGER USED ['format.sem'].
 %:-['format.setheo'].
-%:-['format.sprfn'].
-%:-['format.thinker'].
+% NO LONGER USED format.sex'].
+%:-['format.smt'].
+% NO LONGER USED ['format.sprfn'].
+% NO LONGER USED ['format.thinker'].
+%:-['format.tps'].
 %:-['format.oldtptp'].
 %:-['format.tptp'].
 %:-['format.prefix'].
 %:-['format.waldmeister'].
-%:-compile('format.ft').
-%:-compile('format.ftprolog').
-%:-compile('format.gandalf').
-%:-compile('format.intprop').
-%:-compile('format.jprover').
-%:-compile('format.leancop').
-%:-compile('format.ljt').
-%:-compile('format.pitp').
-%:-compile('format.strip').
 %------------------------------------------------------------------------------
 %----Use the standard TPTP read code. 
 :-['tptp2X.read'].
@@ -166,7 +194,7 @@
 %----Use consult for BinProlog, which has a different compiling attitude.
 tptp2X_load_one_file(TPTPFileName):-
     prolog_dialect(PrologDialect),
-    tptp2X_member(PrologDialect,[binprolog,gnuprolog,generic]),
+    tptp2X_member(PrologDialect,[binprolog,gnu,generic]),
     !,
     tptp_path_name(TPTPFileName,TPTPPathName),
     consult(TPTPPathName).
@@ -182,11 +210,6 @@
         tptp2X_load(FileToInclude)
     ;   true).
 %------------------------------------------------------------------------------
-%----Make a copy of something with new variables
-tptp2X_copy(Old,New):-
-    asserta(tptp2X_copy(Old)),
-    retract(tptp2X_copy(New)).
-%------------------------------------------------------------------------------
 %----Make a subset of a list
 tptp2X_subset([],[]).
 
@@ -254,6 +277,10 @@
     tptp2X_length(Tail,TailLength),
     Length is TailLength + 1.
 %------------------------------------------------------------------------------
+tptp2X_atom_length(Atom,AtomLength):-
+     name(Atom,AtomASCII),
+     tptp2X_length(AtomASCII,AtomLength).
+%------------------------------------------------------------------------------
 %----Setof1 does setof, but allows empty list to be returned
 tptp2X_setof1(Variable,Goal,List):-
     setof(Variable,Goal,List),
@@ -385,8 +412,8 @@
     Random is Lowest + (BigRandom mod (Highest - Lowest + 1)).
 
 %----SWI prolog
-tptp2X_random_integer_for_dialect(swiprolog,Lowest,Highest,Random):-
-    Range is Highest-Lowest + 1,
+tptp2X_random_integer_for_dialect(swi,Lowest,Highest,Random):-
+    Range is (Highest-Lowest) + 1,
     RandomInRange is random(Range),
     Random is Lowest + RandomInRange.
 
@@ -400,7 +427,7 @@
     random(Lowest,HighestPlus1,Random).
 
 %----GNU Prolog version.
-tptp2X_random_integer_for_dialect(gnuprolog,Lowest,Highest,Random):-
+tptp2X_random_integer_for_dialect(gnu,Lowest,Highest,Random):-
     HighestPlus1 is Highest + 1,
     random(Lowest,HighestPlus1,Random).
 
@@ -408,7 +435,7 @@
 tptp2X_random_integer_for_dialect(eclipse,Lowest,Highest,Random):-
 %----Integer in range 0 to (2^32 - 1)
     random(BigRandom),
-    Random is Lowest + (BigRandom mod (Highest - Lowest + 1)).
+    Random is Lowest + (BigRandom mod (1+ Highest - Lowest)).
 
 %----Quintus version - Integer in specified range
 tptp2X_random_integer_for_dialect(quintus,Lowest,Highest,Random):-
@@ -694,25 +721,65 @@
     InformationQuery =.. [InformationQueryPredicate,transform,AFormat,_],
     findall(AFormat,InformationQuery,ListOfFormats).
 %------------------------------------------------------------------------------
+%----If no comment atom then suppress
+output_comment_line(_,''):-
+    !.
+
+output_comment_line(Content,Start-End):-
+    !,
+    write(Start),
+    write(Content),
+    write(End),
+    nl.
+
+output_comment_line(Content,Start):-
+    write(Start),
+    write(Content),
+    nl.
+%------------------------------------------------------------------------------
+comment_atom_length(Start-End,Length):-
+    !,
+    tptp2X_atom_length(Start,StartLength),
+    tptp2X_atom_length(End,EndLength),
+    Length is StartLength + EndLength.
+
+comment_atom_length(Start,Length):-
+    tptp2X_atom_length(Start,Length).
+%------------------------------------------------------------------------------
+generate_separator_list(0,[]).
+
+generate_separator_list(Length,[45|RestOfSeparatorList]):-
+    Length > 0,
+    Length1 is Length - 1,
+    generate_separator_list(Length1,RestOfSeparatorList).
+%------------------------------------------------------------------------------
+generate_separator(Length,Separator):-
+    generate_separator_list(Length,SeparatorList),
+    name(Separator,SeparatorList).
+%------------------------------------------------------------------------------
 %----Write a comment line
 output_separator_line(CommentAtom):-
-    write(CommentAtom),
-    write('------------------------------------------------------------------------------'),
-    nl.
+    comment_atom_length(CommentAtom,CommentAtomLength),
+    SeparatorLength is 79 - CommentAtomLength,
+    generate_separator(SeparatorLength,Separator),
+    output_comment_line(Separator,CommentAtom).
 %------------------------------------------------------------------------------
 %----Output field lines one by one.
 output_field_lines([],_).
 
 output_field_lines([FirstLine|RestOfLines],CommentAtom):-
-    write(CommentAtom),
-    write(FirstLine),
-    nl,
+    output_comment_line(FirstLine,CommentAtom),
     output_field_lines(RestOfLines,CommentAtom).
 %------------------------------------------------------------------------------
 %----Output the file header using the given comment atom
 output_file_header([],_):-
     !.
 
+%----Suppress if no comment atom
+output_file_header([_|RestOfHeaderLines],''):-
+    !,
+    output_file_header(RestOfHeaderLines,'').
+
 %----No leading comment char for empty lines
 output_file_header(['Blank'-_|RestOfHeaderLines],CommentAtom):-
     !,
@@ -723,6 +790,15 @@
     output_field_lines(FieldLines,CommentAtom),
     output_file_header(RestOfHeaderLines,CommentAtom).
 %------------------------------------------------------------------------------
+%----If no header then nothing
+possibly_output_file_header([],_):-
+    !.
+
+%----If some header then header and separator line
+possibly_output_file_header(Header,CommentAtom):-
+    output_file_header(Header,CommentAtom),
+    output_separator_line(CommentAtom).
+%------------------------------------------------------------------------------
 %----Output each of the include directives
 output_each_include_directive([]).
 
@@ -798,24 +874,10 @@
 output_formulae_in_format([],[],[],_,_,_):-
     !.
 
-%----Strange case for schulz
-output_formulae_in_format(Header,[],OutputFormulae,schulz,schulz,_):-
-    !,
-    tptp2X_member('File'-[FileLine],Header),
-    name(FileLine,FileASCII),
-    tptp2X_append(" File     : ",Bit1,FileASCII),
-    tptp2X_append(NameASCII,[32,58,32|_],Bit1),
-    name(Name,NameASCII),
-    write(Name),
-    write(' : '),
-    output_formulae(OutputFormulae,Header,schulz,schulz).
-
 output_formulae_in_format(FileHeader,IncludeDirectives,OutputFormulae,
 OutputFormat,FormatName,CommentAtom):-
-%----Output the file header
-    output_separator_line(CommentAtom),
-    output_file_header(FileHeader,CommentAtom),
     output_separator_line(CommentAtom),
+    possibly_output_file_header(FileHeader,CommentAtom),
     output_include_directives(IncludeDirectives,CommentAtom,FormatName),
     output_formulae(OutputFormulae,FileHeader,OutputFormat,FormatName),
 %----Put a comment line
@@ -832,6 +894,14 @@
     write(' format failed.'),
     nl.
 %------------------------------------------------------------------------------
+%----Reject variable formats
+output_formulae_in_format_to_file(_,_,_,Variable,_,_,_,_):-
+    var(Variable),
+    !,
+    write(
+'%----ERROR : The output format is invalid (it looks like a variable).'),nl,
+    fail.
+
 %----Allow multiple output formats (useful for the competition). Done
 %----by backtracking over formats specified.
 output_formulae_in_format_to_file(FileHeader,IncludeDirectives,
@@ -887,13 +957,13 @@
 tptp2X_delete_file_for_dialect(yap,FileName):-
     delete_file(FileName).
 
-tptp2X_delete_file_for_dialect(swiprolog,FileName):-
+tptp2X_delete_file_for_dialect(swi,FileName):-
     delete_file(FileName).
 
 tptp2X_delete_file_for_dialect(quintus,FileName):-
     delete_file(FileName).
 
-tptp2X_delete_file_for_dialect(gnuprolog,FileName):-
+tptp2X_delete_file_for_dialect(gnu,FileName):-
     delete_file(FileName).
 
 tptp2X_delete_file_for_dialect(sicstus,FileName):-
@@ -936,6 +1006,14 @@
 %----Delete the temporary file
     tptp2X_delete_file(OutputFileName).
 %------------------------------------------------------------------------------
+%----Reject variable transformations
+transform_formulae(_,_,_,_,Variable,_,_,_,_,_):-
+    var(Variable),
+    !,
+    write(
+'%----ERROR : The transformation is invalid (it looks like a variable).'),nl,
+    fail.
+
 %----If a list of transformations, then do each one. Use member due
 %----to backtracking approach
 transform_formulae(FileHeader,InputFormulae,InputName,Dictionary,
@@ -953,14 +1031,41 @@
 OutputFormulae,OutputName,NewDictionary,
 FirstTransformationDone+RestOfTransformationsDone):-
     !,
+%DEBUG write('DO TRANFORM '),write(FirstTransformation),nl,
+%DEBUG write('InputFormulae'),nl,write(InputFormulae),nl,
+%DEBUG write('Dictionary'),nl,write(Dictionary),nl,
     transform_formulae(FileHeader,InputFormulae,InputName,Dictionary,
 FirstTransformation,IntermediateFileHeader,IntermediateFormulae,
 IntermediateName,IntermediateDictionary,FirstTransformationDone),
+%DEBUG write('DONE TRANFORM '),write(FirstTransformation),nl,
+%DEBUG write('IntermediateFormulae'),nl,write(IntermediateFormulae),nl,
+%DEBUG write('IntermediateDictionary'),nl,write(IntermediateDictionary),nl,
     transform_formulae(IntermediateFileHeader,IntermediateFormulae,
 IntermediateName,IntermediateDictionary,RestOfTransformations,
 TransformedFileHeader,OutputFormulae,OutputName,NewDictionary,
 RestOfTransformationsDone).
 
+%----The syntax transformation is internal, to force recomputing syntax
+transform_formulae(FileHeader,Formulae,Name,Dictionary,syntax,FileHeader,
+Formulae,Name,Dictionary,syntax):-
+    !.
+
+%----If a backtrackable transformation, then do them
+transform_formulae(FileHeader,InputFormulae,InputName,Dictionary,
+Transformation,FileHeader,OutputFormulae,OutputName,NewDictionary,
+TransformationAtom):-
+    tptp2X_member(Transformation,[expand:conjectures]),
+    !,
+%----Extract the main name of the transformation
+    get_format_or_transform_name(Transformation,TransformationName,
+TransformationAtom),
+%----Make the transformation query
+    TransformationQuery =.. [TransformationName,InputFormulae,Dictionary,
+Transformation,OutputFormulae,NewDictionary,FileNameSuffix],
+%----Do the transformation
+    TransformationQuery,
+    concatenate_atoms([InputName,FileNameSuffix],OutputName).
+
 %----If a single transformation, then do it
 transform_formulae(FileHeader,InputFormulae,InputName,Dictionary,
 Transformation,FileHeader,OutputFormulae,OutputName,NewDictionary,
@@ -999,9 +1104,8 @@
 %----CNF case
 make_syntax_header_field(SyntaxReplacements,[ClausesLine,LiteralsLine,
 ClauseSizeLine,PredicateLine,FunctionLine,VariablesLine,TermDepthLine]):-
-%----Make clauses line. Leave the CommentAtom off the front as that is
-%----added on output.
-    tptp2X_member('CLSS'-Clauses,SyntaxReplacements),
+    tptp2X_member('CNFF'-Clauses,SyntaxReplacements),
+    !,
     tptp2X_member('NNHN'-NonHornClauses,SyntaxReplacements),
     tptp2X_member('UNIT'-UnitClauses,SyntaxReplacements),
     tptp2X_member('RARE'-RangeRestrictedClauses,SyntaxReplacements),
@@ -1038,7 +1142,7 @@
     tptp2X_member('VARS'-Variables,SyntaxReplacements),
     tptp2X_member('SGTN'-Singletons,SyntaxReplacements),
     concatenate_atoms(['            Number of variables  : ',
-Variables,' (',Singletons,' singleton)'],VariablesLine),
+Variables,' (',Singletons,' sgn)'],VariablesLine),
 %----Make term depth line
     tptp2X_member('TMDP'-MaximalTermDepth,SyntaxReplacements),
     tptp2X_member('TMAD'-AverageTermDepth,SyntaxReplacements),
@@ -1051,7 +1155,8 @@
 PredicateLine,FunctionLine,VariablesLine,TermDepthLine]):-
 %----Make formulae line. Leave the CommentAtom off the front as that is
 %----added on output.
-    tptp2X_member('FORM'-NumberOfFormulae,SyntaxReplacements),
+    tptp2X_member('FOFF'-NumberOfFormulae,SyntaxReplacements),
+    !,
     tptp2X_member('UNIT'-NumberOfUnitFormulae,SyntaxReplacements),
     concatenate_atoms([' Syntax   : Number of formulae    : ',
 NumberOfFormulae,' (',NumberOfUnitFormulae,' unit)'],FormulaeLine),
@@ -1071,22 +1176,21 @@
     tptp2X_member('ORSS'-NumberOfORs,SyntaxReplacements),
     tptp2X_member('ANDS'-NumberOfANDs,SyntaxReplacements),
     concatenate_atoms(['            Number of connectives : ',
-NumberOfConnectives,' (',NumberOfNOTs,' ~  ;',NumberOfORs,'  |;',
-NumberOfANDs,'  &)'],ConnectivesLine1),
+NumberOfConnectives,' (',NumberOfNOTs,'   ~;',NumberOfORs,'   |;',
+NumberOfANDs,'   &)'],ConnectivesLine1),
 %----2nd connectives line
     tptp2X_member('EQVS'-NumberOfEQUIVs,SyntaxReplacements),
     tptp2X_member('IMPS'-NumberOfIMPLYs,SyntaxReplacements),
     tptp2X_member('PMIS'-NumberOfIMPLIEDs,SyntaxReplacements),
+    tptp2X_member('XORS'-NumberOfXORs,SyntaxReplacements),
     concatenate_atoms(['                                         (',
-NumberOfEQUIVs,' <=>;',NumberOfIMPLYs,' =>;',NumberOfIMPLIEDs,' <=)'],
-ConnectivesLine2),
+NumberOfEQUIVs,' <=>;',NumberOfIMPLYs,'  =>;',NumberOfIMPLIEDs,'  <=;',
+NumberOfXORs,' <~>)'],ConnectivesLine2),
 %----3rd connectives line
-    tptp2X_member('XORS'-NumberOfXORs,SyntaxReplacements),
     tptp2X_member('NORS'-NumberOfNORs,SyntaxReplacements),
     tptp2X_member('NANS'-NumberOfNANDs,SyntaxReplacements),
     concatenate_atoms(['                                         (',
-NumberOfXORs,' <~>;',NumberOfNORs,' ~|;',NumberOfNANDs,' ~&)'],
-ConnectivesLine3),
+NumberOfNORs,'  ~|;',NumberOfNANDs,'  ~&)'],ConnectivesLine3),
 %----Predicates line
     tptp2X_member('PRED'-NumberOfPredicateSymbols,SyntaxReplacements),
     tptp2X_member('PROP'-NumberOfPropositions,SyntaxReplacements),
@@ -1109,13 +1213,201 @@
     tptp2X_member('UNIV'-NumberOfUniversals,SyntaxReplacements),
     tptp2X_member('EXIS'-NumberOfExistentials,SyntaxReplacements),
     concatenate_atoms(['            Number of variables   : ',
-NumberOfVariables,' (',NumberOfSingletons,' singleton;',NumberOfUniversals,
-' !;',NumberOfExistentials,' ?)'],VariablesLine),
+NumberOfVariables,' (',NumberOfSingletons,' sgn;',NumberOfUniversals,
+'   !;',NumberOfExistentials,'   ?)'],VariablesLine),
 %----Term depth line
     tptp2X_member('TMDP'-MaximalTermDepth,SyntaxReplacements),
     tptp2X_member('TMAD'-AverageTermDepth,SyntaxReplacements),
     concatenate_atoms(['            Maximal term depth    : ',
 MaximalTermDepth,' (',AverageTermDepth,' average)'],TermDepthLine).
+
+%----TFF case
+make_syntax_header_field(SyntaxReplacements,[FormulaeLine,AtomsLine,
+FormulaDepthLine,ConnectivesLine1,ConnectivesLine2,ConnectivesLine3,
+TypeConnectivesLine,PredicateLine,FunctionLine,VariablesLine,TermDepthLine|
+ArithmeticList]):-
+%----Make formulae line. Leave the CommentAtom off the front as that is
+%----added on output.
+    tptp2X_member('TFFF'-NumberOfFormulae,SyntaxReplacements),
+    !,
+    tptp2X_member('UNIT'-NumberOfUnitFormulae,SyntaxReplacements),
+    tptp2X_member('TFRM'-NumberOfTypeDecs,SyntaxReplacements),
+    concatenate_atoms([' Syntax   : Number of formulae    : ',
+NumberOfFormulae,' (',NumberOfUnitFormulae,' unit;',NumberOfTypeDecs,' type)'],
+FormulaeLine),
+%----Atoms line
+    tptp2X_member('ATOM'-NumberOfAtoms,SyntaxReplacements),
+    tptp2X_member('EQAT'-NumberOfEqualityAtoms,SyntaxReplacements),
+    concatenate_atoms(['            Number of atoms       : ',
+NumberOfAtoms,' (',NumberOfEqualityAtoms,' equality)'],AtomsLine),
+%----Formula depth line
+    tptp2X_member('FMDP'-MaximalFormulaDepth,SyntaxReplacements),
+    tptp2X_member('FMAD'-AverageFormulaDepth,SyntaxReplacements),
+    concatenate_atoms(['            Maximal formula depth : ',
+MaximalFormulaDepth,' (',AverageFormulaDepth,' average)'],FormulaDepthLine),
+%----1st connectives line
+    tptp2X_member('CONN'-NumberOfConnectives,SyntaxReplacements),
+    tptp2X_member('NOTS'-NumberOfNOTs,SyntaxReplacements),
+    tptp2X_member('ORSS'-NumberOfORs,SyntaxReplacements),
+    tptp2X_member('ANDS'-NumberOfANDs,SyntaxReplacements),
+    concatenate_atoms(['            Number of connectives : ',
+NumberOfConnectives,' (',NumberOfNOTs,'   ~;',NumberOfORs,'   |;',
+NumberOfANDs,'   &)'],ConnectivesLine1),
+%----2nd connectives line
+    tptp2X_member('EQVS'-NumberOfEQUIVs,SyntaxReplacements),
+    tptp2X_member('IMPS'-NumberOfIMPLYs,SyntaxReplacements),
+    tptp2X_member('PMIS'-NumberOfIMPLIEDs,SyntaxReplacements),
+    tptp2X_member('XORS'-NumberOfXORs,SyntaxReplacements),
+    concatenate_atoms(['                                         (',
+NumberOfEQUIVs,' <=>;',NumberOfIMPLYs,'  =>;',NumberOfIMPLIEDs,'  <=;',
+NumberOfXORs,' <~>)'],ConnectivesLine2),
+%----3rd connectives line
+    tptp2X_member('NORS'-NumberOfNORs,SyntaxReplacements),
+    tptp2X_member('NANS'-NumberOfNANDs,SyntaxReplacements),
+    concatenate_atoms(['                                         (',
+NumberOfNORs,'  ~|;',NumberOfNANDs,'  ~&)'],ConnectivesLine3),
+%----Type connectives line
+    tptp2X_member('TCON'-NumberOfTypeConnectives,SyntaxReplacements),
+    tptp2X_member('MAPS'-NumberOfMaps,SyntaxReplacements),
+    tptp2X_member('XPRO'-NumberOfXProds,SyntaxReplacements),
+    tptp2X_member('UNIO'-NumberOfUnions,SyntaxReplacements),
+    tptp2X_member('SUBT'-NumberOfSubtypes,SyntaxReplacements),
+    concatenate_atoms(['            Number of type conns  : ',
+NumberOfTypeConnectives,' (',NumberOfMaps,'   >;',NumberOfXProds,'   *;',
+NumberOfUnions,'   +;',NumberOfSubtypes,'  <<)'],TypeConnectivesLine),
+%----Predicates line
+    tptp2X_member('PRED'-NumberOfPredicateSymbols,SyntaxReplacements),
+    tptp2X_member('PROP'-NumberOfPropositions,SyntaxReplacements),
+    tptp2X_member('MINP'-MinimalPredicateArity,SyntaxReplacements),
+    tptp2X_member('MAXP'-MaximalPredicateArity,SyntaxReplacements),
+    concatenate_atoms(['            Number of predicates  : ',
+NumberOfPredicateSymbols,' (',NumberOfPropositions,' propositional; ',
+MinimalPredicateArity,'-',MaximalPredicateArity,' arity)'],PredicateLine),
+%----Functors line
+    tptp2X_member('FUNC'-NumberOfFunctors,SyntaxReplacements),
+    tptp2X_member('CNST'-NumberOfConstants,SyntaxReplacements),
+    tptp2X_member('MINF'-MinimalFunctorArity,SyntaxReplacements),
+    tptp2X_member('MAXF'-MaximalFunctorArity,SyntaxReplacements),
+    concatenate_atoms(['            Number of functors    : ',
+NumberOfFunctors,' (',NumberOfConstants,' constant; ',MinimalFunctorArity,
+'-',MaximalFunctorArity,' arity)'],FunctionLine),
+%----Variables line
+    tptp2X_member('VARS'-NumberOfVariables,SyntaxReplacements),
+    tptp2X_member('SGTN'-NumberOfSingletons,SyntaxReplacements),
+    tptp2X_member('UNIV'-NumberOfUniversals,SyntaxReplacements),
+    tptp2X_member('EXIS'-NumberOfExistentials,SyntaxReplacements),
+    concatenate_atoms(['            Number of variables   : ',
+NumberOfVariables,' (',NumberOfSingletons,' sgn;',NumberOfUniversals,
+'   !;',NumberOfExistentials,'   ?)'],VariablesLine),
+%----Term depth line
+    tptp2X_member('TMDP'-MaximalTermDepth,SyntaxReplacements),
+    tptp2X_member('TMAD'-AverageTermDepth,SyntaxReplacements),
+    concatenate_atoms(['            Maximal term depth    : ',
+MaximalTermDepth,' (',AverageTermDepth,' average)'],TermDepthLine),
+    tptp2X_member('MATT'-NumberOfArithmeticSymbols,SyntaxReplacements),
+    (   NumberOfArithmeticSymbols == '   0'
+   ->   ArithmeticList = []
+    ;   (   tptp2X_member('MATP'-NumberOfMathPredicates,SyntaxReplacements),
+            tptp2X_member('MATF'-NumberOfMathFunctions,SyntaxReplacements),
+            tptp2X_member('MATN'-NumberOfNumbers,SyntaxReplacements),
+            concatenate_atoms(['            Arithmetic symbols    : ',
+NumberOfArithmeticSymbols,' (',NumberOfMathPredicates,' pred;',
+NumberOfMathFunctions,' func;',NumberOfNumbers,' numbers)'],
+ArithmeticLine),
+            ArithmeticList = [ArithmeticLine]
+        )
+    ).
+
+%----THF case
+make_syntax_header_field(SyntaxReplacements,[FormulaeLine,AtomsLine,
+FormulaDepthLine,ConnectivesLine1,ConnectivesLine2,ConnectivesLine3,
+TypeConnectivesLine,SymbolsLine,VariablesLine1,VariablesLine2]):-
+%----Make formulae line. Leave the CommentAtom off the front as that is
+%----added on output.
+    tptp2X_member('THFF'-NumberOfFormulae,SyntaxReplacements),
+    !,
+    tptp2X_member('UNIT'-NumberOfUnitFormulae,SyntaxReplacements),
+    tptp2X_member('TFRM'-NumberOfTypeFormulae,SyntaxReplacements),
+    tptp2X_member('DFRM'-NumberOfDefnFormulae,SyntaxReplacements),
+    concatenate_atoms([' Syntax   : Number of formulae    : ',
+NumberOfFormulae,' (',NumberOfUnitFormulae,' unit;',NumberOfTypeFormulae,
+' type;',NumberOfDefnFormulae,' defn)'],FormulaeLine),
+%----Atoms line
+    tptp2X_member('ATOM'-NumberOfAtoms,SyntaxReplacements),
+    tptp2X_member('EQAT'-NumberOfEqualityAtoms,SyntaxReplacements),
+    tptp2X_member('VAAT'-NumberOfVariableAtoms,SyntaxReplacements),
+    concatenate_atoms(['            Number of atoms       : ',
+NumberOfAtoms,' (',NumberOfEqualityAtoms,' equality;',NumberOfVariableAtoms,
+' variable)'],AtomsLine),
+%----Formula depth line
+    tptp2X_member('FMDP'-MaximalFormulaDepth,SyntaxReplacements),
+    tptp2X_member('FMAD'-AverageFormulaDepth,SyntaxReplacements),
+    concatenate_atoms(['            Maximal formula depth : ',
+MaximalFormulaDepth,' (',AverageFormulaDepth,' average)'],FormulaDepthLine),
+%----1st connectives line
+    tptp2X_member('CONN'-NumberOfConnectives,SyntaxReplacements),
+    tptp2X_member('NOTS'-NumberOfNOTs,SyntaxReplacements),
+    tptp2X_member('ORSS'-NumberOfORs,SyntaxReplacements),
+    tptp2X_member('ANDS'-NumberOfANDs,SyntaxReplacements),
+    tptp2X_member('APPY'-NumberOfAPPLYs,SyntaxReplacements),
+    concatenate_atoms(['            Number of connectives : ',
+NumberOfConnectives,' (',NumberOfNOTs,'   ~;',NumberOfORs,'   |;',
+NumberOfANDs,'   &;',NumberOfAPPLYs,'   @)'],ConnectivesLine1),
+%----2nd connectives line
+    tptp2X_member('EQVS'-NumberOfEQUIVs,SyntaxReplacements),
+    tptp2X_member('IMPS'-NumberOfIMPLYs,SyntaxReplacements),
+    tptp2X_member('PMIS'-NumberOfIMPLIEDs,SyntaxReplacements),
+    tptp2X_member('XORS'-NumberOfXORs,SyntaxReplacements),
+    concatenate_atoms(['                                         (',
+NumberOfEQUIVs,' <=>;',NumberOfIMPLYs,'  =>;',NumberOfIMPLIEDs,'  <=;',
+NumberOfXORs,' <~>)'],ConnectivesLine2),
+%----3rd connectives line
+    tptp2X_member('NORS'-NumberOfNORs,SyntaxReplacements),
+    tptp2X_member('NANS'-NumberOfNANDs,SyntaxReplacements),
+    tptp2X_member('PIPI'-NumberOfPis,SyntaxReplacements),
+    tptp2X_member('SIGM'-NumberOfSigmas,SyntaxReplacements),
+    concatenate_atoms(['                                         (',
+NumberOfNORs,'  ~|;',NumberOfNANDs,'  ~&;',NumberOfPis,'  !!;',
+NumberOfSigmas,'  ??)'],ConnectivesLine3),
+%----Type connectives line
+    tptp2X_member('TCON'-NumberOfTypeConnectives,SyntaxReplacements),
+    tptp2X_member('MAPS'-NumberOfMaps,SyntaxReplacements),
+    tptp2X_member('XPRO'-NumberOfXProds,SyntaxReplacements),
+    tptp2X_member('UNIO'-NumberOfUnions,SyntaxReplacements),
+    tptp2X_member('SUBT'-NumberOfSubtypes,SyntaxReplacements),
+    concatenate_atoms(['            Number of type conns  : ',
+NumberOfTypeConnectives,' (',NumberOfMaps,'   >;',NumberOfXProds,'   *;',
+NumberOfUnions,'   +;',NumberOfSubtypes,'  <<)'],TypeConnectivesLine),
+%----Symbols line
+    tptp2X_member('FUNC'-NumberOfSymbols,SyntaxReplacements),
+    tptp2X_member('GTYP'-NumberOfGlobalTypeDecs,SyntaxReplacements),
+%NOT USED    tptp2X_member('GDEF'-NumberOfGlobalDefns,SyntaxReplacements),
+    concatenate_atoms(['            Number of symbols     : ',
+NumberOfSymbols,' (',NumberOfGlobalTypeDecs,'   :)'],SymbolsLine),
+%NOT USED (printing definitions) ;',NumberOfGlobalDefns,'  :=)'],SymbolsLine),
+%NOT USED tptp2X_member('CNST'-NumberOfConstants,SyntaxReplacements),
+%NOT USED tptp2X_member('MINF'-MinimalSymbolArity,SyntaxReplacements),
+%NOT USED tptp2X_member('MAXF'-MaximalSymbolArity,SyntaxReplacements),
+%NOT USED ,' (',NumberOfConstants,' constant; ',MinimalSymbolArity,
+%NOT USED '-',MaximalSymbolArity,' arity)'],SymbolsLine),
+%----1st variables line
+    tptp2X_member('VARS'-NumberOfVariables,SyntaxReplacements),
+    tptp2X_member('SGTN'-NumberOfSingletons,SyntaxReplacements),
+    tptp2X_member('UNIV'-NumberOfUniversals,SyntaxReplacements),
+    tptp2X_member('EXIS'-NumberOfExistentials,SyntaxReplacements),
+    tptp2X_member('LMDA'-NumberOfLambdas,SyntaxReplacements),
+    concatenate_atoms(['            Number of variables   : ',
+NumberOfVariables,' (',NumberOfSingletons,' sgn;',NumberOfUniversals,
+'   !;',NumberOfExistentials,'   ?;',NumberOfLambdas,'   ^)'],VariablesLine1),
+%----2nd variables line
+    tptp2X_member('TYPE'-NumberOfTypeDecs,SyntaxReplacements),
+%NOT USED    tptp2X_member('DEFN'-NumberOfDefns,SyntaxReplacements),
+    tptp2X_member('BIPI'-NumberOfPIs,SyntaxReplacements),
+    tptp2X_member('BISI'-NumberOfSIGMAs,SyntaxReplacements),
+    concatenate_atoms(['                                         (',
+NumberOfTypeDecs,'   :;',
+%NOT USED (printing definitions) NumberOfDefns,'  :=;',
+NumberOfPIs,'  !>;',NumberOfSIGMAs,'  ?*)'],VariablesLine2).
 %------------------------------------------------------------------------------
 %----Put leading blanks to get an atom in a field of 4
 integer_to_4_digit_atom(Number,Atom):-
@@ -1166,7 +1458,7 @@
 UpdatedFileHeader).
 
 %----Default, do nothing
-update_syntax_field(_,_Formulae,FileHeader,FileHeader).
+update_syntax_field(_,_,FileHeader,FileHeader).
 %------------------------------------------------------------------------------
 %----Extract the base name and type, one of clauses or generator
 base_filename_and_type(TPTPFileName,BaseInputName,_FormulaFormat,
@@ -1190,67 +1482,15 @@
     nl,
     fail.
 %------------------------------------------------------------------------------
-extract_conjecture_dictionary_pairs([],[],[],[],[]).
-
-extract_conjecture_dictionary_pairs([fof(Name,conjecture,LogicFormula)|
-RestOfRawFormulae],[ConjectureDictionary|RestOfRawDictionary],
-NonConjectureFormulae,NonConjectureDictionary,
-[fof(Name,conjecture,LogicFormula)-ConjectureDictionary|
-RestOfConjectureDictionaryPairs]):-
-    !,
-    extract_conjecture_dictionary_pairs(RestOfRawFormulae,RestOfRawDictionary,
-NonConjectureFormulae,NonConjectureDictionary,RestOfConjectureDictionaryPairs).
-
-extract_conjecture_dictionary_pairs([FirstFormula|RestOfRawFormulae],
-[FirstDictionary|RestOfRawDictionary],[FirstFormula|
-RestOfNonConjectureFormulae],[FirstDictionary|RestfNonConjectureDictionary],
-ConjectureDictionaryPairs):-
-    extract_conjecture_dictionary_pairs(RestOfRawFormulae,RestOfRawDictionary,
-RestOfNonConjectureFormulae,RestfNonConjectureDictionary,
-ConjectureDictionaryPairs).
-%------------------------------------------------------------------------------
-add_a_conjecture(NonConjectureFormulae,NonConjectureDictionary,
-[Conjecture-ConjectureDictionary|_],BaseInputName,Index,Formulae,Dictionary,
-UpdatedBaseInputName):-
-    tptp2X_append(NonConjectureFormulae,[Conjecture],Formulae),
-    tptp2X_append(NonConjectureDictionary,[ConjectureDictionary],Dictionary),
-    concatenate_atoms([BaseInputName,'_',Index],UpdatedBaseInputName).
-
-add_a_conjecture(NonConjectureFormulae,NonConjectureDictionary,
-[_|RestOfConjectureDictionaryPairs],BaseInputName,Index,Formulae,Dictionary,
-UpdatedBaseInputName):-
-    NextIndex is Index + 1,
-    add_a_conjecture(NonConjectureFormulae,NonConjectureDictionary,
-RestOfConjectureDictionaryPairs,BaseInputName,NextIndex,Formulae,Dictionary,
-UpdatedBaseInputName).
-%------------------------------------------------------------------------------
-expand_multiple_conjectures(RawFormulae,RawDictionary,BaseInputName,Formulae,
-Dictionary,UpdatedBaseInputName):-
-    tptp_formulae(RawFormulae),
-    tptp2X_select(fof(_,conjecture,_),RawFormulae,OtherRawFormulae),
-    tptp2X_member(fof(_,conjecture,_),OtherRawFormulae),
-    !,
-    extract_conjecture_dictionary_pairs(RawFormulae,RawDictionary,
-NonConjectureFormulae,NonConjectureDictionary,ConjectureDictionaryPairs),
-    add_a_conjecture(NonConjectureFormulae,NonConjectureDictionary,
-ConjectureDictionaryPairs,BaseInputName,1,Formulae,Dictionary,
-UpdatedBaseInputName).
-
-expand_multiple_conjectures(Formulae,Dictionary,BaseInputName,Formulae,
-Dictionary,BaseInputName).
-%------------------------------------------------------------------------------
 %----Get the clauses from file or by generation
 get_header_and_formulae(TPTPFileName,BaseInputName,FileHeader,Extension,_,
-UpdatedBaseInputName,CommentedFileHeader,Formulae,Dictionary):-
+BaseInputName,CommentedFileHeader,Formulae,Dictionary):-
 %----Check for problem and axiom files
     tptp2X_member(Extension,['.p','.ax','.eq']),
 %----Read in the formulae
-    read_formulae_from_file(TPTPFileName,RawFormulae,RawDictionary),
-%----Expand multiple FOF conjectures
-    expand_multiple_conjectures(RawFormulae,RawDictionary,BaseInputName,
-Formulae,Dictionary,UpdatedBaseInputName),
+    read_formulae_from_file(TPTPFileName,Formulae,Dictionary),
 %----Make indicator of source
-    concatenate_atoms([UpdatedBaseInputName,Extension],ReadingText),
+    concatenate_atoms([BaseInputName,Extension],ReadingText),
     add_tptp2X_comment(old,FileHeader,ReadingText,CommentedFileHeader).
 
 get_header_and_formulae(TPTPFileName,BaseInputName,RawFileHeader,'.g',
@@ -1277,23 +1517,25 @@
     numbervars(Formula,0,_),
     numbervars_each_formula(RestOfFormulae).
 %------------------------------------------------------------------------------
-%----Syntax needed for non-TPTP system recommendations
-has_changed_for_syntax(_,_,FileHeader,changed):-
-    tptp2X_member('Syntax'-[_],FileHeader),
+%----Check if the formulae have changed, in which case statistics are computed
+%----This one for dubugging - forces it to happen
+%DEBUG has_changed_for_syntax(_,_,_,_,changed):-!.
+
+%----Needed if specified as the transformation
+has_changed_for_syntax(_,_,syntax,_,changed):-
     !.
 
-%----Not needed if existing syntac field is unchanged
-has_changed_for_syntax(Formulae,OutputFormulae,_,unchanged):-
+%----Not needed if existing syntax field is unchanged
+has_changed_for_syntax(Formulae,OutputFormulae,_,_,unchanged):-
     Formulae == OutputFormulae,
     !.
 
-%----Can't recall why I had this, but now I need the syntax for system
-%----recommendations, so I've added that above
-has_changed_for_syntax(_,_,FileHeader,unchanged):-
+%----For problems that never had any syntax - do nothing
+has_changed_for_syntax(_,_,_,FileHeader,unchanged):-
     \+ tptp2X_member('Syntax'-_,FileHeader),
     !.
 
-has_changed_for_syntax(_,_,_,changed).
+has_changed_for_syntax(_,_,_,_,changed).
 %------------------------------------------------------------------------------
 %----Do this in all possible ways by backtracking
 make_all_outputs(TPTPFileName,BaseInputName,Extension,GenerationSpecification,
@@ -1311,11 +1553,13 @@
 Dictionary,Transformation,TransformedFileHeader,OutputFormulae,BaseOutputName,
 NewDictionary,TransformationDone),
 %----Add comment about transformations done if not none
-    (TransformationDone == none ->
-        TransformCommentedFileHeader = TransformedFileHeader;
-        (   concatenate_atoms(['-t ',TransformationDone],TransformationText),
+    (TransformationDone == none
+    ->  TransformCommentedFileHeader = TransformedFileHeader
+    ;   (   concatenate_atoms(['-t ',TransformationDone],TransformationText),
             add_tptp2X_comment(old,TransformedFileHeader,TransformationText,
-TransformCommentedFileHeader))),
+TransformCommentedFileHeader)
+        )
+    ),
 %----If shorten transformation, then clobber the header
     shorten_header(TransformationDone,TransformCommentedFileHeader,
 ShortenedFileHeader),
@@ -1327,8 +1571,8 @@
     instantiate_variables_from_dictionary(NewDictionary),
     numbervars_each_formula(OutputFormulae),
 %----Check if header needs syntax update (avoid where possible)
-    has_changed_for_syntax(Formulae,OutputFormulae,ShortenedFileHeader,
-ChangedOrNot),
+    has_changed_for_syntax(Formulae,OutputFormulae,TransformationDone,
+ShortenedFileHeader,ChangedOrNot),
 %----Update the Syntax field in the header for the new clauses
     update_syntax_field(ChangedOrNot,OutputFormulae,ShortenedFileHeader,
 SyntaxFileHeader),
@@ -1337,7 +1581,9 @@
 OutputFormat,BaseOutputName,OutputDirectory,_OutputFormatUsed,
 OutputFileName),
     (OutputDirectory \== user ->
-        (   write(BaseInputName),
+        (   write(TPTPFileName),
+%----Need the full name for SystemOnTPTP processing
+%----        (   write(BaseInputName),
             write(' -> '),
             write(OutputFileName),
             nl)
diff -ur 1/TPTP2X/tptp2X.read 2/TPTP2X/tptp2X.read
--- 1/TPTP2X/tptp2X.read	2007-03-01 12:01:53.000000000 -0500
+++ 2/TPTP2X/tptp2X.read	2012-08-13 14:45:12.000000000 -0400
@@ -9,11 +9,16 @@
 %==============================================================================
 %------------------------------------------------------------------------------
 get_environment_variable(Name,Value):-
-    prolog_dialect(swiprolog),
+    prolog_dialect(swi),
     getenv(Name,Value),
     !.
 
 get_environment_variable(Name,Value):-
+    prolog_dialect(gnu),
+    environ(Name,Value),
+    !.
+
+get_environment_variable(Name,Value):-
     prolog_dialect(yap),
     environ(Name,Value),
     !.
@@ -36,11 +41,16 @@
     exists(FileName).
 
 tptp_file_exists(FileName):-
-    prolog_dialect(swiprolog),
+    prolog_dialect(swi),
     !,
     exists_file(FileName).
 
 tptp_file_exists(FileName):-
+    prolog_dialect(gnu),
+    !,
+    file_exists(FileName).
+
+tptp_file_exists(FileName):-
     prolog_dialect(sicstus),
     !,
     file_exists(FileName).
@@ -81,17 +91,21 @@
 %----is used to generate as well as search for files, hence the split
 %----with tptp_find_file.
 tptp_path_name(TPTPFileName,PathName):-
-    name(TPTPFileName,TPTPFileNameList),
     get_tptp_directory(Directory),
-%DEBUG write('including from '),write(Directory),nl,
-    name(Directory,DirectoryList),
-    tptp2X_append(DirectoryList,[47|TPTPFileNameList],PathNameList),
-    name(PathName,PathNameList).
+%DEBUG write('reading from '),write(Directory),nl,
+    concatenate_atoms([Directory,'/',TPTPFileName],PathName).
+
 %------------------------------------------------------------------------------
 %----If absolute, then use that
 %----If it starts with /, nothing
 tptp_find_file(TPTPFileName,_,TPTPFileName):-
+%DEBUG write('----'),writeq(TPTPFileName),nl,
+%DEBUG name(TPTPFileName,X),
+%DEBUG write('===='),write(X),nl,
+%DEBUG X = [47|_],
+%DEBUG write('<<<< Yes, it starts with 47'),nl,
     name(TPTPFileName,[47|_]),
+%DEBUG write('>>>> Yes, the unification works'),nl,
     !.
 
 %----If starts with ~/ then put $HOME on front
@@ -116,7 +130,9 @@
 tptp_find_file(TPTPFileName,CurrentFileName,PathName):-
     var(CurrentFileName),
     tptp2X_cwd(Directory),
+%DEBUG write('Look in '),write(Directory),nl,
     concatenate_atoms([Directory,'/',TPTPFileName],PathName),
+%DEBUG write('Look if this is it '),write(PathName),nl,
     tptp_file_exists(PathName),
     !.
 
@@ -132,50 +148,119 @@
     nl,
     fail.
 %------------------------------------------------------------------------------
+%DEBUG convert_prolog_operators(What,_):-write('convert---'),display(What),nl,fail.
+
 %----Convert infix equality to prefix for internal processing
-convert_to_prefix_equal([],[]):-
+convert_prolog_operators(Variable,Variable):-
+    looks_like_a_variable(Variable),
     !.
 
-convert_to_prefix_equal([FirstLiteral|RestOfLiterals],
-[FirstPrefixEqualLiteral|RestOfPrefixEqualLiterals]):-
-    !,
+convert_prolog_operators([],[]):-
+    !.
+
+%----For CNF
+convert_prolog_operators([FirstLiteral|RestOfLiterals],
+[FirstConvertedLiteral|RestOfConvertedLiterals]):-
+    \+ looks_like_a_variable(FirstLiteral),
     FirstLiteral =.. [Sign,Atom],
-    convert_to_prefix_equal(Atom,PrefixEqualAtom),
-    FirstPrefixEqualLiteral =.. [Sign,PrefixEqualAtom],
-    convert_to_prefix_equal(RestOfLiterals,RestOfPrefixEqualLiterals).
+    tptp2X_member(Sign,[++,--]),
+    !,
+    convert_prolog_operators(Atom,ConvertedAtom),
+    FirstConvertedLiteral =.. [Sign,ConvertedAtom],
+    convert_prolog_operators(RestOfLiterals,RestOfConvertedLiterals).
 
-convert_to_prefix_equal(QuantifiedFormula,QuantifiedPrefixEqualFormula):-
+%----For regular lists
+convert_prolog_operators([H|T],[ConvertedH|ConvertedT]):-
+    !,
+    convert_prolog_operators(H,ConvertedH),
+    convert_prolog_operators(T,ConvertedT).
+
+%----!(!) becomes !!
+convert_prolog_operators(!(!),'!!'):-
+   !.
+
+%----!(!( becomes !! (
+convert_prolog_operators(!(!(Formula)),'!!' (ConvertedFormula)):-
+    !,
+    convert_prolog_operators(Formula,ConvertedFormula).
+
+%---->(!( becomes !> (
+convert_prolog_operators(:(PIBinder,Formula),'!>' ConvertedVariables:
+ConvertedFormula):-
+    nonvar(PIBinder),
+    PIBinder = >(!,Variables),
+    !,
+    convert_prolog_operators(Variables,ConvertedVariables),
+    convert_prolog_operators(Formula,ConvertedFormula).
+
+convert_prolog_operators(QuantifiedFormula,QuantifiedConvertedFormula):-
     tptp_quantified_formula(QuantifiedFormula,Quantifier,Variables,Formula),
     !,
-    convert_to_prefix_equal(Formula,PrefixEqualFormula),
-    Quantification =.. [Quantifier,Variables],
-    QuantifiedPrefixEqualFormula =.. [:,Quantification,PrefixEqualFormula].
+    convert_prolog_operators(Variables,ConvertedVariables),
+    Quantification =.. [Quantifier,ConvertedVariables],
+    convert_prolog_operators(Formula,ConvertedFormula),
+    QuantifiedConvertedFormula =.. [:,Quantification,ConvertedFormula].
 
-convert_to_prefix_equal(BinaryFormula,BinaryPrefixEqualFormula):-
+convert_prolog_operators(BinaryFormula,BinaryConvertedFormula):-
     tptp_binary_formula(BinaryFormula,BinaryConnective,LHS,RHS),
     !,
-    convert_to_prefix_equal(LHS,PrefixEqualLHS),
-    convert_to_prefix_equal(RHS,PrefixEqualRHS),
-    BinaryPrefixEqualFormula =.. [BinaryConnective,PrefixEqualLHS,
-PrefixEqualRHS].
+    convert_prolog_operators(LHS,ConvertedLHS),
+    convert_prolog_operators(RHS,ConvertedRHS),
+    BinaryConvertedFormula =.. [BinaryConnective,ConvertedLHS,
+ConvertedRHS].
 
-convert_to_prefix_equal(UnaryFormula,UnaryPrefixEqualFormula):-
+convert_prolog_operators(UnaryFormula,UnaryConvertedFormula):-
     tptp_unary_formula(UnaryFormula,UnaryConnective,Formula),
     !,
-    convert_to_prefix_equal(Formula,PrefixEqualFormula),
-    UnaryPrefixEqualFormula =.. [UnaryConnective,PrefixEqualFormula].
+    convert_prolog_operators(Formula,ConvertedFormula),
+    UnaryConvertedFormula =.. [UnaryConnective,ConvertedFormula].
+
+convert_prolog_operators(Atom,Atom):-
+    atomic(Atom),
+    !.
+
+%----Still interpret equal as =
+convert_prolog_operators(equal(LHS,RHS),ConvertedEquality):-
+    !,
+    convert_prolog_operators(LHS = RHS,ConvertedEquality).
 
 %----Special hack for !=, with ! as a postfix operator
-convert_to_prefix_equal(LHS = RHS,~ equal(RealLHS,RHS)):-
+convert_prolog_operators(LHS = RHS,~ ConvertedEquality):-
     nonvar(LHS),
     LHS = !(RealLHS),
-    !.
+    !,
+    convert_prolog_operators(RealLHS = RHS,ConvertedEquality).
 
-convert_to_prefix_equal(LHS = RHS,equal(LHS,RHS)):-
-    !.
+convert_prolog_operators(LHS = RHS,'$tptp_equal'(ConvertedLHS,ConvertedRHS)):-
+    !,
+    convert_prolog_operators(LHS,ConvertedLHS),
+    convert_prolog_operators(RHS,ConvertedRHS).
 
-convert_to_prefix_equal(Atom,Atom):-
-    tptp_atomic_formula(Atom).
+convert_prolog_operators(LHS:RHS,ConvertedLHS:ConvertedRHS):-
+    !,
+    convert_prolog_operators(LHS,ConvertedLHS),
+    convert_prolog_operators(RHS,ConvertedRHS).
+
+convert_prolog_operators($$(Function),ConvertedFunction):-
+    !,
+    Function =.. [Functor|Arguments],
+    name(Functor,FunctorASCII),
+    name(DollarFunctor,[36,36|FunctorASCII]),
+    convert_prolog_operators(Arguments,ConvertedArguments),
+    ConvertedFunction =.. [DollarFunctor|ConvertedArguments].
+
+convert_prolog_operators($(Function),ConvertedFunction):-
+    !,
+    Function =.. [Functor|Arguments],
+    name(Functor,FunctorASCII),
+    name(DollarFunctor,[36|FunctorASCII]),
+    convert_prolog_operators(Arguments,ConvertedArguments),
+    ConvertedFunction =.. [DollarFunctor|ConvertedArguments].
+
+convert_prolog_operators(Function,ConvertedFunction):-
+    Function =.. FunctionList,
+    convert_prolog_operators(FunctionList,ConvertedFunctionList),
+    ConvertedFunction =.. ConvertedFunctionList.
 %------------------------------------------------------------------------------
 %----Determine what to do with the term read.
 %----Input clauses are returned in a list. Note the dictionary is 
@@ -197,8 +282,8 @@
 
 normalize_and_include(cnf(Name,Status,CNFFormula),Dictionary,
 CurrentFileName,Clauses,NewDictionary):-
-    convert_to_prefix_equal(CNFFormula,PrefixEqualLiterals),
-    convert_tptp_to_literals(PrefixEqualLiterals,Literals),
+    convert_prolog_operators(CNFFormula,ConvertedLiterals),
+    convert_tptp_to_literals(ConvertedLiterals,Literals),
     !,
     normalize_and_include(input_clause(Name,Status,Literals),Dictionary,
 CurrentFileName,Clauses,NewDictionary).
@@ -216,17 +301,17 @@
     normalize_and_include(fof(Name,Status,Formula),Dictionary,CurrentFileName,
 Formulae,NewDictionary).
 
-%----thof format currently reduced to short format
-normalize_and_include(thof(Name,Status,Formula,_),Dictionary,CurrentFileName,
+%----thf format currently reduced to short format
+normalize_and_include(thf(Name,Status,Formula,_),Dictionary,CurrentFileName,
 Formulae,NewDictionary):-
     !,
-    normalize_and_include(thof(Name,Status,Formula),Dictionary,CurrentFileName,
+    normalize_and_include(thf(Name,Status,Formula),Dictionary,CurrentFileName,
 Formulae,NewDictionary).
 
-normalize_and_include(thof(Name,Status,Formula,_,_),Dictionary,CurrentFileName,
+normalize_and_include(thf(Name,Status,Formula,_,_),Dictionary,CurrentFileName,
 Formulae,NewDictionary):-
     !,
-    normalize_and_include(thof(Name,Status,Formula),Dictionary,CurrentFileName,
+    normalize_and_include(thf(Name,Status,Formula),Dictionary,CurrentFileName,
 Formulae,NewDictionary).
 
 %----Old tptp input_formula format gets converted to fof
@@ -238,21 +323,26 @@
 
 %----Convert to prefix equality
 normalize_and_include(input_clause(Name,Status,Literals),Dictionary,_,
-[input_clause(Name,Status,PrefixEqualLiterals)],[Dictionary]):-
+[input_clause(Name,Status,ConvertedLiterals)],[Dictionary]):-
     !,
-    convert_to_prefix_equal(Literals,PrefixEqualLiterals).
+    convert_prolog_operators(Literals,ConvertedLiterals).
 
 normalize_and_include(fof(Name,Status,Formula),Dictionary,_,
-[fof(Name,Status,PrefixEqualFormula)],[Dictionary]):-
+[fof(Name,Status,ConvertedFormula)],[Dictionary]):-
+    !,
+    convert_prolog_operators(Formula,ConvertedFormula).
+
+normalize_and_include(tff(Name,Status,Formula),Dictionary,_,
+[tff(Name,Status,ConvertedFormula)],[Dictionary]):-
     !,
-    convert_to_prefix_equal(Formula,PrefixEqualFormula).
+    convert_prolog_operators(Formula,ConvertedFormula).
 
-normalize_and_include(thof(Name,Status,Formula),Dictionary,_,
-[thof(Name,Status,PrefixEqualFormula)],[Dictionary]):-
+normalize_and_include(thf(Name,Status,Formula),Dictionary,_,
+[thf(Name,Status,ConvertedFormula)],[Dictionary]):-
     !,
-    convert_to_prefix_equal(Formula,PrefixEqualFormula).
+    convert_prolog_operators(Formula,ConvertedFormula).
 
-%----Include directive cause recursive call to the top level to read
+%----Include directive causes recursive call to the top level to read
 %----the included file.
 normalize_and_include(include(TPTPFileName),_,CurrentFileName,Formulae,
 Dictionary):-
@@ -328,11 +418,11 @@
     read_term(Term,[variable_names(Dictionary)]).
 
 %----SWI prolog
-real_read_for_dialect(swiprolog,Term,Dictionary):-
+real_read_for_dialect(swi,Term,Dictionary):-
     read_term(Term,[variable_names(Dictionary)]).
 
 %----GNU prolog
-real_read_for_dialect(gnuprolog,Term,Dictionary):-
+real_read_for_dialect(gnu,Term,Dictionary):-
     read_term(Term,[variable_names(Dictionary)]).
 
 %----Eclipse version (supplied by Max Moser of TUM)
@@ -358,6 +448,7 @@
 %----Cut to know there is a dialect
     !,
     real_read_for_dialect(Dialect,Term,Dictionary),
+%DEBUG write('read ==='),write(Term),nl,
 %----Cut to prevent back tracking over reading for any dialect (need for YAP)
     !.
 
@@ -371,13 +462,13 @@
 %----Need to deal with skolem_functor facts here, if and when I add
 %----the equality stuff again
     real_read(PrologTerm,TermDictionary),
-%DEBUG write('%% '),write(PrologTerm),nl,
+%DEBUG write('%% '),display(PrologTerm),nl,
     PrologTerm \== end_of_file,
     !,
 %----Check if an include, and return all clauses resulting
     normalize_and_include(PrologTerm,TermDictionary,CurrentFileName,
 FirstFormulae,FirstDictionary),
-%DEBUG write('%% #### '),write(FirstFormulae),nl,
+%DEBUG write('%% #### '),display(FirstFormulae),nl,
     read_formulae(Selection,CurrentFileName,RestOfFormulae,RestOfDictionary),
     tptp2X_append(FirstFormulae,RestOfFormulae,Formulae),
     tptp2X_append(FirstDictionary,RestOfDictionary,Dictionary).
@@ -507,7 +598,7 @@
     tptp2X_append(NonBlanks,[32|_],LineASCII),
     name(FieldName,NonBlanks),
     tptp2X_member(FieldName,['File','Domain','Problem','Axioms','Version',
-'English','Refs','Source','Names','Status','Rating','Syntax','Comments',
+'English','Refs','Source','Names','Status','Rating','Syntax','SPC','Comments',
 'Bugfixes',
 %----For TSTP
 'File','Problem','Transform','Format','Command','Computer','Model','CPU',
@@ -546,6 +637,41 @@
     read_header_fields(FirstLine,Header),
     !.
 %------------------------------------------------------------------------------
+%----If empty header read them provide all dummy fields
+complete_header([],BaseInputName,[
+'File'-[FileLine],
+'Domain'-[' Domain   :'],
+'Problem'-[' Problem  :'],
+'Version'-[' Version  :'],
+'English'-[' English  :'],
+'Blank'-[''],
+'Refs'-[' Refs     :'],
+'Source'-[' Source   :'],
+'Names'-[' Names    :'],
+'Blank'-[''],
+'Status'-[' Status   : unknown'],
+'Rating'-[' Rating   : ?'],
+'Syntax'-[' Syntax   :'],
+%----Not useful now FOF has arrived. Kept in case.
+%'            Number of clauses           :    0 (   0 non-Horn)(   0 unit)',
+%'            Number of literals          :    0 (   0 equality)',
+%'            Maximal clause size         :    0',
+%'            Number of predicate symbols :    0 (   0 propositional)',
+%'            Number of function symbols  :    0 (   0 constant)',
+%'            Number of variables         :    0 (   0 singleton)',
+%'            Maximal term depth          :    0'],
+'SPC'-[' SPC      :'],
+'Blank'-[''],
+'Comments'-[' Comments : '] ]):-
+    !,
+    name(BaseInputName,BaseInputNameASCII),
+    tptp2X_append(" File     : ",BaseInputNameASCII,FileLineASCII1),
+    tptp2X_append(FileLineASCII1," : TPTP v0.0.0. Released v0.0.0.",
+FileLineASCII2),
+    name(FileLine,FileLineASCII2).
+
+complete_header(Header,_,Header).
+%------------------------------------------------------------------------------
 %----Read TPTP file header, in fields
 read_header_from_file(TPTPFileName,BaseInputName,Header):-
 %----Make full path name
@@ -562,39 +688,13 @@
 %----cases and input restored
     (   (   separator_line(FirstHeaderLine),
 %----Read in the header fields
-            read_header_fields(Header)) -> 
-        true
-    ;   (
-        name(BaseInputName,BaseInputNameASCII),
-        tptp2X_append(" File     : ",BaseInputNameASCII,FileLineASCII1),
-        tptp2X_append(FileLineASCII1," : TPTP v0.0.0. Released v0.0.0.",
-FileLineASCII2),
-        name(FileLine,FileLineASCII2),
-        Header = [
-            'File'-[FileLine],
-            'Domain'-[' Domain   :'],
-            'Problem'-[' Problem  :'],
-            'Version'-[' Version  :'],
-            'English'-[' English  :'],
-            'Blank'-[''],
-            'Refs'-[' Refs     :'],
-            'Source'-[' Source   :'],
-            'Names'-[' Names    :'],
-            'Blank'-[''],
-            'Status'-[' Status   : unknown'],
-            'Rating'-[' Rating   : ?'],
-            'Syntax'-[' Syntax   :'],
-%----Not useful now FOF has arrived. Kept in case.
-%'            Number of clauses           :    0 (   0 non-Horn)(   0 unit)',
-%'            Number of literals          :    0 (   0 equality)',
-%'            Maximal clause size         :    0',
-%'            Number of predicate symbols :    0 (   0 propositional)',
-%'            Number of function symbols  :    0 (   0 constant)',
-%'            Number of variables         :    0 (   0 singleton)',
-%'            Maximal term depth          :    0'],
-            'Blank'-[''],
-            'Comments'-[' Comments : ']]
-    )),
+            read_header_fields(HeaderFromFile)) -> 
+%----If an empty header is read, i.e., two separator lines, then fill in
+%----dummy fields. If any fields are read, keep just them.
+        complete_header(HeaderFromFile,BaseInputName,Header)
+%----If no header, or a single separator line, then return no header
+    ;   Header = []
+    ),
 %----Cut, so that later errors do not try to read more fields
     !,
 %----Restore output direction
diff -ur 1/TPTP2X/tptp2X.syntax 2/TPTP2X/tptp2X.syntax
--- 1/TPTP2X/tptp2X.syntax	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/tptp2X.syntax	2012-08-13 14:45:12.000000000 -0400
@@ -5,13 +5,46 @@
 %----Recognition of tptp syntax
 %==============================================================================
 %------------------------------------------------------------------------------
+tptp_quantifier(Quantifier):-
+    tptp2X_member(Quantifier,['!','?','^','!>','?*',':=','@+','@-']).
+%------------------------------------------------------------------------------
+tptp_type_binary_connective(TypeConnective):-
+    tptp2X_member(TypeConnective,['>','*','+']).
+%------------------------------------------------------------------------------
+tptp_flat_binary_connnective(Connective):-
+    tptp2X_member(Connective,['@','>','*','+']).
+%------------------------------------------------------------------------------
+tptp_associative_binary_connective(Connective):-
+%----|;BUG
+    tptp2X_member(Connective,[&,'|',';','@','*','+','>']).
+%------------------------------------------------------------------------------
+tptp_left_associative_binary_connective(Connective):-
+    tptp2X_member(Connective,['@','*','+']).
+%------------------------------------------------------------------------------
+tptp_right_associative_binary_connective(Connective):-
+    tptp2X_member(Connective,['>']).
+%------------------------------------------------------------------------------
+tptp_binary_connnective(Connective):-
+    tptp2X_member(Connective,['|',';','~|','&','~&','=>','<=','<=>','<~>','@',
+'>','*','+','-->']).
+%------------------------------------------------------------------------------
 %----Recognise and split up quantified formulae
 %----FOF syntax, only in tptp mode
 tptp_quantified_formula(QuantifiedFormula,Quantifier,Variables,Formula):-
+    nonvar(QuantifiedFormula),
     QuantifiedFormula =.. [:,Quantification,Formula],
-    !,
+    \+ looks_like_a_variable(Quantification),
     Quantification =.. [Quantifier,Variables],
-    tptp2X_member(Quantifier,['!','?','^']).
+    tptp_quantifier(Quantifier),
+    !.
+
+%----Case for reconstruction
+tptp_quantified_formula(QuantifiedFormula,Quantifier,Variables,Formula):-
+    var(QuantifiedFormula),
+    QuantifiedFormula =.. [:,Quantification,Formula],
+    Quantification =.. [Quantifier,Variables],
+    tptp_quantifier(Quantifier),
+    !.
 
 oldtptp_quantified_formula(QuantifiedFormula,Quantifier,Variables,Formula):-
     tptp_quantified_formula(QuantifiedFormula,Quantifier,Variables,Formula).
@@ -20,13 +53,13 @@
 %----Converting from the Prolog syntax to FOF syntax
 tptp_binary_formula(BinaryFormula,BinaryConnective,LHS,RHS):-
 %----Do the member first to get instantiated variables for backward use
-%----Will backtrack until it finds the right connective. 
-    tptp2X_member(OldBinaryConnective-BinaryConnective,[
-%----Double \\ for SICStus and old syntax. TO BE REMOVED LATER.
-%---- '\\/'-'|',    '\\~/'-'~|',    '/\\'-'&',    '/~\\'-'~&',
+%----Will backtrack until it finds the right connective. Needs the ()s for 
+%----Prolog weirdness with '+'.
+    tptp2X_member((OldBinaryConnective)-(BinaryConnective),[
 %----|;BUG
-'|'-'|',     ';'-'|',     '~|'-'~|',    '&'-'&',     '~&'-'~&',   
-'=>'-'=>',   '<='-'<=',   '<=>'-'<=>', '<~>'-'<~>']),
+('|')-('|'),(';')-('|'),('~|')-('~|'),('&')-('&'),('~&')-('~&'), ('=>')-('=>'),
+('<=')-('<='),('<=>')-('<=>'),('<~>')-('<~>'),('@')-('@'),('>')-('>'),
+('*')-('*'),('+')-('+'),('-->')-('-->')]),
     BinaryFormula =.. [OldBinaryConnective,LHS,RHS].
 
 oldtptp_binary_formula(BinaryFormula,BinaryConnective,LHS,RHS):-
@@ -35,7 +68,7 @@
 %----Recognise and split up unary formulae
 tptp_unary_formula(UnaryFormula,UnaryConnective,Formula):-
     UnaryFormula =.. [UnaryConnective,Formula],
-    tptp2X_member(UnaryConnective,[~]).
+    tptp2X_member(UnaryConnective,['~','!!','??']).
 
 oldtptp_unary_formula(UnaryFormula,UnaryConnective,Formula):-
     tptp_unary_formula(UnaryFormula,UnaryConnective,Formula).
@@ -49,11 +82,54 @@
 
 tptp_non_atomic_formula(Formula):-
     tptp_unary_formula(Formula,_,_).
+
+%----A sad attempt to recognize when an equality is an equation. It doesn't
+%----work because X = Y is an equation but is seen to be an atomic equality.
+%----Shit, because variables are atoms for THF.
+tptp_non_atomic_formula('$tptp_equal'(LHS,_)):-
+    \+ tptp_atomic_formula(LHS).
+
+tptp_non_atomic_formula('$tptp_equal'(_,RHS)):-
+    \+ tptp_atomic_formula(RHS).
+
+%----!= are unary
+tptp_non_atomic_formula('$tptp_not_equal'(_,_)).
+
+%----Tuples - non-empty ones are not atomic
+tptp_non_atomic_formula([_|_]).
 %------------------------------------------------------------------------------
-%----Recognize atomic formulae
+%----Recognize atomic formulae. Variables for THF.
+tptp_atomic_formula(Variable):-
+    looks_like_a_variable(Variable),
+    !.
+
 tptp_atomic_formula(AtomicFormula):-
     \+ tptp_non_atomic_formula(AtomicFormula).
 %------------------------------------------------------------------------------
+tptp_flat_binary_formula(Variable,BinaryConnective):-
+    looks_like_a_variable(Variable),
+    !,
+    tptp_flat_binary_connnective(BinaryConnective).
+
+tptp_flat_binary_formula(Formula,BinaryConnective):-
+    tptp_literal_formula(Formula,_),
+    !,
+    tptp_flat_binary_connnective(BinaryConnective).
+
+tptp_flat_binary_formula(Formula,BinaryConnective):-
+    Formula =.. [BinaryConnective,LHS,RHS],
+    tptp_flat_binary_connnective(BinaryConnective),
+    tptp_flat_binary_formula(LHS,_LHSConnective),
+    tptp_flat_binary_formula(RHS,_RHSConnective).
+%------------------------------------------------------------------------------
+tptp_flat_type(Formula,BinaryConnective):-
+    tptp_flat_binary_formula(Formula,BinaryConnective),
+    !.
+
+tptp_flat_type(XProd > Symbol,'>'):-
+    atomic(Symbol),
+    tptp_flat_binary_formula(XProd,'*').
+%------------------------------------------------------------------------------
 %----Recognize literal formulae
 tptp_literal_formula(~Atom,Atom):-
     tptp_atomic_formula(Atom).
@@ -64,32 +140,65 @@
 %----Check that it is a list of clauses
 tptp_clauses([]).
 
-tptp_clauses([input_clause(_,_,_)|RestOfClauses]):-
+tptp_clauses([input_clause(_,_Role,_)|RestOfClauses]):-
+%----CNF cannot have conjectures - why did I enforce this?
+%    Role \== conjecture,
     tptp_clauses(RestOfClauses).
 %------------------------------------------------------------------------------
-%----Check that it is a list of formulae
-tptp_formulae([]).
+tptp_ensure_short_form([],[]).
 
-tptp_formulae([fof(_,_,_)|RestOfFormulae]):-
-    tptp_formulae(RestOfFormulae).
-
-tptp_formulae([thof(_,_,_)|RestOfFormulae]):-
-    tptp_formulae(RestOfFormulae).
+tptp_ensure_short_form([AnnotatedFormula|RestOfAnnotatedFormulae],
+[ShortAnnotatedFormula|RestOfShortForms]):-
+    AnnotatedFormula =.. [Language,Name,Role,Logic|_],
+    ShortAnnotatedFormula =.. [Language,Name,Role,Logic],
+    tptp_ensure_short_form(RestOfAnnotatedFormulae,RestOfShortForms).
 %------------------------------------------------------------------------------
-%----Check that it is a list of tstp formulae
-tstp_clauses([]).
+tptp_ensure_long_form([],[]).
+
+tptp_ensure_long_form([AnnotatedFormula|RestOfAnnotatedFormulae],
+[LongAnnotatedFormula|RestOfLongForms]):-
+    AnnotatedFormula =.. [Language,Name,Role,Logic],
+    !,
+    LongAnnotatedFormula =.. [Language,Name,Role,Logic,unknown,[]],
+    tptp_ensure_long_form(RestOfAnnotatedFormulae,RestOfLongForms).
 
-tstp_clauses([Formula|RestOfFormulae]):-
-    Formula =.. [cnf|_],
-    tstp_formulae(RestOfFormulae).
+tptp_ensure_long_form([AnnotatedFormula|RestOfAnnotatedFormulae],
+[LongAnnotatedFormula|RestOfLongForms]):-
+    AnnotatedFormula =.. [Language,Name,Role,Logic,Source],
+    !,
+    LongAnnotatedFormula =.. [Language,Name,Role,Logic,Source,[]],
+    tptp_ensure_long_form(RestOfAnnotatedFormulae,RestOfLongForms).
+
+tptp_ensure_long_form([AnnotatedFormula|RestOfAnnotatedFormulae],
+[AnnotatedFormula|RestOfLongForms]):-
+    AnnotatedFormula =.. [_,_,_,_,_,_],
+    !,
+    tptp_ensure_long_form(RestOfAnnotatedFormulae,RestOfLongForms).
 %------------------------------------------------------------------------------
-%----Check that it is a list of tstp formulae
-tstp_formulae([]).
+%----Check that it is a list of formulae with these languages
+tptp_formulae_language([],_).
 
-tstp_formulae([Formula|RestOfFormulae]):-
+tptp_formulae_language([Formula|RestOfFormulae],Languages):-
     Formula =.. [Language|_],
-    tptp2X_member(Language,[cnf,fof]),
-    tstp_formulae(RestOfFormulae).
+    tptp2X_member(Language,Languages),
+    tptp_formulae_language(RestOfFormulae,Languages).
+%------------------------------------------------------------------------------
+%----Extract formulae with a given role
+tptp_separate_formulae_with_role(_,[],[],[]).
+
+tptp_separate_formulae_with_role(Role,[WithRole|Rest],[WithRole|
+RestWithRole],OtherRole):-
+    WithRole =.. [_,_,Role|_],
+    !,
+    tptp_separate_formulae_with_role(Role,Rest,RestWithRole,OtherRole).
+
+tptp_separate_formulae_with_role(Role,[WithoutRole|Rest],WithRole,[WithoutRole|
+RestWithoutRole]):-
+    tptp_separate_formulae_with_role(Role,Rest,WithRole,RestWithoutRole).
+%------------------------------------------------------------------------------
+%----Check that it is a list of formulae
+tptp_formulae(Formulae):-
+    tptp_formulae_language(Formulae,[fof,thf,tff]).
 %------------------------------------------------------------------------------
 tptp_clause_like(Literal):-
     tptp_literal_formula(Literal,_),
@@ -102,7 +211,6 @@
 tptp_clause_like_formulae([]).
 
 tptp_clause_like_formulae([fof(_,_,Formula)|RestOfFormulae]):-
-write(Formula),nl,
     tptp_clause_like(Formula),
     tptp_clause_like_formulae(RestOfFormulae).
 %------------------------------------------------------------------------------
@@ -122,7 +230,8 @@
 %----Look at formulae one at a time, to avoid extracting all atoms
 %----unnecessarily
     tptp2X_member(AnnotatedFormula,Formulae),
-    extract_atoms_from_formulae([AnnotatedFormula],_,_,Atoms),
+    AnnotatedFormula =.. [fof|_],
+    extract_atoms_from_formulae([AnnotatedFormula],_,_,no,Atoms),
     tptp2X_member(Atom,Atoms),
     Atom =.. [_,_|_],
     !.
@@ -160,6 +269,185 @@
     tptp_normal_formula(FirstFormula),
     tptp_normal_formulae(RestOfFormulae).
 %------------------------------------------------------------------------------
+ensure_typed_variables([],[]).
+
+ensure_typed_variables([Variable|RestOfVariables],[Variable:'$i'|
+RestOfTypedVariables]):-
+    looks_like_a_variable(Variable),
+    !,
+    ensure_typed_variables(RestOfVariables,RestOfTypedVariables).
+
+ensure_typed_variables([Variable:Type|RestOfVariables],[Variable:Type|
+RestOfTypedVariables]):-
+    !,
+    ensure_typed_variables(RestOfVariables,RestOfTypedVariables).
+
+ensure_typed_variables([Variable|_RestOfVariables],[Variable|
+_RestOfTypedVariables]):-
+    write('SHOULD NEVER GET HERE'),nl.
+
+%------------------------------------------------------------------------------
+type_quantified_variables(QuantifiedFormula,FixedQuantified):-
+    tptp_quantified_formula(QuantifiedFormula,Quantifier,Variables,Formula),
+    !,
+    type_quantified_variables(Formula,FixedFormula),
+    ensure_typed_variables(Variables,TypedVariables),
+    tptp_quantified_formula(FixedQuantified,Quantifier,TypedVariables,
+FixedFormula).
+
+type_quantified_variables(BinaryFormula,FixedBinary):-
+    tptp_binary_formula(BinaryFormula,BinaryConnective,LHS,RHS),
+    !,
+    type_quantified_variables(LHS,FixedLHS),
+    type_quantified_variables(RHS,FixedRHS),
+    tptp_binary_formula(FixedBinary,BinaryConnective,FixedLHS,FixedRHS).
+
+type_quantified_variables(UnaryFormula,FixedUnary):-
+    tptp_unary_formula(UnaryFormula,UnaryConnective,Formula),
+    !,
+    type_quantified_variables(Formula,FixedFormula),
+    tptp_unary_formula(FixedUnary,UnaryConnective,FixedFormula).
+
+type_quantified_variables(Formula,Formula).
+%------------------------------------------------------------------------------
+type_tff_variables([],[]).
+
+type_tff_variables([TFFFormula|RestTFFFormulae],[FixedTFFFormula|
+RestFixedTFFFormulae]):-
+    TFFFormula =.. [Form,Name,Role,Logic|Rest],
+    Role \= type,
+    tptp2X_member(Form,[tff,fof]),
+    !,
+    type_quantified_variables(Logic,TypedLogic),
+    FixedTFFFormula =.. [tff,Name,Role,TypedLogic|Rest],
+    type_tff_variables(RestTFFFormulae,RestFixedTFFFormulae).
+
+type_tff_variables([TFFFormula|RestTFFFormulae],[TFFFormula|
+RestFixedTFFFormulae]):-
+    type_tff_variables(RestTFFFormulae,RestFixedTFFFormulae).
+%------------------------------------------------------------------------------
+tptp_xproduct_length(RHS * Atomic,Arity):-
+    atomic(Atomic),
+    !,
+    Arity1 is Arity - 1,
+    tptp_xproduct_length(RHS,Arity1).
+
+tptp_xproduct_length(_,1).
+%------------------------------------------------------------------------------
+tptp_symbol_is_declared(Number,0,_,_):-
+    looks_like_a_number(Number),
+    !.
+
+tptp_symbol_is_declared(Defined,_,_,_):-
+    name(Defined,[36|_]),
+    !.
+
+tptp_symbol_is_declared(Symbol,0,_,TypeDeclarations):-
+    tptp2X_member(tff(_,type,Symbol: '$tType'),TypeDeclarations),
+    !.
+
+tptp_symbol_is_declared(Symbol,0,RequiredResultType,TypeDeclarations):-
+    tptp2X_member(tff(_,type,Symbol: RequiredResultType),TypeDeclarations),
+    !.
+
+tptp_symbol_is_declared(Symbol,Arity,RequiredResultType,TypeDeclarations):-
+    Arity > 0,
+    tptp2X_member(tff(_,type,Symbol: XProduct > RequiredResultType),
+TypeDeclarations),
+    tptp_xproduct_length(XProduct,Arity).
+%------------------------------------------------------------------------------
+tptp_find_undeclared_symbols([],_,_,[]).
+
+tptp_find_undeclared_symbols([Symbol/Arity|RestOfStructures],TypeDeclarations,
+RequiredResultType,UndeclaredStructures):-
+%----Don't let a variable RequiredResultType get instantiated
+    (   nonvar(RequiredResultType)
+   ->   ThisRequiredResultType = RequiredResultType
+    ;   true
+    ),
+    tptp_symbol_is_declared(Symbol,Arity,ThisRequiredResultType,
+TypeDeclarations),
+    !,
+    tptp_find_undeclared_symbols(RestOfStructures,TypeDeclarations,
+RequiredResultType,UndeclaredStructures).
+
+tptp_find_undeclared_symbols([Undeclared|RestOfStructures],TypeDeclarations,
+RequiredResultType,[Undeclared|RestOfUndeclaredStructures]):-
+    tptp_find_undeclared_symbols(RestOfStructures,TypeDeclarations,
+RequiredResultType,RestOfUndeclaredStructures).
+%------------------------------------------------------------------------------
+tptp_make_xproduct(1,ArgumentType,ArgumentType).
+
+tptp_make_xproduct(Arity,ArgumentType,(RestOfXProduct * ArgumentType)):-
+    Arity > 1,
+    Arity1 is Arity - 1,
+    tptp_make_xproduct(Arity1,ArgumentType,RestOfXProduct).
+%------------------------------------------------------------------------------
+tptp_make_type_declarations([],_,_,[]).
+
+tptp_make_type_declarations([Symbol/Arity|RestOfStructures],ArgumentType,
+ResultType,TypeDeclarations):-
+    tptp2X_member(Symbol/Arity,['$tptp_equal'/2]),
+    !,
+    tptp_make_type_declarations(RestOfStructures,ArgumentType,ResultType,
+TypeDeclarations).
+
+tptp_make_type_declarations([Symbol/0|RestOfStructures],ArgumentType,ResultType,
+[tff(Name,type,Symbol:ResultType)|RestOfTypeDeclarations]):-
+    !,
+    concatenate_atoms([Symbol,'_0_',type],Name),
+    tptp_make_type_declarations(RestOfStructures,ArgumentType,ResultType,
+RestOfTypeDeclarations).
+
+tptp_make_type_declarations([Symbol/Arity|RestOfStructures],ArgumentType,
+ResultType,[tff(Name,type,Symbol: XProduct > ResultType)|
+RestOfTypeDeclarations]):-
+    Arity > 0,
+    tptp_make_xproduct(Arity,ArgumentType,XProduct),
+    concatenate_atoms([Symbol,'_',Arity,'_',type],Name),
+%DEBUG write('=== MTD : '),write(tff(Name,type,Symbol: XProduct > ResultType)),nl,
+    tptp_make_type_declarations(RestOfStructures,ArgumentType,ResultType,
+RestOfTypeDeclarations).
+%------------------------------------------------------------------------------
+complete_tff_types(LogicalFormulae,TypeDeclarations,
+CompletedTypeDeclarations):-
+%DEBUG write('--- ITDs : '),write(TypeDeclarations),nl,
+%----Do basic syntactic examination
+    examine_formulae_for_predicates(LogicalFormulae,_,PredicateStructures,_),
+%DEBUG write('--- PSs  : '),write(PredicateStructures),nl,
+    examine_formulae_for_functors(LogicalFormulae,FunctorStructures,_),
+%----Find which are already declared
+    tptp_find_undeclared_symbols(PredicateStructures,TypeDeclarations,'$o',
+UndeclaredPredicateStructures),
+%DEBUG write('--- UPS : '),write(UndeclaredPredicateStructures),nl,
+%----Declare rest as $i and $o
+    tptp_make_type_declarations(UndeclaredPredicateStructures,'$i','$o',
+PredicateTypeDeclarations),
+%DEBUG write('--- PTDs : '),display(PredicateTypeDeclarations),nl,
+    tptp_find_undeclared_symbols(FunctorStructures,TypeDeclarations,_,
+UndeclaredFunctorStructures),
+%DEBUG write('--- UFS : '),write(UndeclaredFunctorStructures),nl,
+    tptp_make_type_declarations(UndeclaredFunctorStructures,'$i','$i',
+FunctorTypeDeclarations),
+%DEBUG write('--- FTDs : '),display(FunctorTypeDeclarations),nl,
+    tptp2X_append(TypeDeclarations,PredicateTypeDeclarations,
+TypeDeclarations1),
+    tptp2X_append(TypeDeclarations1,FunctorTypeDeclarations,
+CompletedTypeDeclarations).
+%------------------------------------------------------------------------------
+tptp_complete_types(Formulae,CompletedTypeDeclarations,
+CompletedLogicalFormulae):-
+    tptp_formulae_language(Formulae,[tff,fof]),
+    !,
+    tptp_separate_formulae_with_role(type,Formulae,TypeDeclarations,
+LogicalFormulae),
+    type_tff_variables(LogicalFormulae,CompletedLogicalFormulae),
+    complete_tff_types(CompletedLogicalFormulae,TypeDeclarations,
+CompletedTypeDeclarations).
+
+%----Need to implement for THF
+tptp_complete_types(Formulae,[],Formulae).
+%------------------------------------------------------------------------------
 %======================================================================
 %----Syntax procedures
 %======================================================================
@@ -224,6 +512,10 @@
     Depth is ArgumentDepth + 1.
 %------------------------------------------------------------------------------
 %----Measure the depth of a formula
+tptp2X_syntax_formula_depth(Variable,1):-
+    looks_like_a_variable(Variable),
+    !.
+
 tptp2X_syntax_formula_depth(QuantifiedFormula,Depth):-
     tptp_quantified_formula(QuantifiedFormula,_,Variables,Formula),
     !,
@@ -245,15 +537,150 @@
     tptp2X_syntax_formula_depth(Formula,FormulaDepth),
     Depth is FormulaDepth + 1.
 
+tptp2X_syntax_formula_depth(TypeOrDefnForm,Depth):-
+    TypeOrDefnForm =.. [Separator,Formula,TypeOrDefn],
+    tptp2X_member(Separator,[':',':=']),
+    !,
+    tptp2X_syntax_formula_depth(Formula,LHSDepth),
+    tptp2X_syntax_formula_depth(TypeOrDefn,RHSDepth),
+    tptp2X_choose_maximum(LHSDepth,RHSDepth,ANYDepth),
+    Depth is ANYDepth + 1.
+
 tptp2X_syntax_formula_depth(AtomicFormula,1):-
-    tptp_atomic_formula(AtomicFormula).
+    tptp_atomic_formula(AtomicFormula),
+    !.
+
+%----Only delve into equations (THF), not equalities (FOF, CNF)
+tptp2X_syntax_formula_depth('$tptp_equal'(LHS,RHS),Depth):-
+    !,
+    tptp2X_syntax_formula_depth(LHS,LHSDepth),
+    tptp2X_syntax_formula_depth(RHS,RHSDepth),
+    tptp2X_choose_maximum(LHSDepth,RHSDepth,ANYSideDepth),
+    Depth is ANYSideDepth + 1.
+
+tptp2X_syntax_formula_depth('$tptp_not_equal'(LHS,RHS),Depth):-
+    !,
+    tptp2X_syntax_formula_depth(~ '$tptp_equal'(LHS,RHS),Depth).
+%------------------------------------------------------------------------------
+count_formula_list_connectives([],
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]).
+
+count_formula_list_connectives([Formula|RestOfFormulae],CountVector):-
+    count_formula_connectives(Formula,FirstVector),
+    count_formula_list_connectives(RestOfFormulae,RestVector),
+    tptp2X_list_add(FirstVector,RestVector,CountVector).
 %------------------------------------------------------------------------------
 %----Count the number of occurences of each type of connective in a
 %----formula
+%DEBUG count_formula_connectives(Formula,_):-write('CFC--- '),display(Formula),nl,fail.
+
+%----Catch variables (for THF case) and atomic formulae early
+count_formula_connectives(Variable,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]):-
+    looks_like_a_variable(Variable),
+    !.
+
+count_formula_connectives(Atomic,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]):-
+    atomic(Atomic),
+    !.
+
+%----Type declaration - catch before quantified
+%----Global type - RHS only, and count type declartions
+count_formula_connectives(Symbol : Type,CountVector):-
+%----Non-var looks like !
+    atomic(Symbol),
+    !,
+    count_formula_connectives(Type,TypeCountVector),
+    tptp2X_list_add(TypeCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
+CountVector).
+
+%----Variable type - RHS only, and count typed variables
+count_formula_connectives(Symbol : Type,CountVector):-
+    var(Symbol),
+    !,
+    count_formula_connectives(Type,TypeCountVector),
+    tptp2X_list_add(TypeCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],
+CountVector).
+
+%----Map arrows 
+count_formula_connectives(LHS > RHS,CountVector):-
+    !,
+    count_formula_connectives(LHS,LHSCountVector),
+    count_formula_connectives(RHS,RHSCountVector),
+    tptp2X_list_add(LHSCountVector,RHSCountVector,LocalCountVector),
+    tptp2X_list_add(LocalCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
+CountVector).
+
+%----X product
+count_formula_connectives(LHS * RHS,CountVector):-
+    !,
+    count_formula_connectives(LHS,LHSCountVector),
+    count_formula_connectives(RHS,RHSCountVector),
+    tptp2X_list_add(LHSCountVector,RHSCountVector,LocalCountVector),
+    tptp2X_list_add(LocalCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
+CountVector).
+
+%----Union
+count_formula_connectives(LHS + RHS,CountVector):-
+    !,
+    count_formula_connectives(LHS,LHSCountVector),
+    count_formula_connectives(RHS,RHSCountVector),
+    tptp2X_list_add(LHSCountVector,RHSCountVector,LocalCountVector),
+    tptp2X_list_add(LocalCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
+CountVector).
+
+%----Subtype
+count_formula_connectives(_ << _,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]):-
+    !.
+
+%----Global defn - RHS only, and count global definitions
+count_formula_connectives(Symbol := Defn,CountVector):-
+    atomic(Symbol),
+    !,
+    count_formula_connectives(Defn,DefnCountVector),
+    tptp2X_list_add(DefnCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
+CountVector).
+
+%----Variable defn - RHS only, and count nothing. Note TypedVariable may have
+%----its own RHS, which will be done above. Count of variable defns is done
+%----in letrec below.
+count_formula_connectives(TypedVariable := Defn,CountVector):-
+    !,
+    count_formula_connectives(TypedVariable,TypedVariableCountVector),
+    count_formula_connectives(Defn,DefnCountVector),
+    tptp2X_list_add(TypedVariableCountVector,DefnCountVector,CountVector).
+
 %----NOT
 count_formula_connectives(~ Formula,CountVector):-
+    !,
     count_formula_connectives(Formula,FormulaCountVector),
-    tptp2X_list_add(FormulaCountVector,[1,0,0,0,0,0,0,0,0,0,0],CountVector).
+    tptp2X_list_add(FormulaCountVector,
+[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
+
+%----Pi
+count_formula_connectives('!!' Formula,CountVector):-
+    !,
+    count_formula_connectives(Formula,FormulaCountVector),
+    tptp2X_list_add(FormulaCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],
+CountVector).
+
+%----Sigma
+count_formula_connectives('??' Formula,CountVector):-
+    !,
+    count_formula_connectives(Formula,FormulaCountVector),
+    tptp2X_list_add(FormulaCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
+CountVector).
 
 %----OR
 count_formula_connectives(';'(LHS,RHS),CountVector):-
@@ -262,92 +689,176 @@
     count_formula_connectives(LHS,LHSCountVector),
     count_formula_connectives(RHS,RHSCountVector),
     tptp2X_list_add(LHSCountVector,RHSCountVector,ORCountVector),
-    tptp2X_list_add(ORCountVector,[0,1,0,0,0,0,0,0,0,0,0],CountVector).
+    tptp2X_list_add(ORCountVector,
+[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
 
 %----|;BUG
 count_formula_connectives('|'(LHS,RHS),CountVector):-
+    !,
     count_formula_connectives(LHS,LHSCountVector),
     count_formula_connectives(RHS,RHSCountVector),
     tptp2X_list_add(LHSCountVector,RHSCountVector,ORCountVector),
-    tptp2X_list_add(ORCountVector,[0,1,0,0,0,0,0,0,0,0,0],CountVector).
+    tptp2X_list_add(ORCountVector,
+[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
 
 %----AND
 count_formula_connectives(LHS & RHS,CountVector):-
+    !,
     count_formula_connectives(LHS,LHSCountVector),
     count_formula_connectives(RHS,RHSCountVector),
     tptp2X_list_add(LHSCountVector,RHSCountVector,ANDCountVector),
-    tptp2X_list_add(ANDCountVector,[0,0,1,0,0,0,0,0,0,0,0],CountVector).
+    tptp2X_list_add(ANDCountVector,
+[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
 
 %----IMPLY
 count_formula_connectives(LHS => RHS,CountVector):-
+    !,
     count_formula_connectives(LHS,LHSCountVector),
     count_formula_connectives(RHS,RHSCountVector),
     tptp2X_list_add(LHSCountVector,RHSCountVector,IMPLYCountVector),
-    tptp2X_list_add(IMPLYCountVector,[0,0,0,1,0,0,0,0,0,0,0],CountVector).
+    tptp2X_list_add(IMPLYCountVector,
+[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
 
 %----IMPLIED
 count_formula_connectives(LHS <= RHS,CountVector):-
+    !,
     count_formula_connectives(LHS,LHSCountVector),
     count_formula_connectives(RHS,RHSCountVector),
     tptp2X_list_add(LHSCountVector,RHSCountVector,IMPLIEDCountVector),
-    tptp2X_list_add(IMPLIEDCountVector,[0,0,0,0,1,0,0,0,0,0,0],CountVector).
+    tptp2X_list_add(IMPLIEDCountVector,
+[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
 
 %----EQUIV
 count_formula_connectives(LHS <=> RHS,CountVector):-
+    !,
     count_formula_connectives(LHS,LHSCountVector),
     count_formula_connectives(RHS,RHSCountVector),
     tptp2X_list_add(LHSCountVector,RHSCountVector,EQUIVCountVector),
-    tptp2X_list_add(EQUIVCountVector,[0,0,0,0,0,1,0,0,0,0,0],CountVector).
+    tptp2X_list_add(EQUIVCountVector,
+[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
 
 %----XOR
 count_formula_connectives(LHS <~> RHS,CountVector):-
+    !,
     count_formula_connectives(LHS,LHSCountVector),
     count_formula_connectives(RHS,RHSCountVector),
     tptp2X_list_add(LHSCountVector,RHSCountVector,XORCountVector),
-    tptp2X_list_add(XORCountVector,[0,0,0,0,0,0,1,0,0,0,0],CountVector).
+    tptp2X_list_add(XORCountVector,
+[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
 
 %----NOR
 count_formula_connectives(LHS '~|' RHS,CountVector):-
+    !,
     count_formula_connectives(LHS,LHSCountVector),
     count_formula_connectives(RHS,RHSCountVector),
     tptp2X_list_add(LHSCountVector,RHSCountVector,NORCountVector),
-    tptp2X_list_add(NORCountVector,[0,0,0,0,0,0,0,1,0,0,0],CountVector).
+    tptp2X_list_add(NORCountVector,
+[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
 
 %----NAND
 count_formula_connectives(LHS ~& RHS,CountVector):-
+    !,
     count_formula_connectives(LHS,LHSCountVector),
     count_formula_connectives(RHS,RHSCountVector),
     tptp2X_list_add(LHSCountVector,RHSCountVector,NANDCountVector),
-    tptp2X_list_add(NANDCountVector,[0,0,0,0,0,0,0,0,1,0,0],CountVector).
+    tptp2X_list_add(NANDCountVector,
+[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
+
+%----Applys
+count_formula_connectives(@(LHS,RHS),CountVector):-
+    !,
+    count_formula_connectives(LHS,LHSCountVector),
+    count_formula_connectives(RHS,RHSCountVector),
+    tptp2X_list_add(LHSCountVector,RHSCountVector,ANDCountVector),
+    tptp2X_list_add(ANDCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
 
 %----Universals
 count_formula_connectives(! Variables : Formula,CountVector):-
-    count_formula_connectives(Formula,FormulaCountVector),
+    !,
     tptp2X_length(Variables,NumberOfVariables),
-    tptp2X_list_add(FormulaCountVector,[0,0,0,0,0,0,0,0,0,NumberOfVariables,0],
+    count_formula_list_connectives(Variables,VariablesCountVector),
+    count_formula_connectives(Formula,FormulaCountVector),
+    tptp2X_list_add(VariablesCountVector,FormulaCountVector,LocalCountVector),
+    tptp2X_list_add(LocalCountVector,
+[0,0,0,0,0,0,0,0,0,NumberOfVariables,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 CountVector).
 
 %----Existentials
 count_formula_connectives(? Variables : Formula,CountVector):-
-    count_formula_connectives(Formula,FormulaCountVector),
+    !,
     tptp2X_length(Variables,NumberOfVariables),
-    tptp2X_list_add(FormulaCountVector,[0,0,0,0,0,0,0,0,0,0,NumberOfVariables],
+    count_formula_list_connectives(Variables,VariablesCountVector),
+    count_formula_connectives(Formula,FormulaCountVector),
+    tptp2X_list_add(VariablesCountVector,FormulaCountVector,LocalCountVector),
+    tptp2X_list_add(LocalCountVector,
+[0,0,0,0,0,0,0,0,0,0,NumberOfVariables,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 CountVector).
 
 %----Lambdas 
 count_formula_connectives(^ Variables : Formula,CountVector):-
+    !,
+    tptp2X_length(Variables,NumberOfVariables),
+    count_formula_list_connectives(Variables,VariablesCountVector),
     count_formula_connectives(Formula,FormulaCountVector),
+    tptp2X_list_add(VariablesCountVector,FormulaCountVector,LocalCountVector),
+    tptp2X_list_add(LocalCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,NumberOfVariables,0,0,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
+
+%----PI 
+count_formula_connectives('!>' Variables : Formula,CountVector):-
+    !,
     tptp2X_length(Variables,NumberOfVariables),
-    tptp2X_list_add(FormulaCountVector,[0,0,0,0,0,0,0,0,0,0,NumberOfVariables],
+    count_formula_list_connectives(Variables,VariablesCountVector),
+    count_formula_connectives(Formula,FormulaCountVector),
+    tptp2X_list_add(VariablesCountVector,FormulaCountVector,LocalCountVector),
+    tptp2X_list_add(LocalCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,NumberOfVariables,0,0,0,0,0,0,0],
 CountVector).
 
-%----Atomic formulae
-count_formula_connectives(Atom,[0,0,0,0,0,0,0,0,0,0,0]):-
-    tptp_atomic_formula(Atom).
+%----SIGMA 
+count_formula_connectives('?*' Variables : Formula,CountVector):-
+    !,
+    tptp2X_length(Variables,NumberOfVariables),
+    count_formula_list_connectives(Variables,VariablesCountVector),
+    count_formula_connectives(Formula,FormulaCountVector),
+    tptp2X_list_add(VariablesCountVector,FormulaCountVector,LocalCountVector),
+    tptp2X_list_add(LocalCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,NumberOfVariables,0,0,0,0,0,0],
+CountVector).
+
+%----Letrec
+count_formula_connectives(:= (Variables : Formula),CountVector):-
+    !,
+    tptp2X_length(Variables,NumberOfVariables),
+    count_formula_list_connectives(Variables,VariablesCountVector),
+    count_formula_connectives(Formula,FormulaCountVector),
+    tptp2X_list_add(VariablesCountVector,FormulaCountVector,LocalCountVector),
+    tptp2X_list_add(LocalCountVector,
+[0,0,0,0,0,0,0,0,0,0,0,0,0,NumberOfVariables,0,0,0,0,0,0,0,0,0,0,0],
+CountVector).
+
+%----THF atoms can have formulae inside
+count_formula_connectives(Atom,CountVector):-
+    Atom =.. [_|Arguments],
+    count_formula_list_connectives(Arguments,CountVector).
+
 %------------------------------------------------------------------------------
 %----Count the number of occurences of each type of connective in a
 %----list of formulae
-count_formulae_connectives([],[0,0,0,0,0,0,0,0,0,0,0]).
+count_formulae_connectives([],
+[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]).
 
 count_formulae_connectives([AnnotatedFormula|RestOfFormulae],CountVector):-
     AnnotatedFormula =.. [_,_,_,FirstFormula|_],
@@ -355,9 +866,9 @@
     count_formulae_connectives(RestOfFormulae,RestVector),
     tptp2X_list_add(FirstVector,RestVector,CountVector).
 %------------------------------------------------------------------------------
-%======================================================================
+%==============================================================================
 %----Pulling clauses apart code
-%======================================================================
+%==============================================================================
 %------------------------------------------------------------------------------
 %----Extract all the arguments from the literals
 extract_arguments_from_literals([],[]):-
@@ -369,14 +880,15 @@
     Atom =.. [_|ArgumentList],
     tptp2X_append(ArgumentList,RestOfArguments,Arguments).
 %------------------------------------------------------------------------------
-%----Extract all the arguments from atoms
-extract_arguments_from_atoms([],[]):-
-    !.
-
-extract_arguments_from_atoms([FirstAtom|RestOfAtoms],Arguments):-
-    extract_arguments_from_atoms(RestOfAtoms,RestOfArguments),
-    FirstAtom =.. [_|ArgumentList],
-    tptp2X_append(ArgumentList,RestOfArguments,Arguments).
+%----Extract all the function arguments from atoms. Avoid nested formulae
+%----which can occur in THF case.
+extract_arguments_from_atoms(Atoms,Arguments):-
+    findall(Argument,
+        (   tptp2X_member(Atom,Atoms),
+            Atom =.. [_|ArgumentList],
+            tptp2X_member(Argument,ArgumentList),
+            tptp_atomic_formula(Argument)
+        ),Arguments).
 %------------------------------------------------------------------------------
 %----Filter a list of literals for those with certain properties
 filter_literals([],_,_,_,[]).
@@ -386,7 +898,9 @@
 [FirstLiteral|RestOfFilteredLiterals]):-
 %----Verify to avoid instantiations if variables
     \+ \+ (FirstLiteral =.. [Sign,Atom],
-           \+ (Atom = $_),
+%----Avoid reserved predicates
+           \+ (atom(Atom),
+               name(Atom,[36|_])),
            functor(Atom,PredicateSymbol,Arity)),
     !,
     filter_literals(RestOfLiterals,Sign,PredicateSymbol,Arity,
@@ -409,47 +923,133 @@
 RestOfFilteredLiterals),
     tptp2X_append(FilteredLiterals,RestOfFilteredLiterals,Literals).
 %------------------------------------------------------------------------------
+extract_atom_from_type(BinaryType,Type):-
+    BinaryType =.. [TypeConnective,LHS,RHS],
+    tptp_type_binary_connective(TypeConnective),
+    !,
+    (   extract_atom_from_type(LHS,Type)
+    ;   extract_atom_from_type(RHS,Type)
+    ).
+
+extract_atom_from_type(FormulaType,Type):-
+    tptp_non_atomic_formula(FormulaType),
+    extract_atom_from_formula(FormulaType,no,Type).
+%------------------------------------------------------------------------------
 %----Given a formula, extract an atom
-extract_atom_from_formula(QuantifiedFormula,Atom):-
+%DEBUG extract_atom_from_formula(Something,_,_):-write('EAFF--- '),write(Something),nl,fail.
+
+extract_atom_from_formula(Variable,no,_):-
+    looks_like_a_variable(Variable),
+    !,
+    fail.
+
+extract_atom_from_formula(Variable,yes,Variable):-
+    looks_like_a_variable(Variable),
+    !.
+
+%----Lists for tuples in THF
+extract_atom_from_formula([First|Rest],THFAtoms,Atom):-
+    !,
+    tptp2X_member(Term,[First|Rest]),
+    extract_atom_from_formula(Term,THFAtoms,Atom).
+
+%----Look in variable lists for typed and defined stuff
+extract_atom_from_formula(QuantifiedFormula,THFAtoms,Atom):-
+    tptp_quantified_formula(QuantifiedFormula,_,Variables,_),
+    extract_atom_from_formula(Variables,THFAtoms,Atom).
+
+extract_atom_from_formula(QuantifiedFormula,THFAtoms,Atom):-
     tptp_quantified_formula(QuantifiedFormula,_,_,Formula),
     !,
-    extract_atom_from_formula(Formula,Atom).
+    extract_atom_from_formula(Formula,THFAtoms,Atom).
 
-extract_atom_from_formula(BinaryFormula,Atom):-
+extract_atom_from_formula(BinaryFormula,THFAtoms,Atom):-
     tptp_binary_formula(BinaryFormula,_,LHS,_),
-%----Cannot cut here as this is backtracked over in 
-%----extract_atoms_from_formulae
-    extract_atom_from_formula(LHS,Atom).
+%----Cannot cut here as this is backtracked over in extract_atoms_from_formulae
+    extract_atom_from_formula(LHS,THFAtoms,Atom).
 
-extract_atom_from_formula(BinaryFormula,Atom):-
+extract_atom_from_formula(BinaryFormula,THFAtoms,Atom):-
     tptp_binary_formula(BinaryFormula,_,_,RHS),
     !,
-    extract_atom_from_formula(RHS,Atom).
+    extract_atom_from_formula(RHS,THFAtoms,Atom).
 
-extract_atom_from_formula(UnaryFormula,Atom):-
+extract_atom_from_formula(UnaryFormula,THFAtoms,Atom):-
     tptp_unary_formula(UnaryFormula,_,Formula),
     !,
-    extract_atom_from_formula(Formula,Atom).
+    extract_atom_from_formula(Formula,THFAtoms,Atom).
+
+%----Do not do subtypes
+extract_atom_from_formula(_ << _,_,_):-
+    !,
+    fail.
+
+%----Do not do LHS of types
+extract_atom_from_formula(Formula:_,THFAtoms,Atom):-
+    fail,
+    extract_atom_from_formula(Formula,THFAtoms,Atom).
+
+extract_atom_from_formula(_:Type,THFAtoms,Atom):-
+    !,
+    extract_atom_from_formula(Type,THFAtoms,Atom).
+
+%----Do not do LHS of definitions (variable and global constant)
+extract_atom_from_formula(Formula:=_,THFAtoms,Atom):-
+    fail,
+    extract_atom_from_formula(Formula,THFAtoms,Atom).
+
+extract_atom_from_formula(_:=Definition,THFAtoms,Atom):-
+    !,
+    extract_atom_from_formula(Definition,THFAtoms,Atom).
+
+%----!= are unary
+extract_atom_from_formula('$tptp_not_equal'(LHS,RHS),THFAtoms,Atom):-
+    extract_atom_from_formula('$tptp_equal'(LHS,RHS),THFAtoms,Atom).
+
+%----Equalities are atoms in FOF mode, and fake in THF mode
+extract_atom_from_formula('$tptp_equal'(LHS,RHS),_,'$tptp_equal'(LHS,RHS)).
+
+%----Equalities are not atoms in THF mode
+extract_atom_from_formula('$tptp_equal'(LHS,_),yes,Atom):-
+    extract_atom_from_formula(LHS,yes,Atom).
+
+extract_atom_from_formula('$tptp_equal'(_,RHS),yes,Atom):-
+    !,
+    extract_atom_from_formula(RHS,yes,Atom).
+
+extract_atom_from_formula(Atom,_,Atom):-
+    Atom \= '$tptp_equal'(_,_),
+    tptp_atomic_formula(Atom).
 
-extract_atom_from_formula(Atom,Atom):-
-    tptp_atomic_formula(Atom),
-    \+ (Atom = $_).
+%----Delve into arguments in THF mode
+extract_atom_from_formula(AtomWithFormulaArgs,yes,Atom):-
+    AtomWithFormulaArgs =.. [_|Arguments],
+    tptp2X_member(Argument,Arguments),
+    extract_atom_from_formula(Argument,yes,Atom).
+%------------------------------------------------------------------------------
+filter_atoms_from_formulae(Atom,_,0):-
+    looks_like_a_variable(Atom).
+
+filter_atoms_from_formulae(Atom,PredicateSymbol,Arity):-
+    \+ looks_like_a_variable(Atom),
+    functor(Atom,PredicateSymbol,Arity).
 %------------------------------------------------------------------------------
 %----Extract all the atoms from the formulae, subject to the predicate 
 %----symbol and arity.
-extract_atoms_from_formulae(Formulae,PredicateSymbol,Arity,Atoms):-
+extract_atoms_from_formulae(Formulae,PredicateSymbol,Arity,THFAtoms,Atoms):-
     findall(Atom,
         (   tptp2X_member(AnnotatedFormula,Formulae),
-            AnnotatedFormula =.. [Language,_,_,Formula|_],
-            tptp2X_member(Language,[cnf,fof]),
-            extract_atom_from_formula(Formula,Atom),
-            functor(Atom,PredicateSymbol,Arity)),
+%DEBUG write('EAFF--- '),write(AnnotatedFormula),nl,
+            AnnotatedFormula =.. [_,_,_,Formula|_],
+%DEBUG write('EAFF-F--- '),write(Formula),nl,
+            extract_atom_from_formula(Formula,THFAtoms,Atom),
+%DEBUG write('EAFF-A--- '),write(Atom),nl,
+            filter_atoms_from_formulae(Atom,PredicateSymbol,Arity)),
         Atoms).
 %------------------------------------------------------------------------------
 %----Get the functor details of a term
 %----Integer term
-extract_typed_functor_structure(Integer,Integer/0):-
-    integer(Integer),
+extract_typed_functor_structure(Number,Number/0):-
+    looks_like_a_number(Number),
     !.
 
 %----Function term
@@ -463,20 +1063,57 @@
 %----Get functor details from these terms
     extract_functor_structure(FunctionArguments,FunctorStructure).
 %------------------------------------------------------------------------------
-%----Check that a term looks like a variable
-looks_like_a_variable(Variable):-
+looks_like_a_number(Integer):-
+    integer(Integer),
+    !.
+
+looks_like_a_number(Numerator/Denominator):-
+    integer(Numerator),
+    integer(Denominator),
+    !.
+
+%----Only in Eclipse I think
+looks_like_a_number(Real):-
+    number(Real).
+%------------------------------------------------------------------------------
+%----A list of ASCII codes looks like a string to me
+looks_like_a_string([Integer]):-
+    integer(Integer).
+
+looks_like_a_string([Integer|RestOfIntegers]):-
+    integer(Integer),
+    looks_like_a_string(RestOfIntegers).
+%------------------------------------------------------------------------------
+looks_like_a_prolog_variable(Variable):-
     var(Variable).
 
-looks_like_a_variable(Something):-
+looks_like_a_prolog_variable(Something):-
     nonvar(Something),
     Something =.. ['$VAR',_].
+%------------------------------------------------------------------------------
+%----Check that a term looks like a variable
+looks_like_a_variable(Variable):-
+    looks_like_a_prolog_variable(Variable).
 
 looks_like_a_variable(AtomVariable):-
     nonvar(AtomVariable),
     atom(AtomVariable),
-    name(AtomVariable,[FirstASCII|_]),
+    name(AtomVariable,[FirstASCII|RestASCII]),
     FirstASCII >= 65,
-    FirstASCII =< 90.
+    FirstASCII =< 90,
+%----All alphanumeric
+    \+ (tptp2X_member(NastyASCII,RestASCII),
+        \+ (   NastyASCII >= 65,
+               NastyASCII =< 90
+           ),
+        \+ (   NastyASCII >= 97,
+               NastyASCII =< 122
+           ),
+        \+ (   NastyASCII >= 48,
+               NastyASCII =< 57
+           ),
+        NastyASCII \== 95
+    ).
 %------------------------------------------------------------------------------
 %----Extract any functor structure from a list of terms
 extract_functor_structure(Terms,FunctorStructure):-
@@ -499,6 +1136,8 @@
 %----Given a list of atoms, make unsigned structure
 extract_unsigned_structure_from_atoms(Atoms,Symbol/Arity):-
     tptp2X_member(Atom,Atoms),
+%----Exclude variable atoms from THF case
+    \+ looks_like_a_variable(Atom),
     functor(Atom,Symbol,Arity).
 %------------------------------------------------------------------------------
 %----Collect all predicate symbols
@@ -523,14 +1162,32 @@
         tptp2X_member(PredicateSymbol/_,UnsignedPredicateStructures),
         PredicateSymbols).
 
-%----FOF case
-examine_formulae_for_predicates(Formulae,[],UnsignedPredicateStructures,
-PredicateSymbols):-
-    tptp_formulae(Formulae),
-    extract_atoms_from_formulae(Formulae,_,_,Atoms),
+%----FOF and TFF case
+examine_formulae_for_predicates(AnnotatedFormulae,[],
+UnsignedPredicateStructures,PredicateSymbols):-
+    (   tptp_formulae_language(AnnotatedFormulae,[fof])
+    ;   tptp_formulae_language(AnnotatedFormulae,[tff])
+    ),
+    extract_atoms_from_formulae(AnnotatedFormulae,_,_,no,Atoms),
+%DEBUG write('EFFP Atoms--- '),write(Atoms),nl,
     tptp2X_findall_setof1(UnsignedStructure,
         extract_unsigned_structure_from_atoms(Atoms,UnsignedStructure),
         UnsignedPredicateStructures),
+%DEBUG write('EFFP UPS--- '),write(UnsignedPredicateStructures),nl,
+    tptp2X_findall_setof1(PredicateSymbol,
+        tptp2X_member(PredicateSymbol/_,UnsignedPredicateStructures),
+        PredicateSymbols).
+
+%----THF case
+examine_formulae_for_predicates(AnnotatedFormulae,[],
+UnsignedPredicateStructures,PredicateSymbols):-
+    tptp_formulae_language(AnnotatedFormulae,[thf]),
+    extract_atoms_from_formulae(AnnotatedFormulae,_,_,yes,Atoms),
+%DEBUG write('EFFP Atoms--- '),write(Atoms),nl,
+    tptp2X_findall_setof1(UnsignedStructure,
+        extract_unsigned_structure_from_atoms(Atoms,UnsignedStructure),
+        UnsignedPredicateStructures),
+%DEBUG write('EFFP UPS--- '),write(UnsignedPredicateStructures),nl,
     tptp2X_findall_setof1(PredicateSymbol,
         tptp2X_member(PredicateSymbol/_,UnsignedPredicateStructures),
         PredicateSymbols).
@@ -550,19 +1207,142 @@
     tptp2X_findall_setof1(Functor,tptp2X_member(Functor/_,
 FunctorStructures),Functors).
 
-%----FOF case
-examine_formulae_for_functors(Formulae,FunctorStructures,Functors):-
-    tptp_formulae(Formulae),
-    extract_atoms_from_formulae(Formulae,_,_,Atoms),
+%----FOF and THF case
+examine_formulae_for_functors(AnnotatedFormulae,FunctorStructures,Functors):-
+    tptp_formulae(AnnotatedFormulae),
+    extract_atoms_from_formulae(AnnotatedFormulae,_,_,no,Atoms),
+%DEBUG write('EFFF--- '),write(Atoms),nl,
     extract_arguments_from_atoms(Atoms,Arguments),
+%DEBUG write('EFFFArgs '),write(Arguments),nl,
     tptp2X_findall_setof1(FunctorStructure,extract_functor_structure(
 Arguments,FunctorStructure),FunctorStructures),
+%DEBUG write('EFFFFSs '),write(FunctorStructures),nl,
     tptp2X_findall_setof1(Functor,tptp2X_member(Functor/_,
 FunctorStructures),Functors).
 %------------------------------------------------------------------------------
-%======================================================================
+examine_formulae_for_symbols(Formulae,SymbolStructures,Symbols):-
+    examine_formulae_for_predicates(Formulae,_,UnsignedPredicateStructures,
+PredicateSymbols),
+    examine_formulae_for_functors(Formulae,FunctorStructures,Functors),
+    tptp2X_append(UnsignedPredicateStructures,FunctorStructures,
+AllSymbolStructures),
+    tptp2X_setof1(SymbolStructure,tptp2X_member(SymbolStructure,
+AllSymbolStructures),SymbolStructures),
+    tptp2X_append(PredicateSymbols,Functors,AllSymbols),
+    tptp2X_setof1(Symbol,tptp2X_member(Symbol,AllSymbols),Symbols).
+%------------------------------------------------------------------------------
+extract_type_from_type(BinaryType,Type):-
+    BinaryType =.. [TypeConnective,LHS,RHS],
+    tptp_type_binary_connective(TypeConnective),
+    !,
+    (   extract_type_from_type(LHS,Type)
+    ;   extract_type_from_type(RHS,Type)
+    ).
+
+extract_type_from_type(AtomicType,AtomicType):-
+    tptp_atomic_formula(AtomicType),
+    !.
+
+extract_type_from_type(FormulaType,Type):-
+    tptp_non_atomic_formula(FormulaType),
+    extract_type_from_formula(FormulaType,Type).
+%------------------------------------------------------------------------------
+%DEBUG extract_type_from_formula(Formula,_):-write('ETFF--- '),display(Formula),nl.
+
+%----Given a formula, extract an atom
+extract_type_from_formula(Variable,_):-
+    looks_like_a_variable(Variable),
+    !,
+    fail.
+
+extract_type_from_formula([First|Rest],Type):-
+    !,
+    tptp2X_member(ListElement,[First|Rest]),
+    extract_type_from_formula(ListElement,Type).
+
+extract_type_from_formula(QuantifiedFormula,Type):-
+    tptp_quantified_formula(QuantifiedFormula,_,_,Formula),
+%----Cannot cut here as this is backtracked over in examine_formulae_for_types
+    extract_type_from_formula(Formula,Type).
+
+%----Look in the variable list
+extract_type_from_formula(QuantifiedFormula,Atom):-
+    tptp_quantified_formula(QuantifiedFormula,_,TypedVariables,_),
+    !,
+    extract_type_from_formula(TypedVariables,Atom).
+
+extract_type_from_formula(BinaryFormula,Atom):-
+    tptp_binary_formula(BinaryFormula,_,LHS,_),
+%----Cannot cut here as this is backtracked over in examine_formulae_for_types
+    extract_type_from_formula(LHS,Atom).
+
+extract_type_from_formula(BinaryFormula,Atom):-
+    tptp_binary_formula(BinaryFormula,_,_,RHS),
+    !,
+    extract_type_from_formula(RHS,Atom).
+
+extract_type_from_formula(UnaryFormula,Atom):-
+    tptp_unary_formula(UnaryFormula,_,Formula),
+    !,
+    extract_type_from_formula(Formula,Atom).
+
+%----Aha! A type. Take it, and look inside it.
+extract_type_from_formula(_:ItsType,ItsType).
+%DEBUG write('ETFF found--- '),write(ItsType),nl.
+
+extract_type_from_formula(_:ItsType,Type):-
+    tptp_non_atomic_formula(ItsType),
+    !,
+    extract_type_from_type(ItsType,Type).
+
+extract_type_from_formula(Formula:_,Type):-
+    tptp_non_atomic_formula(Formula),
+    !,
+    extract_type_from_formula(Formula,Type).
+
+extract_type_from_formula(_:=_,_):-
+    !,
+    fail.
+
+extract_type_from_formula(Atom,Atom):-
+    tptp_atomic_formula(Atom).
+%DEBUG write('ETFF atomic--- '),write(Atom),nl.
+%------------------------------------------------------------------------------
+extract_type_from_thf_formulae(AnnotatedFormulae,Type):-
+    tptp2X_member(AnnotatedTHF,AnnotatedFormulae),
+    AnnotatedTHF =.. [thf,_,_,Formula|_],
+    extract_type_from_formula(Formula,Type).
+%------------------------------------------------------------------------------
+extract_atomic_type(ComplexTypes,AtomicType):-
+    tptp2X_member(AtomicType,ComplexTypes),
+    atomic(AtomicType).
+%------------------------------------------------------------------------------
+%----Collect all types
+%----Empty case
+examine_formulae_for_types([],[],[]):-
+    !.
+
+%----CNF case
+examine_formulae_for_types(Clauses,[],[]):-
+    tptp_clauses(Clauses).
+
+%----Formula case
+examine_formulae_for_types(AnnotatedFormulae,ComplexTypes,AtomicTypes):-
+    tptp_formulae(AnnotatedFormulae),
+    tptp2X_findall_setof1(ComplexType,extract_type_from_thf_formulae(
+AnnotatedFormulae,ComplexType),ComplexTypes),
+    tptp2X_setof1(AtomicType,extract_atomic_type(ComplexTypes,AtomicType),
+AtomicTypes).
+%------------------------------------------------------------------------------
+examine_formulae_for_definitions(AnnotatedFormulae,DefinedSymbols):-
+    findall(DefinedSymbol,
+        (   tptp2X_member(AnnotatedTHF,AnnotatedFormulae),
+            AnnotatedTHF =.. [thf,_,definition,DefinedSymbol:=_|_]
+        ),DefinedSymbols).
+%------------------------------------------------------------------------------
+%==============================================================================
 %----Syntactic examination code
-%======================================================================
+%==============================================================================
 %------------------------------------------------------------------------------
 %----Count the number of structures with a given arity
 count_structures_of_arity([],_,0):-
@@ -654,7 +1434,7 @@
 %----FOF case
 extract_arguments_of_atoms(Formulae,Arguments):-
     tptp_formulae(Formulae),
-    extract_atoms_from_formulae(Formulae,_,_,Atoms),
+    extract_atoms_from_formulae(Formulae,_,_,no,Atoms),
     extract_arguments_from_atoms(Atoms,Arguments).
 %------------------------------------------------------------------------------
 %----Look for the maximum depth of any term (CNF and FOF)
@@ -669,6 +1449,101 @@
     tptp2X_maximal_in_list(AllDepths,MaximalTermDepth),
     tptp2X_arithmetic_average(AllDepths,AverageTermDepth).
 %------------------------------------------------------------------------------
+count_math_functions(FunctorStructures,NumberOfMathFunctions):-
+    findall(MathFunction,
+        (   tptp2X_member(MathFunction,[
+'$uminus'/1,
+'$sum'/2,
+'$difference'/2,
+'$product'/2,
+'$to_int'/1,
+'$to_rat'/1,
+'$to_real'/1]),
+            tptp2X_member(MathFunction,FunctorStructures)
+        ),
+        AllMathFunctions),
+    tptp2X_length(AllMathFunctions,NumberOfMathFunctions).
+%------------------------------------------------------------------------------
+count_math_predicates(PredicateStructures,NumberOfMathPredicates):-
+    findall(MathPredicate,
+        (   tptp2X_member(MathPredicate,[
+'$less'/2,
+'$lesseq'/2,
+'$greater'/2,
+'$greatereq'/2,
+'$evaleq'/2,
+'$is_int'/1,
+'$is_rat'/1]),
+            tptp2X_member(MathPredicate,PredicateStructures)
+        ),
+        AllMathPredicates),
+    tptp2X_length(AllMathPredicates,NumberOfMathPredicates).
+%------------------------------------------------------------------------------
+count_math_numbers(FunctorStructures,NumberOfNumbers):-
+    findall(Number,
+        (   tptp2X_member(Number/0,FunctorStructures),
+            looks_like_a_number(Number)
+        ),
+        AllNumbers),
+    tptp2X_length(AllNumbers,NumberOfNumbers).
+%------------------------------------------------------------------------------
+count_mathematics(AnnotatedClauses,NumberOfArithmeticSymbols,
+NumberOfMathPredicates,NumberOfMathFunctions,NumberOfNumbers):-
+    tptp_clauses(AnnotatedClauses),
+    !,
+    extract_literals_from_clauses(AnnotatedClauses,_,_,_,Literals),
+    findall(Structure,
+        extract_signed_structure_from_literals(Literals,Structure),
+        PredicateStructures),
+    tptp2X_setof1(UnsignedStructure,
+        extract_unsigned_structure(PredicateStructures,UnsignedStructure),
+        UnsignedPredicateStructures),
+    count_math_predicates(UnsignedPredicateStructures,NumberOfMathPredicates),
+    extract_arguments_from_literals(Literals,Arguments),
+    findall(FunctorStructure,extract_functor_structure(
+Arguments,FunctorStructure),FunctorStructures),
+    count_math_functions(FunctorStructures,NumberOfMathFunctions),
+    count_math_numbers(FunctorStructures,NumberOfNumbers),
+    NumberOfArithmeticSymbols is NumberOfMathPredicates +
+NumberOfMathFunctions + NumberOfNumbers.
+
+%----FOF and TFF case
+count_mathematics(AnnotatedFormulae,NumberOfArithmeticSymbols,
+NumberOfMathPredicates,NumberOfMathFunctions,NumberOfNumbers):-
+    (   tptp_formulae_language(AnnotatedFormulae,[fof])
+    ;   tptp_formulae_language(AnnotatedFormulae,[tff])
+    ),
+    !,
+    extract_atoms_from_formulae(AnnotatedFormulae,_,_,no,Atoms),
+    tptp2X_findall_setof1(UnsignedStructure,
+        extract_unsigned_structure_from_atoms(Atoms,UnsignedStructure),
+        UnsignedPredicateStructures),
+    count_math_predicates(UnsignedPredicateStructures,NumberOfMathPredicates),
+    extract_arguments_from_atoms(Atoms,Arguments),
+    findall(FunctorStructure,extract_functor_structure(
+Arguments,FunctorStructure),FunctorStructures),
+    count_math_functions(FunctorStructures,NumberOfMathFunctions),
+    count_math_numbers(FunctorStructures,NumberOfNumbers),
+    NumberOfArithmeticSymbols is NumberOfMathPredicates +
+NumberOfMathFunctions + NumberOfNumbers.
+%DEBUG write('NP '),write(NumberOfMathPredicates),nl,
+%DEBUG write('NF '),write(NumberOfMathFunctions),nl,
+%DEBUG write('NN '),write(NumberOfNumbers),nl.
+
+%----THF case
+count_mathematics(AnnotatedFormulae,NumberOfArithmeticSymbols,
+NumberOfMathPredicates,NumberOfMathFunctions,NumberOfNumbers):-
+    tptp_formulae_language(AnnotatedFormulae,[thf]),
+    extract_atoms_from_formulae(AnnotatedFormulae,_,_,yes,Atoms),
+    tptp2X_findall_setof1(UnsignedStructure,
+        extract_unsigned_structure_from_atoms(Atoms,UnsignedStructure),
+        UnsignedPredicateStructures),
+    count_math_predicates(UnsignedPredicateStructures,NumberOfMathPredicates),
+    count_math_functions(UnsignedPredicateStructures,NumberOfMathFunctions),
+    count_math_numbers(UnsignedPredicateStructures,NumberOfNumbers),
+    NumberOfArithmeticSymbols is NumberOfMathPredicates +
+NumberOfMathFunctions + NumberOfNumbers.
+%------------------------------------------------------------------------------
 %----Find the clause with the most literals and count
 clause_size_values([],0,0):-
     !.
@@ -688,8 +1563,11 @@
 formulae_depth_values(Formulae,MaximalFormulaDepth,AverageFormulaDepth):-
     findall(FormulaDepth,
 %----Select an input clause and get its length
-        (   tptp2X_member(fof(_,_,Formula),Formulae),
-            tptp2X_syntax_formula_depth(Formula,FormulaDepth)),
+        (   tptp2X_member(AnnotatedFormula,Formulae),
+            AnnotatedFormula =.. [_,_,_,Formula],
+            tptp2X_syntax_formula_depth(Formula,FormulaDepth)
+%DEBUG write(AnnotatedFormula),write(' '),write(FormulaDepth),nl
+        ),
         AllFormulaDepths),
     tptp2X_maximal_in_list(AllFormulaDepths,MaximalFormulaDepth),
     tptp2X_arithmetic_average(AllFormulaDepths,AverageFormulaDepth).
@@ -703,32 +1581,21 @@
 %------------------------------------------------------------------------------
 %----Check if the formula variables are quantified, and note that quantified
 %----variables have been used
-check_quantifications([],_,ExcessQuantifiedVariables,
-ExcessQuantifiedVariables,[]).
+check_quantifications([],_,[]).
 
 check_quantifications([FirstFormulaVariable|RestOfFormulaVariables],
-VariablesQuantifiedSoFar,ExcessQuantifiedSoFar,ExcessQuantifiedVariables,
-FreeVariables):-
+VariablesQuantifiedSoFar,FreeVariables):-
 %----Check it's not a free variable
-    tptp2X_member(QuantifiedVariable,VariablesQuantifiedSoFar),
-    QuantifiedVariable == FirstFormulaVariable,
+    tptp2X_exact_member(FirstFormulaVariable,VariablesQuantifiedSoFar),
     !,
-%----Note that it has been used, if necessary
-    ((tptp2X_select(ExcessVariable,ExcessQuantifiedSoFar,
-OtherExcessQuantifiedSoFar),
-      ExcessVariable == QuantifiedVariable) ->
-        true
-    ;   OtherExcessQuantifiedSoFar = ExcessQuantifiedSoFar),
-%----Move on to next
     check_quantifications(RestOfFormulaVariables,VariablesQuantifiedSoFar,
-OtherExcessQuantifiedSoFar,ExcessQuantifiedVariables,FreeVariables).
+FreeVariables).
 
 %----Damn, it's a free variable
 check_quantifications([FirstFormulaVariable|RestOfFormulaVariables],
-VariablesQuantifiedSoFar,ExcessQuantifiedSoFar,ExcessQuantifiedVariables,
-[FirstFormulaVariable|RestOfFreeVariables]):-
+VariablesQuantifiedSoFar,[FirstFormulaVariable|RestOfFreeVariables]):-
     check_quantifications(RestOfFormulaVariables,VariablesQuantifiedSoFar,
-ExcessQuantifiedSoFar,ExcessQuantifiedVariables,RestOfFreeVariables).
+RestOfFreeVariables).
 %------------------------------------------------------------------------------
 seperate_types_from_variables([],[],[]).
 
@@ -744,61 +1611,97 @@
     seperate_types_from_variables(RestOfTypedVariables,RestOfVariables,
 RestOfTypes).
 %------------------------------------------------------------------------------
+%DEBUG parse_formula_for_variables(S,Q,_,_):-
+%DEBUG     write('PFFV--- '),write(S),write(' '),write(Q),nl,fail.
+
 %----Parse formula for variables, checking quantification
-parse_formula_for_variables(QuantifiedFormula,VariablesQuantifiedSoFar,
-AllQuantifiedVariables,ExcessQuantifiedSoFar,ExcessQuantifiedVariables,
+parse_formula_for_variables(Variable,QuantifiedVariablesSoFar,[Variable],
 FreeVariables):-
+    looks_like_a_variable(Variable),
+    !,
+    check_quantifications([Variable],QuantifiedVariablesSoFar,FreeVariables).
+
+%----Is it an atom
+parse_formula_for_variables(Atom,_,[],[]):-
+    atomic(Atom),
+    !.
+
+%----Is it a quantified formula
+parse_formula_for_variables(QuantifiedFormula,QuantifiedVariablesSoFar,
+AllQuantifiedVariables,FreeVariables):-
     tptp_quantified_formula(QuantifiedFormula,_,QuantifiedVariablesWithTypes,
 Formula),
+    !,
     seperate_types_from_variables(QuantifiedVariablesWithTypes,
 QuantifiedVariables,Types),
-    replace_variable_list(QuantifiedVariables,Formula,NewQuantifiedVariables,
-ReplacedFormula),
-    !,
-    tptp2X_append(VariablesQuantifiedSoFar,NewQuantifiedVariables,
-NewVariablesQuantifiedSoFar),
-    tptp2X_append(ExcessQuantifiedSoFar,NewQuantifiedVariables,
-NewExcessQuantifiedSoFar),
-    parse_formula_for_variables(Types,NewVariablesQuantifiedSoFar,
-TypeVariables,NewExcessQuantifiedSoFar,NextExcessQuantifiedSoFar,
-FreeTypeVariables),
-    parse_formula_for_variables(ReplacedFormula,NewVariablesQuantifiedSoFar,
-FormulaQuantifiedVariables,NextExcessQuantifiedSoFar,ExcessQuantifiedVariables,
-FreeFormulaVariables),
-    tptp2X_append(NewQuantifiedVariables,TypeVariables,MoreQuantifiedVariables),
-    tptp2X_append(MoreQuantifiedVariables,FormulaQuantifiedVariables,
+    replace_variable_list(QuantifiedVariables,Formula-Types,
+NewQuantifiedVariables,ReplacedFormula-ReplacedTypes),
+    tptp2X_append(QuantifiedVariablesSoFar,NewQuantifiedVariables,
+NewQuantifiedVariablesSoFar),
+%----Parse the types and formula with the current quantified variables
+    parse_list_for_variables(ReplacedTypes,NewQuantifiedVariablesSoFar,
+_TypeVariables,FreeTypeVariables),
+    parse_formula_for_variables(ReplacedFormula,NewQuantifiedVariablesSoFar,
+FormulaQuantifiedVariables,FreeFormulaVariables),
+%tptp2X_append(NewQuantifiedVariables,TypeVariables,MoreQuantifiedVariables),
+    tptp2X_append(NewQuantifiedVariables,FormulaQuantifiedVariables,
 AllQuantifiedVariables),
     tptp2X_append(FreeTypeVariables,FreeFormulaVariables,FreeVariables).
 
-parse_formula_for_variables(BinaryFormula,VariablesQuantifiedSoFar,
-AllQuantifiedVariables,ExcessQuantifiedSoFar,ExcessQuantifiedVariables,
-FreeVariables):-
+%----Is it binary
+parse_formula_for_variables(BinaryFormula,QuantifiedVariablesSoFar,
+AllQuantifiedVariables,FreeVariables):-
     tptp_binary_formula(BinaryFormula,_,LHS,RHS),
     !,
-    parse_formula_for_variables(LHS,VariablesQuantifiedSoFar,
-LHSQuantifiedVariables,ExcessQuantifiedSoFar,LHSExcessQuantifiedSoFar,
-LHSFreeVariables),
-    parse_formula_for_variables(RHS,VariablesQuantifiedSoFar,
-RHSQuantifiedVariables,LHSExcessQuantifiedSoFar,ExcessQuantifiedVariables,
-RHSFreeVariables),
+    parse_formula_for_variables(LHS,QuantifiedVariablesSoFar,
+LHSQuantifiedVariables,LHSFreeVariables),
+    parse_formula_for_variables(RHS,QuantifiedVariablesSoFar,
+RHSQuantifiedVariables,RHSFreeVariables),
     tptp2X_append(LHSFreeVariables,RHSFreeVariables,FreeVariables),
     tptp2X_append(LHSQuantifiedVariables,RHSQuantifiedVariables,
 AllQuantifiedVariables).
 
-parse_formula_for_variables(UnaryFormula,VariablesQuantifiedSoFar,
-QuantifiedVariables,ExcessQuantifiedSoFar,ExcessQuantifiedVariables,
-FreeVariables):-
+%----Is it unary
+parse_formula_for_variables(UnaryFormula,QuantifiedVariablesSoFar,
+QuantifiedVariables,FreeVariables):-
     tptp_unary_formula(UnaryFormula,_,Formula),
     !,
-    parse_formula_for_variables(Formula,VariablesQuantifiedSoFar,
-QuantifiedVariables,ExcessQuantifiedSoFar,ExcessQuantifiedVariables,
-FreeVariables).
+    parse_formula_for_variables(Formula,QuantifiedVariablesSoFar,
+QuantifiedVariables,FreeVariables).
+
+parse_formula_for_variables(_ := Definition,VariablesQuantifiedSoFar,
+QuantifiedVariables,FreeVariables):-
+    !,
+    parse_formula_for_variables(Definition,VariablesQuantifiedSoFar,
+QuantifiedVariables,FreeVariables).
 
-parse_formula_for_variables(AtomicFormula,VariablesQuantifiedSoFar,Variables,
-ExcessQuantifiedSoFar,ExcessQuantifiedVariables,FreeVariables):-
-    tptp2X_syntax_extract_variables(AtomicFormula,Variables,_),
-    check_quantifications(Variables,VariablesQuantifiedSoFar,
-ExcessQuantifiedSoFar,ExcessQuantifiedVariables,FreeVariables).
+parse_formula_for_variables(_ : Type,VariablesQuantifiedSoFar,
+QuantifiedVariables,FreeVariables):-
+    !,
+    parse_formula_for_variables(Type,VariablesQuantifiedSoFar,
+QuantifiedVariables,FreeVariables).
+
+%----Else it is a term
+parse_formula_for_variables(Term,QuantifiedVariablesSoFar,QuantifiedVariables,
+FreeVariables):-
+    Term =.. TermList,
+    parse_list_for_variables(TermList,QuantifiedVariablesSoFar,
+QuantifiedVariables,FreeVariables).
+%------------------------------------------------------------------------------
+%DEBUG parse_list_for_variables(S,Q,_,_):-
+%DEBUG     write('PLFV--- '),write(S),write(' '),write(Q),nl,fail.
+
+parse_list_for_variables([],_,[],[]).
+
+parse_list_for_variables([H|T],QuantifiedVariablesSoFar,QuantifiedVariables,
+FreeVariables):-
+    parse_formula_for_variables(H,QuantifiedVariablesSoFar,HQuantifiedVariables,
+HFreeVariables),
+    parse_list_for_variables(T,QuantifiedVariablesSoFar,TQuantifiedVariables,
+TFreeVariables),
+    tptp2X_append(HQuantifiedVariables,TQuantifiedVariables,
+QuantifiedVariables),
+    tptp2X_append(HFreeVariables,TFreeVariables,FreeVariables).
 %------------------------------------------------------------------------------
 %----Report bad variables if there are any
 report_bad_variables(_,[],_):-
@@ -820,9 +1723,7 @@
 QuantifiedVariables):-
     AnnotatedFormula =.. [_,Name,_,FirstFormula|_],
     parse_formula_for_variables(FirstFormula,[],FirstQuantifiedVariables,
-[],ExcessQuantifiedVariables,FreeVariables),
-    report_bad_variables('Excess quantified variables',
-ExcessQuantifiedVariables,Name),
+FreeVariables),
     report_bad_variables('Free variables',FreeVariables,Name),
 %----Do rest of formulae and append the result
     parse_formulae_for_variables(RestOfFormulae,RestOfQuantifiedVariables),
@@ -845,14 +1746,10 @@
 %----Count the number of singleton variables in the clauses
 count_number_of_variables(Formulae,NumberOfVariables,NumberOfSingletons):-
 %----Copy so that I can use numbervars to count them
-    tptp2X_copy(Formulae,CopyOfFormulae),
-%DEBUG statistics(times,T2),write('% about to extract_formulae_variables '),write(T2),nl,
+    copy_term(Formulae,CopyOfFormulae),
     extract_formulae_variables(CopyOfFormulae,Variables),
-%DEBUG statistics(times,T3),write('% about to numbervars '),write(T3),nl,
     numbervars(Variables,0,NumberOfVariables),
-%DEBUG statistics(times,T4),write('% about to findall '),write(T4),nl,
     extract_singleton_variables(Variables,Singletons),
-%DEBUG statistics(times,T5),write('% about to tptp2X_length '),write(T5),nl,
     tptp2X_length(Singletons,NumberOfSingletons).
 %------------------------------------------------------------------------------
 %----Separate out the positive and negative literals
@@ -915,20 +1812,44 @@
     NewNumberOfHornClauses is NumberOfHornClauses + 1.
 %------------------------------------------------------------------------------
 %----Count number of unit formulae (has a single atom)
-count_unit_formulae(InputFormulae,NumberOfUnitFormulae):-
+count_unit_formulae(InputFormulae,THFAtoms,NumberOfUnitFormulae):-
     findall(InputFormula,
         (   tptp2X_member(InputFormula,InputFormulae),
 %----Check the formula has a single atom. THIS ASSUMES tptp CONNECTIVES
 %----at the moment
-            extract_atoms_from_formulae([InputFormula],_,_,[_])),
+            extract_atoms_from_formulae([InputFormula],_,_,THFAtoms,[_])),
         UnitFormulae),
+%DEBUG write('UF are '),write(UnitFormulae),nl,
     tptp2X_length(UnitFormulae,NumberOfUnitFormulae).
 %------------------------------------------------------------------------------
+count_formulae_with_role(Formulae,Role,NumberOfRoleFormulae):-
+    findall(RoleFormula,
+        (   tptp2X_member(RoleFormula,Formulae),
+            RoleFormula =.. [_,_,Role|_]
+        ),
+        RoleFormulae),
+    tptp2X_length(RoleFormulae,NumberOfRoleFormulae).
+%------------------------------------------------------------------------------
+count_variable_atoms(Atoms,NumberOfVariableAtoms):-
+    findall(Variable,
+        (   tptp2X_member(Variable,Atoms),
+            looks_like_a_variable(Variable)
+        ),
+        VariableAtoms),
+    tptp2X_length(VariableAtoms,NumberOfVariableAtoms).
+%------------------------------------------------------------------------------
+remove_equality_for_thf_structures(SymbolStructures,THFSymbolStructures):-
+    tptp2X_select('$tptp_equal'/_,SymbolStructures,THFSymbolStructures),
+    !.
+
+remove_equality_for_thf_structures(SymbolStructures,SymbolStructures).
+
+%------------------------------------------------------------------------------
 %----Do the syntactic examination of the input set
 %----Empty case assumes clauses. May not be true, of course. AAARGH.
 examine_input_syntactics([],
 %----These are the output values
-['CLSS'-0,'NNHN'-0,'UNIT'-0,'RARE'-0,'LITS'-0,'EQLS'-0,'CLSZ'-0,'CLAS'-0,
+['CNFF'-0,'NNHN'-0,'UNIT'-0,'RARE'-0,'LITS'-0,'EQLS'-0,'CLSZ'-0,'CLAS'-0,
  'PRED'-0,'PROP'-0,'MINP'-0,'MAXP'-0,'FUNC'-0,'CNST'-0,'MINF'-0,'MAXF'-0,
  'VARS'-0,'SGTN'-0,'TMDP'-0,'TMAD'-0]):-
     !.
@@ -936,7 +1857,7 @@
 %----CNF case
 examine_input_syntactics(Clauses,
 %----These are the output values
-['CLSS'-NumberOfClauses,'NNHN'-NumberOfNonHornClauses,
+['CNFF'-NumberOfClauses,'NNHN'-NumberOfNonHornClauses,
  'UNIT'-NumberOfUnitClauses,'RARE'-NumberOfRangeRestrictedClauses,
  'LITS'-NumberOfLiterals,'EQLS'-NumberOfEqualityLiterals,
  'CLSZ'-MaximalClauseSize,'CLAS'-AverageClauseSize,
@@ -945,7 +1866,9 @@
  'FUNC'-NumberOfFunctors,'CNST'-NumberOfConstants,
  'MINF'-MinimalFunctorArity,'MAXF'-MaximalFunctorArity,
  'VARS'-NumberOfVariables,'SGTN'-NumberOfSingletons,
- 'TMDP'-MaximalTermDepth,'TMAD'-AverageTermDepth]):-
+ 'TMDP'-MaximalTermDepth,'TMAD'-AverageTermDepth,
+ 'MATT'-NumberOfArithmeticSymbols,'MATP'-NumberOfMathPredicates,
+ 'MATF'-NumberOfMathFunctions,'MATN'-NumberOfNumbers]):-
 %----Check it contains clauses
     tptp_clauses(Clauses),
     !,
@@ -965,7 +1888,8 @@
 %----Number of literals
     count_literals_with_predicate(Clauses,_,_,NumberOfLiterals),
 %----Number of equality literals
-    count_literals_with_predicate(Clauses,equal,2,NumberOfEqualityLiterals),
+    count_literals_with_predicate(Clauses,'$tptp_equal',2,
+NumberOfEqualityLiterals),
 %----Maximal clause size and arithmetic_average clause size
     clause_size_values(Clauses,MaximalClauseSize,AverageClauseSize),
 %----Number of predicate symbols
@@ -983,6 +1907,9 @@
 %----Range of functor arities
     tptp2X_arity_range(FunctorStructures,MinimalFunctorArity,
 MaximalFunctorArity),
+%----Math components
+    count_mathematics(Clauses,NumberOfArithmeticSymbols,
+NumberOfMathPredicates,NumberOfMathFunctions,NumberOfNumbers),
 %----Number of variables and singletons BEWARE THIS INSTANTIATES
     count_number_of_variables(Clauses,NumberOfVariables,
 NumberOfSingletons),
@@ -991,8 +1918,7 @@
 
 %----FOF case
 examine_input_syntactics(Formulae,
-%----These are the output values
-['FORM'-NumberOfFormulae,'UNIT'-NumberOfUnitFormulae,
+['FOFF'-NumberOfFormulae,'UNIT'-NumberOfUnitFormulae,
  'ATOM'-NumberOfAtoms,'EQAT'-NumberOfEqualityAtoms,
  'FMDP'-MaximalFormulaDepth,'FMAD'-AverageFormulaDepth,
  'CONN'-NumberOfConnectives,
@@ -1005,9 +1931,86 @@
  'MINF'-MinimalFunctorArity,'MAXF'-MaximalFunctorArity,
  'VARS'-NumberOfVariables,'SGTN'-NumberOfSingletons,
  'UNIV'-NumberOfUniversals,'EXIS'-NumberOfExistentials,
- 'TMDP'-MaximalTermDepth,'TMAD'-AverageTermDepth]):-
+ 'TMDP'-MaximalTermDepth,'TMAD'-AverageTermDepth,
+ 'MATT'-NumberOfArithmeticSymbols,'MATP'-NumberOfMathPredicates,
+ 'MATF'-NumberOfMathFunctions,'MATN'-NumberOfNumbers]):-
 %----Check it contains formulae
-    tptp_formulae(Formulae),
+    tptp_formulae_language(Formulae,[fof]),
+    !,
+%----Do basic syntactic examination
+    examine_formulae_for_predicates(Formulae,_,UnsignedPredicateStructures,_),
+    examine_formulae_for_functors(Formulae,FunctorStructures,_),
+%----Number of formulae
+    tptp2X_length(Formulae,NumberOfFormulae),
+%----Number of unit formulae
+    count_unit_formulae(Formulae,no,NumberOfUnitFormulae),
+%----Number of atoms
+    extract_atoms_from_formulae(Formulae,_,_,no,Atoms),
+    tptp2X_length(Atoms,NumberOfAtoms),
+%----Number of equality atoms
+    extract_atoms_from_formulae(Formulae,'$tptp_equal',2,no,EqualityAtoms),
+    tptp2X_length(EqualityAtoms,NumberOfEqualityAtoms),
+%----Maximal and arithmetic_average formula depth
+    formulae_depth_values(Formulae,MaximalFormulaDepth,AverageFormulaDepth),
+%----Number of each type of connective
+    count_formulae_connectives(Formulae,[NumberOfNOTs,NumberOfORs,
+NumberOfANDs,NumberOfIMPLYs,NumberOfIMPLIEDs,NumberOfEQUIVs,NumberOfXORs,
+NumberOfNORs,NumberOfNANDs,NumberOfUniversals,NumberOfExistentials,
+_NumberOfLambdas,_NumberOfAPPLYs,_NumberOfDefns,_NumberOfTypeDecs,
+_NumberOfPi,_NumberOfSigmas,_NumberOfPIs,_NumberOfSIGMAs,_NumberOfGlobalDefns,
+_NumberOfGlobalTypeDecs,_NumberOfMaps,_NumberOfXProds,_NumberOfUnions,
+_NumberOfSubtypes]),
+    NumberOfConnectives is NumberOfNOTs + NumberOfORs + NumberOfANDs + 
+NumberOfIMPLYs + NumberOfIMPLIEDs + NumberOfEQUIVs + NumberOfXORs + 
+NumberOfNORs + NumberOfNANDs,
+%----Number of predicate symbols
+    tptp2X_length(UnsignedPredicateStructures,NumberOfPredicateSymbols),
+%----Number of propositions
+    count_structures_of_arity(UnsignedPredicateStructures,0,
+NumberOfPropositions),
+%----Range of predicate arities
+    tptp2X_arity_range(UnsignedPredicateStructures,MinimalPredicateArity,
+MaximalPredicateArity),
+%----Number of functors
+    tptp2X_length(FunctorStructures,NumberOfFunctors),
+%----Number of constants
+    count_structures_of_arity(FunctorStructures,0,NumberOfConstants),
+%----Range of functor arities
+    tptp2X_arity_range(FunctorStructures,MinimalFunctorArity,
+MaximalFunctorArity),
+%----Math components
+    count_mathematics(Formulae,NumberOfArithmeticSymbols,
+NumberOfMathPredicates,NumberOfMathFunctions,NumberOfNumbers),
+%----Number of variables and singletons BEWARE THIS INSTANTIATES????
+%----Should equal the sum of !, ?, and ^
+    count_number_of_variables(Formulae,NumberOfVariables,
+NumberOfSingletons),
+%----Maximal and arithmetic_average term depth
+    term_depth_values(Formulae,MaximalTermDepth,AverageTermDepth).
+
+%----TFF case
+examine_input_syntactics(Formulae,
+['TFFF'-NumberOfFormulae,'UNIT'-NumberOfUnitFormulae,
+ 'TFRM'-NumberOfTypeFormulae,
+ 'ATOM'-NumberOfAtoms,'EQAT'-NumberOfEqualityAtoms,
+ 'FMDP'-MaximalFormulaDepth,'FMAD'-AverageFormulaDepth,
+ 'CONN'-NumberOfConnectives,
+ 'NOTS'-NumberOfNOTs,'ORSS'-NumberOfORs,'ANDS'-NumberOfANDs,
+ 'IMPS'-NumberOfIMPLYs,'PMIS'-NumberOfIMPLIEDs,'EQVS'-NumberOfEQUIVs,
+ 'XORS'-NumberOfXORs,'NORS'-NumberOfNORs,'NANS'-NumberOfNANDs,
+ 'TCON'-NumberOfTypeConnectives,'MAPS'-NumberOfMaps,'XPRO'-NumberOfXProds,
+ 'UNIO'-NumberOfUnions,'SUBT'-NumberOfSubtypes,
+ 'PRED'-NumberOfPredicateSymbols,'PROP'-NumberOfPropositions,
+ 'MINP'-MinimalPredicateArity,'MAXP'-MaximalPredicateArity,
+ 'FUNC'-NumberOfFunctors,'CNST'-NumberOfConstants,
+ 'MINF'-MinimalFunctorArity,'MAXF'-MaximalFunctorArity,
+ 'VARS'-NumberOfVariables,'SGTN'-NumberOfSingletons,
+ 'UNIV'-NumberOfUniversals,'EXIS'-NumberOfExistentials,
+ 'TMDP'-MaximalTermDepth,'TMAD'-AverageTermDepth,
+ 'MATT'-NumberOfArithmeticSymbols,'MATP'-NumberOfMathPredicates,
+ 'MATF'-NumberOfMathFunctions,'MATN'-NumberOfNumbers]):-
+%----Check it contains formulae
+    tptp_formulae_language(Formulae,[tff]),
     !,
 %----Do basic syntactic examination
     examine_formulae_for_predicates(Formulae,_,UnsignedPredicateStructures,_),
@@ -1015,22 +2018,30 @@
 %----Number of formulae
     tptp2X_length(Formulae,NumberOfFormulae),
 %----Number of unit formulae
-    count_unit_formulae(Formulae,NumberOfUnitFormulae),
+    count_unit_formulae(Formulae,no,NumberOfUnitFormulae),
+%----Number of formulae with type role
+    count_formulae_with_role(Formulae,type,NumberOfTypeFormulae),
 %----Number of atoms
-    extract_atoms_from_formulae(Formulae,_,_,Atoms),
+    extract_atoms_from_formulae(Formulae,_,_,no,Atoms),
     tptp2X_length(Atoms,NumberOfAtoms),
 %----Number of equality atoms
-    extract_atoms_from_formulae(Formulae,equal,2,EqualityAtoms),
+    extract_atoms_from_formulae(Formulae,'$tptp_equal',2,no,EqualityAtoms),
     tptp2X_length(EqualityAtoms,NumberOfEqualityAtoms),
 %----Maximal and arithmetic_average formula depth
     formulae_depth_values(Formulae,MaximalFormulaDepth,AverageFormulaDepth),
 %----Number of each type of connective
     count_formulae_connectives(Formulae,[NumberOfNOTs,NumberOfORs,
 NumberOfANDs,NumberOfIMPLYs,NumberOfIMPLIEDs,NumberOfEQUIVs,NumberOfXORs,
-NumberOfNORs,NumberOfNANDs,NumberOfUniversals,NumberOfExistentials]),
+NumberOfNORs,NumberOfNANDs,NumberOfUniversals,NumberOfExistentials,
+_NumberOfLambdas,_NumberOfAPPLYs,_NumberOfDefns,_NumberOfTypeDecs,
+_NumberOfPi,_NumberOfSigmas,_NumberOfPIs,_NumberOfSIGMAs,_NumberOfGlobalDefns,
+_NumberOfGlobalTypeDecs,NumberOfMaps,NumberOfXProds,NumberOfUnions,
+NumberOfSubtypes]),
     NumberOfConnectives is NumberOfNOTs + NumberOfORs + NumberOfANDs + 
 NumberOfIMPLYs + NumberOfIMPLIEDs + NumberOfEQUIVs + NumberOfXORs + 
 NumberOfNORs + NumberOfNANDs,
+    NumberOfTypeConnectives is NumberOfMaps + NumberOfXProds + NumberOfUnions +
+NumberOfSubtypes,
 %----Number of predicate symbols
     tptp2X_length(UnsignedPredicateStructures,NumberOfPredicateSymbols),
 %----Number of propositions
@@ -1046,18 +2057,99 @@
 %----Range of functor arities
     tptp2X_arity_range(FunctorStructures,MinimalFunctorArity,
 MaximalFunctorArity),
+%----Math components
+    count_mathematics(Formulae,NumberOfArithmeticSymbols,
+NumberOfMathPredicates,NumberOfMathFunctions,NumberOfNumbers),
 %----Number of variables and singletons BEWARE THIS INSTANTIATES????
+%----Should equal the sum of !, ?, and ^
     count_number_of_variables(Formulae,NumberOfVariables,
 NumberOfSingletons),
 %----Maximal and arithmetic_average term depth
     term_depth_values(Formulae,MaximalTermDepth,AverageTermDepth).
+
+%----THF case
+examine_input_syntactics(Formulae,
+['THFF'-NumberOfFormulae,'UNIT'-NumberOfUnitFormulae,
+ 'TFRM'-NumberOfTypeFormulae,'DFRM'-NumberOfDefnFormulae,
+ 'GDEF'-NumberOfGlobalDefns,'GTYP'-NumberOfGlobalTypeDecs,
+ 'ATOM'-NumberOfAtoms,'EQAT'-NumberOfEqualityAtoms,
+ 'VAAT'-NumberOfVariableAtoms,
+ 'FMDP'-MaximalFormulaDepth,'FMAD'-AverageFormulaDepth,
+ 'CONN'-NumberOfConnectives,
+ 'NOTS'-NumberOfNOTs,'ORSS'-NumberOfORs,'ANDS'-NumberOfANDs,
+ 'IMPS'-NumberOfIMPLYs,'PMIS'-NumberOfIMPLIEDs,'EQVS'-NumberOfEQUIVs,
+ 'XORS'-NumberOfXORs,'NORS'-NumberOfNORs,'NANS'-NumberOfNANDs,
+ 'APPY'-NumberOfAPPLYs,'DEFN'-NumberOfDefns,'TYPE'-NumberOfTypeDecs,
+ 'PIPI'-NumberOfPis,'SIGM'-NumberOfSigmas,
+ 'BIPI'-NumberOfPIs,'BISI'-NumberOfSIGMAs,
+ 'FUNC'-NumberOfSymbols,'CNST'-NumberOfConstants,
+ 'MINF'-MinimalSymbolArity,'MAXF'-MaximalSymbolArity,
+ 'VARS'-NumberOfVariables,'SGTN'-NumberOfSingletons,
+ 'UNIV'-NumberOfUniversals,'EXIS'-NumberOfExistentials,
+ 'LMDA'-NumberOfLambdas,
+ 'MATT'-NumberOfArithmeticSymbols,'MATP'-NumberOfMathPredicates,
+ 'MATF'-NumberOfMathFunctions,'MATN'-NumberOfNumbers,
+ 'TCON'-NumberOfTypeConnectives,'MAPS'-NumberOfMaps,'XPRO'-NumberOfXProds,
+ 'UNIO'-NumberOfUnions,'SUBT'-NumberOfSubtypes]):-
+%----Check it contains formulae
+    tptp_formulae_language(Formulae,[thf]),
+    !,
+%----Do basic syntactic examination
+    examine_formulae_for_symbols(Formulae,SymbolStructures,_),
+%----Remove equality for THF usage
+    remove_equality_for_thf_structures(SymbolStructures,THFSymbolStructures),
+%----Number of formulae
+    tptp2X_length(Formulae,NumberOfFormulae),
+%----Number of unit formulae
+    count_unit_formulae(Formulae,yes,NumberOfUnitFormulae),
+%----Number of formulae with type and defn role
+    count_formulae_with_role(Formulae,type,NumberOfTypeFormulae),
+    count_formulae_with_role(Formulae,definition,NumberOfDefnFormulae),
+%----Number of atoms (note, this includes the equality "atoms")
+    extract_atoms_from_formulae(Formulae,_,_,yes,Atoms),
+%DEBUG write('ATOMS '),write(Atoms),nl,
+    tptp2X_length(Atoms,NumberOfAtoms),
+    count_variable_atoms(Atoms,NumberOfVariableAtoms),
+%----Number of equality atoms
+    extract_atoms_from_formulae(Formulae,'$tptp_equal',2,yes,EqualityAtoms),
+    tptp2X_length(EqualityAtoms,NumberOfEqualityAtoms),
+%----Maximal and arithmetic_average formula depth
+    formulae_depth_values(Formulae,MaximalFormulaDepth,AverageFormulaDepth),
+%----Number of each type of connective
+    count_formulae_connectives(Formulae,[NumberOfNOTs,NumberOfORs,
+NumberOfANDs,NumberOfIMPLYs,NumberOfIMPLIEDs,NumberOfEQUIVs,NumberOfXORs,
+NumberOfNORs,NumberOfNANDs,NumberOfUniversals,NumberOfExistentials,
+NumberOfLambdas,NumberOfAPPLYs,NumberOfDefns,NumberOfTypeDecs,
+NumberOfPis,NumberOfSigmas,NumberOfPIs,NumberOfSIGMAs,NumberOfGlobalDefns,
+NumberOfGlobalTypeDecs,NumberOfMaps,NumberOfXProds,NumberOfUnions,
+NumberOfSubtypes]),
+    NumberOfConnectives is NumberOfNOTs + NumberOfORs + NumberOfANDs + 
+NumberOfIMPLYs + NumberOfIMPLIEDs + NumberOfEQUIVs + NumberOfXORs + 
+NumberOfNORs + NumberOfNANDs + NumberOfAPPLYs + NumberOfPis + NumberOfSigmas,
+    NumberOfTypeConnectives is NumberOfMaps + NumberOfXProds + NumberOfUnions +
+NumberOfSubtypes,
+%----Number of functors
+    tptp2X_length(THFSymbolStructures,NumberOfSymbols),
+%DEBUG write('SYMBOLS '),write(THFSymbolStructures),write(NumberOfSymbols),nl,
+%----Number of constants
+    count_structures_of_arity(THFSymbolStructures,0,NumberOfConstants),
+%----Range of functor arities
+    tptp2X_arity_range(THFSymbolStructures,MinimalSymbolArity,
+MaximalSymbolArity),
+%----Math components
+    count_mathematics(Formulae,NumberOfArithmeticSymbols,
+NumberOfMathPredicates,NumberOfMathFunctions,NumberOfNumbers),
+%----Number of variables and singletons BEWARE THIS INSTANTIATES????
+%----Should equal the sum of !, ?, and ^
+    count_number_of_variables(Formulae,NumberOfVariables,
+NumberOfSingletons).
 %------------------------------------------------------------------------------
 convert_literal_to_tptp(--Atom,~ Atom).
 
 convert_literal_to_tptp(++Atom,Atom).
 %------------------------------------------------------------------------------
 %----TSTP conversion procedures
-convert_literals_to_tptp([],$(false)):-
+convert_literals_to_tptp([],'$false'):-
     !.
 
 convert_literals_to_tptp([Literal],Formula):-
@@ -1092,10 +2184,10 @@
     convert_tptp_to_literals(RHS,RHSLiterals),
     tptp2X_append(LHSLiterals,RHSLiterals,Literals).
 
-%convert_tptp_to_literals($(false),[]):-
+%convert_tptp_to_literals('$false',[]):-
 %    !.
 %
-%convert_tptp_to_literals(~ $(true),[]):-
+%convert_tptp_to_literals(~ '$true',[]):-
 %    !.
 
 convert_tptp_to_literals(~ Atom,[--Atom]):-
diff -ur 1/TPTP2X/tptp2X.uninstalled 2/TPTP2X/tptp2X.uninstalled
--- 1/TPTP2X/tptp2X.uninstalled	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/tptp2X.uninstalled	2013-03-10 18:37:48.843090000 -0400
@@ -3,7 +3,7 @@
 #----These need to be installed
 set TPTPDirectory=/home/graph/tptp/TPTP
 set PrologInterpreter='/usr/local/bin/eclipse'
-set PrologArguments='-l 512000'
+set PrologArguments='-l 1024000 -g 1024000'
 set Gawk=/bin/awk
 #--------------------------------------------------------------------------
 #----Set default values for tptp2X parameters
@@ -422,7 +422,7 @@
 @ TPTP2XQueries=0
 #----Make an input file for Prolog
 set PrologInputFile="/tmp/tptp2XScript_$$"
-echo "compile('tptp2X.main')." >$PrologInputFile
+echo "COMPILE('tptp2X.main')." >$PrologInputFile
 echo "asserta(tptp2X_unique_value($$))." >>$PrologInputFile
 echo "asserta(tptp2X_cwd('$cwd'))." >>$PrologInputFile
 #----Make a query for each file specified. By now all *s are expanded.
@@ -466,7 +466,7 @@
 #----domain directory, TPTP directory
 #----NOTE $cwd in csh include full path names (e.g., /home/2/geoff) which
 #----     can mess up Prolog when generator files are reloaded
-                foreach PossiblePath ("" "$cwd" "$TPTPDirectory/Problems/$Domain" "$TPTPDirectory/Generators" "$TPTPDirectory/Problems" "$TPTPDirectory/Axioms" "$TPTPDirectory")
+                foreach PossiblePath ("" "$cwd" "$TPTPDirectory/Problems/$Domain" "$TPTPDirectory/Problems" "$TPTPDirectory/Axioms" "$TPTPDirectory/Generators" "$TPTPDirectory")
 #----If found, then set path
                     if (-f "$PossiblePath/$FilePath$PossibleExtension") then
                         set FilePath="$PossiblePath/$FilePath$PossibleExtension"
@@ -577,5 +577,5 @@
 /bin/rm -f /tmp/tptp2X-$$.p
 #--------------------------------------------------------------------------
 #----Clean up any old files lying around
-/bin/find /tmp \( -name 'tptp2X*' -o -name 'TemporaryFile*.tptp' \) -atime +1 -exec rm -f {} >& /dev/null \;
+/bin/find /tmp \( -name 'tptp2X*' -o -name 'TemporaryFile*.tptp' \) -atime +1 -exec rm -f {} >& /dev/null \; || true
 #--------------------------------------------------------------------------
diff -ur 1/TPTP2X/transform.arrange 2/TPTP2X/transform.arrange
--- 1/TPTP2X/transform.arrange	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/transform.arrange	2012-08-13 14:45:12.000000000 -0400
@@ -57,8 +57,8 @@
 %----Reverse a unit equality clause
 reverse_unit_equality(input_clause(Name,Status,[Literal]),input_clause(
 Name,Status,[ReversedLiteral])):-
-    Literal =.. [Sign,equal(T1,T2)],
-    ReversedLiteral =.. [Sign,equal(T2,T1)].
+    Literal =.. [Sign,'$tptp_equal'(T1,T2)],
+    ReversedLiteral =.. [Sign,'$tptp_equal'(T2,T1)].
 %----------------------------------------------------------------------
 %----Reverse all the terms in only unit equality clauses (fail if
 %----anything else appears)
@@ -67,7 +67,7 @@
 reverse_unit_equalities([input_clause(Name,Status,[Literal])|RestOfClauses],
 [ReversedClause|RestOfReversedClauses]):-
 %----Check it's a unit equality
-    Literal =.. [_,equal(_,_)],
+    Literal =.. [_,'$tptp_equal'(_,_)],
     !,
     reverse_unit_equality(input_clause(Name,Status,[Literal]),ReversedClause),
     reverse_unit_equalities(RestOfClauses,RestOfReversedClauses).
@@ -82,7 +82,7 @@
 %----If a unit equality and the random number says yeah, then reverse
 randomly_reverse_unit_equalities([input_clause(Name,Status,[Literal])|
 RestOfClauses],[ReversedClause|RestOfReversedClauses]):-
-    Literal =.. [_,equal(_,_)],
+    Literal =.. [_,'$tptp_equal'(_,_)],
 %----Cannot unify here as that might cause shit in the random number
 %----generator (which might expect to produce what ever)
     tptp2X_random_integer(1,2,OneOrTwo),
@@ -117,7 +117,7 @@
     reverse_literals_in_clauses(IntermediateClauses,OutputClauses).
 
 %----For reversing FOF formulae order
-fr(InputFormulae,Dictionary,cr,OutputFormulae,Dictionary,'+fr'):-
+fr(InputFormulae,Dictionary,fr,OutputFormulae,Dictionary,'+fr'):-
     tptp_formulae(InputFormulae),
     fast_reverse_list(InputFormulae,[],OutputFormulae).
 
diff -ur 1/TPTP2X/transform.equality 2/TPTP2X/transform.equality
--- 1/TPTP2X/transform.equality	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/transform.equality	2012-08-13 14:45:12.000000000 -0400
@@ -19,7 +19,7 @@
     tptp_clauses(Clauses),
     tptp2X_member(input_clause(_,_,Literals),Clauses),
     tptp2X_member(Literal,Literals),
-    Literal =.. [_,equal(_,_)],
+    Literal =.. [_,'$tptp_equal'(_,_)],
     !,
 %----Get the predicate structures
     examine_formulae_for_predicates(Clauses,_,UnsignedPredicateStructures,_).
@@ -27,7 +27,7 @@
 check_there_is_equality(Formulae,UnsignedPredicateStructures):-
     tptp_formulae(Formulae),
     examine_formulae_for_predicates(Formulae,_,UnsignedPredicateStructures,_),
-    tptp2X_member(equal/2,UnsignedPredicateStructures),
+    tptp2X_member('$tptp_equal'/2,UnsignedPredicateStructures),
     !.
 %------------------------------------------------------------------------------
 %----Set if two clauses have the same literals, modulo renaming
@@ -158,8 +158,8 @@
 %----CNF case
 generate_function_substitutivity_axiom(FunctorStructures,'-',
 input_clause(AxiomName,axiom,
-    [--equal(Variable1,Variable2),
-     ++equal(Function1,Function2)])
+    [--'$tptp_equal'(Variable1,Variable2),
+     ++'$tptp_equal'(Function1,Function2)])
 ):-
     tptp2X_member(Structure,FunctorStructures),
     make_two_templates_with_substitution(Structure,Function1,Function2,
@@ -169,8 +169,8 @@
 generate_function_substitutivity_axiom(FunctorStructures,'+',
 fof(AxiomName,axiom,
     ! [Variable1,Variable2|OtherVariables] :
-      ( equal(Variable1,Variable2) 
-     => equal(Function1,Function2) )   )
+      ( '$tptp_equal'(Variable1,Variable2) 
+     => '$tptp_equal'(Function1,Function2) )   )
 ):-
     tptp2X_member(Structure,FunctorStructures),
     make_two_templates_with_substitution(Structure,Function1,Function2,
@@ -181,7 +181,7 @@
 %----CNF case
 generate_predicate_substitutivity_axiom(PredicateStructures,'-',
 input_clause(AxiomName,axiom,
-    [--equal(Variable1,Variable2),
+    [--'$tptp_equal'(Variable1,Variable2),
      --Predicate1,
      ++Predicate2])
 ):-
@@ -193,7 +193,7 @@
 generate_predicate_substitutivity_axiom(PredicateStructures,'+',
 fof(AxiomName,axiom,
     ! [Variable1,Variable2|OtherVariables] :
-      ( ( equal(Variable1,Variable2) 
+      ( ( '$tptp_equal'(Variable1,Variable2) 
         & Predicate1 ) 
      => Predicate2 )   )
 ):-
@@ -204,40 +204,40 @@
 %----Generate a specific axiom set in some form
 generate_equality_axioms(r,'+',_,_,[
 fof(reflexivity,axiom,
-    ! [X] : equal(X,X)   )
+    ! ['X'] : '$tptp_equal'('X','X')   )
 ]).
 
 generate_equality_axioms(r,'-',_,_,[
 input_clause(reflexivity,axiom,
-    [++equal(X,X)])
+    [++'$tptp_equal'('X','X')])
 ]).
 
 generate_equality_axioms(s,'+',_,_,[
 fof(symmetry,axiom,
-    ! [X,Y] : 
-      ( equal(X,Y)
-     => equal(Y,X) )   )
+    ! ['X','Y'] : 
+      ( '$tptp_equal'('X','Y')
+     => '$tptp_equal'('Y','X') )   )
 ]).
 
 generate_equality_axioms(s,'-',_,_,[
 input_clause(symmetry,axiom,
-    [--equal(X,Y),
-     ++equal(Y,X)])
+    [--'$tptp_equal'('X','Y'),
+     ++'$tptp_equal'('Y','X')])
 ]).
 
 generate_equality_axioms(t,'+',_,_,[
 fof(transitivity,axiom,
-    ! [X,Y,Z] : 
-      ( ( equal(X,Y)
-        & equal(Y,Z) )
-     => equal(X,Z) )   )
+    ! ['X','Y','Z'] : 
+      ( ( '$tptp_equal'('X','Y')
+        & '$tptp_equal'('Y','Z') )
+     => '$tptp_equal'('X','Z') )   )
 ]).
 
 generate_equality_axioms(t,'-',_,_,[
 input_clause(transitivity,axiom,
-    [--equal(X,Y),
-     --equal(Y,Z),
-     ++equal(X,Z)])
+    [--'$tptp_equal'('X','Y'),
+     --'$tptp_equal'('Y','Z'),
+     ++'$tptp_equal'('X','Z')])
 ]).
 
 generate_equality_axioms(f,FormulaFormat,_,FunctorStructures,
@@ -337,7 +337,7 @@
 convert_literals_to_equality([Literal|RestOfLiterals],[Literal|
 RestOfEqualityLiterals]):-
     Literal =.. [_,Atom],
-    Atom =.. [equal,_,_],
+    Atom =.. ['$tptp_equal',_,_],
     !,
     convert_literals_to_equality(RestOfLiterals,RestOfEqualityLiterals).
 
@@ -345,7 +345,7 @@
 convert_literals_to_equality([Literal|RestOfLiterals],[EqualityLiteral|
 RestOfEqualityLiterals]):-
     Literal =.. [Sign,Atom],
-    EqualityAtom =.. [equal,Atom,$(true)],
+    EqualityAtom =.. ['$tptp_equal',Atom,'$true'],
     EqualityLiteral =.. [Sign,EqualityAtom],
     convert_literals_to_equality(RestOfLiterals,RestOfEqualityLiterals).
 %------------------------------------------------------------------------------
@@ -366,7 +366,8 @@
 %----Check if there is equality
     check_there_is_equality(Formulae,UnsignedPredicateStructures),
 %----Remove equality it to prevent transitivity being created
-    tptp2X_select(equal/2,UnsignedPredicateStructures,PredicateStructures),
+    tptp2X_select('$tptp_equal'/2,UnsignedPredicateStructures,
+PredicateStructures),
     examine_formulae_for_functors(Formulae,FunctorStructures,_),
 %----Determine the type of axioms required
     determine_formula_format(Formulae,FormulaFormat).
Only in 2/TPTP2X: transform.expand
diff -ur 1/TPTP2X/transform.fofify 2/TPTP2X/transform.fofify
--- 1/TPTP2X/transform.fofify	2007-03-01 12:01:55.000000000 -0500
+++ 2/TPTP2X/transform.fofify	2012-08-13 14:45:12.000000000 -0400
@@ -22,7 +22,7 @@
 %------------------------------------------------------------------------------
 %----Convert literals to a FOF
 %----Positive and negative makes an implication
-implify_literals(Literals,Conjunction => Disjunction):-
+implify_literals(Literals,(Conjunction => Disjunction)):-
     split_atoms_by_sign(Literals,[Postive1|PositiveRest],
 [Negative1|NegativeRest]),
     !,
@@ -43,6 +43,7 @@
 convert_to_FOF_literals([],[]).
 
 convert_to_FOF_literals([++Atom|RestOfLiterals],[Atom|RestOfFOFLiterals]):-
+    !,
     convert_to_FOF_literals(RestOfLiterals,RestOfFOFLiterals).
 
 convert_to_FOF_literals([--Atom|RestOfLiterals],[~Atom|RestOfFOFLiterals]):-
@@ -91,7 +92,7 @@
     negate(FOFedLiterals,NegatedFOFedLiterals).
 
 obvious_make_conjecture([input_clause(Name,negated_conjecture,Literals)|
-RestOfConjectureClauses],NegatedFOFedLiterals '|' RestOfConjecture,
+RestOfConjectureClauses],(NegatedFOFedLiterals '|' RestOfConjecture),
 CombinedName):-
     implify_literals(Literals,FOFedLiterals),
     negate(FOFedLiterals,NegatedFOFedLiterals),
@@ -106,48 +107,323 @@
     obvious_make_conjecture(ConjectureClauses,ConjectureFormula,CombinedName),
     existentially_quantify(ConjectureFormula,QuantifiedFormula).
 %------------------------------------------------------------------------------
-obvious_translate_axioms_clauses_to_fof([],[]).
+obvious_translate_axioms_to_fof([],[]).
 
-obvious_translate_axioms_clauses_to_fof([input_clause(Name,Status,Literals)|
-RestOfClauses],[fof(Name,Status,QuantifiedFormula)|RestOfFormulae]):-
+obvious_translate_axioms_to_fof([input_clause(Name,Status,Literals)|
+RestOfFormulae],[fof(Name,Status,QuantifiedFormula)|RestOfTranslated]):-
+    !,
     implify_literals(Literals,Formula),
     universally_quantify(Formula,QuantifiedFormula),
-    obvious_translate_axioms_clauses_to_fof(RestOfClauses,RestOfFormulae).
+    obvious_translate_axioms_to_fof(RestOfFormulae,RestOfTranslated).
+
+obvious_translate_axioms_to_fof([NonClause|RestOfFormulae],
+[NonClause|RestOfTranslated]):-
+    obvious_translate_axioms_to_fof(RestOfFormulae,RestOfTranslated).
+%------------------------------------------------------------------------------
+direct_translate_to_fof([],[]).
+
+direct_translate_to_fof([FirstClause|RestOfClauses],[FirstFOF|RestOfFOF]):-
+    FirstClause =.. [input_clause,Name,Role,Literals|Rest],
+    !,
+    fofify_literals(Literals,Disjunction),
+    universally_quantify(Disjunction,LogicFormula),
+    FirstFOF =.. [fof,Name,Role,LogicFormula|Rest],
+    direct_translate_to_fof(RestOfClauses,RestOfFOF).
+
+direct_translate_to_fof([NonClause|RestOfClauses],[NonClause|RestOfFOF]):-
+    direct_translate_to_fof(RestOfClauses,RestOfFOF).
 %------------------------------------------------------------------------------
 %----Convert a set of clauses to formulae
-translate_to_fof([],_,[]):-
+translate_cnf_to_fof([],_,[]):-
     !.
 
-translate_to_fof(Clauses,obvious,FOFFormulae):-
+translate_cnf_to_fof(Clauses,direct,FOFFormulae):-
+    direct_translate_to_fof(Clauses,FOFFormulae).
+
+translate_cnf_to_fof(Clauses,obvious,FOFFormulae):-
 %----Extract the conjecture clauses
-    extract_conjecture_clauses(Clauses,ConjectureClauses,OtherClauses),
-    obvious_translate_axioms_clauses_to_fof(OtherClauses,AxiomFormulae),
+    extract_conjecture_clauses(Clauses,ConjectureClauses,OtherFormulae),
+    obvious_translate_axioms_to_fof(OtherFormulae,AxiomFormulae),
     obvious_translate_conjecture_clauses_to_fof(ConjectureClauses,
 ConjectureFormulae),
     tptp2X_append(AxiomFormulae,ConjectureFormulae,FOFFormulae).
 
-translate_to_fof(Clauses,proving,[fof(combined,conjecture,
+translate_cnf_to_fof(Clauses,proving,[fof(combined,conjecture,
 ~QuantifiedFormula)]):-
     conjoin_clauses(Clauses,Formula),
     universally_quantify(Formula,QuantifiedFormula).
 %------------------------------------------------------------------------------
-%----Formulae are clausifed 
 fofify(Clauses,Dictionary,fofify:Algorithm,FOFFormulae,Dictionary,
 NameSuffix):-
-    tptp_clauses(Clauses),
-    translate_to_fof(Clauses,Algorithm,FOFFormulae),
+    translate_cnf_to_fof(Clauses,Algorithm,FOFFormulae),
     concatenate_atoms(['+fof_',Algorithm],NameSuffix).
+%------------------------------------------------------------------------------
+make_tff_fof_sort_atoms([],_,[],[]).
 
-fofify(Formulae,Dictionary,fofify:Algorithm,Formulae,Dictionary,NameSuffix):-
-    tptp_formulae(Formulae),
-    concatenate_atoms(['+fof_',Algorithm],NameSuffix).
+%----Ignore unsorted variables
+make_tff_fof_sort_atoms([Variable|RestOfTFFVariables],KnownTypes,[Variable|
+RestOfFOFVariables],SortAtoms):-
+    looks_like_a_variable(Variable),
+    !,
+    make_tff_fof_sort_atoms(RestOfTFFVariables,KnownTypes,RestOfFOFVariables,
+SortAtoms).
+
+%----Ignore variables with built-in sorts
+make_tff_fof_sort_atoms([Variable:Sort|RestOfTFFVariables],KnownTypes,
+[Variable|RestOfFOFVariables],SortAtoms):-
+    _ =.. [Sort,Variable],
+    tptp2X_member(Sort,KnownTypes),
+    !,
+    make_tff_fof_sort_atoms(RestOfTFFVariables,KnownTypes,RestOfFOFVariables,
+SortAtoms).
+
+%----Make sort atoms for all other sorted variables
+make_tff_fof_sort_atoms([Variable:Sort|RestOfTFFVariables],KnownTypes,
+[Variable|RestOfFOFVariables],[SortAtom|RestOfSortAtoms]):-
+    SortAtom =.. [Sort,Variable],
+    make_tff_fof_sort_atoms(RestOfTFFVariables,KnownTypes,RestOfFOFVariables,
+RestOfSortAtoms).
+%------------------------------------------------------------------------------
+conjoin_sort_atoms([OneAtom],OneAtom).
+
+conjoin_sort_atoms([Atom|RestOfAtoms],(Atom & RestOfConjunction)):-
+    conjoin_sort_atoms(RestOfAtoms,RestOfConjunction).
+%------------------------------------------------------------------------------
+make_tff_sorted_formula([],FOFLogic,_,FOFLogic):-
+    !.
+
+make_tff_sorted_formula(SortAtoms,FOFLogic,Connective,FOFFormula):-
+    conjoin_sort_atoms(SortAtoms,SortConjunction),
+    FOFFormula =.. [Connective,SortConjunction,FOFLogic].
+%------------------------------------------------------------------------------
+translate_tff_logic_to_fof(Variable,_,Variable):-
+    looks_like_a_variable(Variable),
+    !.
+
+translate_tff_logic_to_fof(! TFFVariables : TFFLogic,KnownTypes,
+! FOFVariables : FOFFormula):-
+    !,
+    make_tff_fof_sort_atoms(TFFVariables,KnownTypes,FOFVariables,SortAtoms),
+    translate_tff_logic_to_fof(TFFLogic,KnownTypes,FOFLogic),
+    make_tff_sorted_formula(SortAtoms,FOFLogic,'=>',FOFFormula).
+
+translate_tff_logic_to_fof(? TFFVariables : TFFLogic,KnownTypes,
+? FOFVariables : FOFFormula):-
+    !,
+    make_tff_fof_sort_atoms(TFFVariables,KnownTypes,FOFVariables,SortAtoms),
+    translate_tff_logic_to_fof(TFFLogic,KnownTypes,FOFLogic),
+    make_tff_sorted_formula(SortAtoms,FOFLogic,'&',FOFFormula).
+
+translate_tff_logic_to_fof(TFFBinaryFormula,KnownTypes,FOFBinaryFormula):-
+    tptp_binary_formula(TFFBinaryFormula,Connective,TFFLHS,TFFRHS),
+    !,
+    translate_tff_logic_to_fof(TFFLHS,KnownTypes,FOFLHS),
+    translate_tff_logic_to_fof(TFFRHS,KnownTypes,FOFRHS),
+    FOFBinaryFormula =.. [Connective,FOFLHS,FOFRHS].
+
+translate_tff_logic_to_fof(TFFUnaryFormula,KnownTypes,FOFUnaryFormula):-
+    tptp_unary_formula(TFFUnaryFormula,Connective,TFFFormula),
+    !,
+    translate_tff_logic_to_fof(TFFFormula,KnownTypes,FOFFormula),
+    FOFUnaryFormula =.. [Connective,FOFFormula].
+
+translate_tff_logic_to_fof(AtomicFormula,_,AtomicFormula).
+%------------------------------------------------------------------------------
+look_for_individual_TLT('$i',TLTsSoFar,TLTsSoFar):-
+    tptp2X_member('$i',TLTsSoFar),
+    !.
+
+look_for_individual_TLT('$i',TLTsSoFar,['$i'|TLTsSoFar]):-
+    !.
+
+look_for_individual_TLT(_,TLTsSoFar,TLTsSoFar).
 %------------------------------------------------------------------------------
-axiomate(Formulae,Dictionary,axiomate,AxiomFormulae,Dictionary,_NameSuffix):-
+make_signature_sort_atom(Type,KnownTypes,'$true',_):-
+    tptp2X_member(Type,KnownTypes),
+    !.
+
+make_signature_sort_atom(Type,_,SortAtom,Variable):-
+    SortAtom =.. [Type,Variable].
+%------------------------------------------------------------------------------
+%DEBUG translate_tff_signature_to_fof(T,_,_,_):-write('TTSTF '),display(T),nl,fail.
+
+translate_tff_signature_to_fof((RestOfTypes * Type),KnownTypes,Variables,
+(RestOfConjunction & SortAtom),TLTsSoFar,TopLevelTypes):-
+    !,
+    make_signature_sort_atom(Type,KnownTypes,SortAtom,Variable),
+    look_for_individual_TLT(Type,TLTsSoFar,IndividualTLTs),
+    translate_tff_signature_to_fof(RestOfTypes,KnownTypes,RestOfVariables,
+RestOfConjunction,IndividualTLTs,TopLevelTypes),
+    tptp2X_append(RestOfVariables,[Variable],Variables).
+
+translate_tff_signature_to_fof(OneType,KnownTypes,[Variable],SortAtom,
+TLTsSoFar,TopLevelTypes):-
+    look_for_individual_TLT(OneType,TLTsSoFar,TopLevelTypes),
+    make_signature_sort_atom(OneType,KnownTypes,SortAtom,Variable).
+%------------------------------------------------------------------------------
+%----Declarations of types specify non-empty domains
+translate_tff_type_to_fof(Type : '$tType',_KnownTypes,
+? [X] : SortAtom,TLTsSoFar,[Type|TLTsSoFar]):-
+    !,
+%----Reject duplicate declarations of types
+    \+ tptp2X_member(Type,TLTsSoFar),
+    SortAtom =.. [Type,X].
+
+%----Subtypes become implications. Remove subtype as TLT
+translate_tff_type_to_fof(Subtype << Type,_KnownTypes,
+! [X] : (SubsortAtom => SortAtom),TLTsSoFar,TopLevelTypes):-
+    !,
+    tptp2X_select(Subtype,TLTsSoFar,LessTLTsSoFar),
+    look_for_individual_TLT(Type,LessTLTsSoFar,TopLevelTypes),
+    SubsortAtom =.. [Subtype,X],
+    SortAtom =.. [Type,X].
+
+%----Signatures get converted to sort atoms.
+translate_tff_type_to_fof(Symbol : Arguments > Result,KnownTypes,
+! Variables : ( SortConjunction => SortAtom ),TLTsSoFar,TopLevelTypes):-
+    !,
+    translate_tff_signature_to_fof(Arguments,KnownTypes,Variables,
+SortConjunction,TLTsSoFar,TopLevelTypes),
+    Function =.. [Symbol|Variables],
+    make_signature_sort_atom(Result,KnownTypes,SortAtom,Function).
+
+translate_tff_type_to_fof(AtomSymbol : Type,KnownTypes,SortAtom,TLTsSoFar,
+TopLevelTypes):-
+    !,
+    look_for_individual_TLT(Type,TLTsSoFar,TopLevelTypes),
+    make_signature_sort_atom(Type,KnownTypes,SortAtom,AtomSymbol).
+%------------------------------------------------------------------------------
+%DEBUG translate_tff_to_fof([F|_],_,_,_,_):-write('TTTF '),write(F),nl,fail.
+
+translate_tff_to_fof([],_,[],TopLevelTypes,TopLevelTypes).
+
+%----Skip predicate declarations
+translate_tff_to_fof([TFFFormula|RestOfTFFFormulae],KnownTypes,
+RestOfFOFFormulae,TLTsSoFar,TopLevelTypes):-
+    TFFFormula =.. [tff,_,type,_ : '$o'|_],
+    !,
+    translate_tff_to_fof(RestOfTFFFormulae,KnownTypes,RestOfFOFFormulae,
+TLTsSoFar,TopLevelTypes).
+
+translate_tff_to_fof([TFFFormula|RestOfTFFFormulae],KnownTypes,
+RestOfFOFFormulae,TLTsSoFar,TopLevelTypes):-
+    TFFFormula =.. [tff,_,type,_ : (Arguments > '$o') |_],
+    translate_tff_signature_to_fof(Arguments,KnownTypes,_,_,TLTsSoFar,MoreTLTs),
+    !,
+    translate_tff_to_fof(RestOfTFFFormulae,KnownTypes,RestOfFOFFormulae,
+MoreTLTs,TopLevelTypes).
+
+%----Do all other types
+translate_tff_to_fof([TFFFormula|RestOfTFFFormulae],KnownTypes,[FOFFormula|
+RestOfFOFFormulae],TLTsSoFar,TopLevelTypes):-
+    TFFFormula =.. [tff,Name,type,TFFType|_],
+    !,
+%DEBUG write('translates type '),write(TFFType),nl,
+%DEBUG write('old TLTS '),write(TLTsSoFar),nl,
+    translate_tff_type_to_fof(TFFType,KnownTypes,FOFLogic,TLTsSoFar,NewTLTs),
+%DEBUG write('translated type '),write(FOFLogic),nl,
+%DEBUG write('new TLTS '),write(NewTLTs),nl,
+    concatenate_atoms(['fof_',Name],FOFName),
+    FOFFormula =.. [fof,FOFName,axiom,FOFLogic,
+inference(tff2fof,[status(thm)],[Name])],
+    translate_tff_to_fof(RestOfTFFFormulae,KnownTypes,RestOfFOFFormulae,
+NewTLTs,TopLevelTypes).
+
+%----Do regular tff formulae
+translate_tff_to_fof([TFFFormula|RestOfTFFFormulae],KnownTypes,[FOFFormula|
+RestOfFOFFormulae],TLTsSoFar,TopLevelTypes):-
+    TFFFormula =.. [tff,Name,Role,TFFLogic|_],
+    !,
+%DEBUG write('translate '),write(TFFLogic),nl,
+    translate_tff_logic_to_fof(TFFLogic,KnownTypes,FOFLogic),
+%DEBUG write('translated '),write(FOFLogic),nl,
+    concatenate_atoms(['fof_',Name],FOFName),
+    FOFFormula =.. [fof,FOFName,Role,FOFLogic,
+inference(tff2fof,[status(thm)],[Name])],
+    translate_tff_to_fof(RestOfTFFFormulae,KnownTypes,RestOfFOFFormulae,
+TLTsSoFar,TopLevelTypes).
+
+%----Ignore others - help, what are they?
+translate_tff_to_fof([Formula|RestOfTFFFormulae],KnownTypes,
+[Formula|RestOfFOFFormulae],TLTsSoFar,TopLevelTypes):-
+write('HELP, what is this doing here'),nl,write(Formula),nl,
+    translate_tff_to_fof(RestOfTFFFormulae,KnownTypes,RestOfFOFFormulae,
+TLTsSoFar,TopLevelTypes).
+%------------------------------------------------------------------------------
+translate_tff_top_level_types(TopLevelTypes,_,with,
+fof(Name,axiom,
+! [X,Y] : ( (FirstAtom & SecondAtom) => '$tptp_not_equal'(X,Y) ) )
+):-
+    tptp2X_append(_,[FirstType|RestOfTypes],TopLevelTypes),
+    tptp2X_member(SecondType,RestOfTypes),
+    FirstAtom =.. [FirstType,X],
+    SecondAtom =.. [SecondType,Y],
+    concatenate_atoms([FirstType,'_',SecondType,'_distinct'],Name).
+
+translate_tff_top_level_types(Types,TFFFormulae,_,DisjointFormula):-
+    tptp2X_member(Type,Types),
+    findall(Subtype,tptp2X_member(tff(_,type,Subtype << Type),TFFFormulae),
+SubtypesOfType),
+    translate_tff_top_level_types(SubtypesOfType,TFFFormulae,with,
+DisjointFormula).
+%------------------------------------------------------------------------------
+tff2fof_known_types([],[]).
+
+tff2fof_known_types([$(Type)|RestKnownTypes],[AtomicType|
+RestAtomicKnownTypes]):-
+    !,
+    concatenate_atoms(['$',Type],AtomicType),
+    tff2fof_known_types(RestKnownTypes,RestAtomicKnownTypes).
+
+tff2fof_known_types([AtomicKnownType|RestKnownTypes],[AtomicKnownType|
+RestAtomicKnownTypes]):-
+    tff2fof_known_types(RestKnownTypes,RestAtomicKnownTypes).
+%------------------------------------------------------------------------------
+tff2fof(TFFFormulae,Dictionary,tff2fof:WithOrWithoutInequalities,FOFFormulae,
+FOFDictionary,Extension):-
+   tptp2X_member(WithOrWithoutInequalities,[with,without]),
+   tff2fof(TFFFormulae,Dictionary,
+tff2fof:WithOrWithoutInequalities:['$int','$rat','$real'],
+FOFFormulae,FOFDictionary,Extension).
+
+tff2fof(TFFFormulae,Dictionary,tff2fof,FOFFormulae,FOFDictionary,Extension):-
+   tff2fof(TFFFormulae,Dictionary,tff2fof:with:['$int','$rat','$real'],
+FOFFormulae,FOFDictionary,Extension).
+
+tff2fof(TFFFormulae,Dictionary,tff2fof:WithOrWithoutInequalities:KnownTypes,
+FOFFormulae,Dictionary,'+tff2fof'):-
+%DEBUG write('TFFFormulae '),write(TFFFormulae),nl,
+%DEBUG write('Dictionary '),write(Dictionary),nl,
+    tff2fof_known_types(KnownTypes,AtomicKnownTypes),
+    tptp_formulae_language(TFFFormulae,[tff]),
+    !,
+    tptp_complete_types(TFFFormulae,CompletedTypeDeclarations,
+CompletedLogicalFormulae),
+    tptp2X_append(CompletedTypeDeclarations,CompletedLogicalFormulae,
+CompletedTFFFormulae),
+%DEBUG write('CompletedTFFFormulae '),write(CompletedTFFFormulae),nl,
+    translate_tff_to_fof(CompletedTFFFormulae,AtomicKnownTypes,TFFFOFFormulae,
+[],TopLevelTypes),
+%DEBUG write('TFFFOFFormulae '),write(TFFFOFFormulae),nl,
+   findall(DisjointFormula,translate_tff_top_level_types(TopLevelTypes,
+TFFFormulae,WithOrWithoutInequalities,DisjointFormula),DisjointFormulae),
+%DEBUG write('Disjoints '),write(DisjointFormulae),nl,
+    tptp2X_append(TFFFOFFormulae,DisjointFormulae,FOFFormulae).
+
+tff2fof(Formulae,Dictionary,tff2fof,Formulae,Dictionary,'').
+%------------------------------------------------------------------------------
+axiomate(Formulae,Dictionary,axiomate,AxiomFormulae,Dictionary,NameSuffix):-
     tptp_formulae(Formulae),
-    tptp2X_select(fof(_,conjecture,_),Formulae,AxiomFormulae),
-    \+ tptp2X_member(fof(_,conjecture,_),AxiomFormulae).
+    tptp2X_select(fof(_,conjecture,_),Formulae,DeConjecturedFormulae),
+    !,
+    axiomate(DeConjecturedFormulae,Dictionary,axiomate,AxiomFormulae,
+Dictionary,NameSuffix).
+
+axiomate(Formulae,Dictionary,axiomate,Formulae,Dictionary,'+axed').
 %------------------------------------------------------------------------------
 fofify_file_information(transform,fofify:obvious,'obvious or proving').
 
 fofify_file_information(transform,axiomate,'Removes the conjecture').
+
+fofify_file_information(transform,tff2fof,'Converts TFF to FOF').
 %------------------------------------------------------------------------------
Only in 2/TPTP2X: transform.milfof
diff -ur 1/TPTP2X/transform.reform 2/TPTP2X/transform.reform
--- 1/TPTP2X/transform.reform	2007-03-01 12:01:53.000000000 -0500
+++ 2/TPTP2X/transform.reform	2012-08-13 14:45:12.000000000 -0400
@@ -59,12 +59,13 @@
 %==============================================================================
 remove_top_level_and([],[]).
 
+%----Don't remove from conjecture
 remove_top_level_and([fof(Name,conjecture,Formula)|RestOfFormulae],
 [fof(Name,conjecture,Formula)|RestOfNoAndFormulae]):-
     !,
     remove_top_level_and(RestOfFormulae,RestOfNoAndFormulae).
  
-remove_top_level_and([fof(Name,Type,LHS & RHS)|RestOfFormulae],
+remove_top_level_and([fof(Name,Type,(LHS & RHS))|RestOfFormulae],
 NoAndFormulae):-
     !,
     concatenate_atoms([Name,'_AndLHS'],LHSName),
@@ -77,6 +78,13 @@
     remove_top_level_and(RestOfFormulae,RestOfNoAndFormulae).
 %------------------------------------------------------------------------------
 %----Remove <= <~> ~| and ~&
+%DEBUG standardize_formula(F,_):-write('SF--- '),write(F),nl,fail.
+
+%----Catch variables early (for THF case)
+standardize_formula(Variable,Variable):-
+    looks_like_a_variable(Variable),
+    !.
+
 %----Remove <=
 standardize_formula((P <= Q),StandardisedImplication):-
     !,
@@ -100,80 +108,73 @@
     standardize_formula(P,P1),
     standardize_formula(Q,Q1).
 
-%----Remove => false
-standardize_formula((P => $(false)),~ (P1)):-
+%----Remove => false. For THF prevent instantiation
+standardize_formula(LHS => RHS,~ (StandardisedLHS)):-
+    RHS == '$false',
     !,
-    standardize_formula(P,P1).
+    standardize_formula(LHS,StandardisedLHS).
 
 %----Remove true =>
-standardize_formula(($(true) => P),P1):-
+standardize_formula(LHS => RHS,StandardisedRHS):-
+    LHS == '$true',
     !,
-    standardize_formula(P,P1).
+    standardize_formula(RHS,StandardisedRHS).
 
 %----Remove true & anything
-standardize_formula((P & $(true)),P1):-
+standardize_formula(LHS & RHS,StandardisedLHS):-
+    RHS == '$true',
     !,
-    standardize_formula(P,P1).
+    standardize_formula(LHS,StandardisedLHS).
 
-standardize_formula(($(true) & P),P1):-
+standardize_formula(LHS & RHS,StandardisedRHS):-
+    LHS == '$true',
     !,
-    standardize_formula(P,P1).
+    standardize_formula(RHS,StandardisedRHS).
 
 %----Remove false | anything
-standardize_formula((P '|' $(false)),P1):-
+standardize_formula(LHS | RHS,StandardisedLHS):-
+    RHS == '$false',
     !,
-    standardize_formula(P,P1).
+    standardize_formula(LHS,StandardisedLHS).
 
-standardize_formula(($(false) '|' P),P1):-
+standardize_formula(LHS | RHS,StandardisedRHS):-
+    LHS == '$false',
     !,
-    standardize_formula(P,P1).
+    standardize_formula(RHS,StandardisedRHS).
 
 %----Do all others by parts
-standardize_formula(! X : P,! X : P1):-
-    !,
-    standardize_formula(P,P1).
-
-standardize_formula(? X : P,? X : P1):-
-    !,
-    standardize_formula(P,P1).
-
-standardize_formula((P <=> Q),(P1 <=> Q1)):-
-    !,
-    standardize_formula(P,P1),
-    standardize_formula(Q,Q1).
-
-standardize_formula((P => Q),(P1 => Q1)):-
+standardize_formula(QuantifiedFormula,StandardisedQuantifiedFormula):-
+    tptp_quantified_formula(QuantifiedFormula,Quantifier,Variables,Formula),
     !,
-    standardize_formula(P,P1),
-    standardize_formula(Q,Q1).
-
-standardize_formula((P & Q),(P1 & Q1)):-
-    !,
-    standardize_formula(P,P1),
-    standardize_formula(Q,Q1).
-
-standardize_formula((P ; Q),(P1 ; Q1)):-
-    !,
-    standardize_formula(P,P1),
-    standardize_formula(Q,Q1).
+    standardize_formula(Formula,StandardizedFormula),
+    tptp_quantified_formula(StandardisedQuantifiedFormula,Quantifier,Variables,
+StandardizedFormula).
 
-%----|;BUG
-standardize_formula((P '|' Q),(P1 ; Q1)):-
+standardize_formula(BinaryFormula,StandardizedBinaryFormula):-
+    tptp_binary_formula(BinaryFormula,BinaryConnective,LHS,RHS),
     !,
-    standardize_formula(P,P1),
-    standardize_formula(Q,Q1).
+    standardize_formula(LHS,StandardizedLHS),
+    standardize_formula(RHS,StandardizedRHS),
+    tptp_binary_formula(StandardizedBinaryFormula,BinaryConnective,
+StandardizedLHS,StandardizedRHS).
 
-standardize_formula((~ P),(~ P1)):-
+standardize_formula(UnaryFormula,StandardizedUnaryFormula):-
+    tptp_unary_formula(UnaryFormula,UnaryConnective,Formula),
     !,
-    standardize_formula(P,P1).
+    standardize_formula(Formula,StandardizedFormula),
+    tptp_unary_formula(StandardizedUnaryFormula,UnaryConnective,
+StandardizedFormula).
 
 standardize_formula(P,P).
 %------------------------------------------------------------------------------
 standardize_formulae([],[]).
 
-standardize_formulae([fof(Name,Status,Formula)|RestOfFormulae],
-[fof(Name,Status,StandardizedFormula)|RestOfStandardizedFormulae]):-
+standardize_formulae([AnnotatedFormula|RestOfFormulae],
+[StandardizedAnnotatedFormula|RestOfStandardizedFormulae]):-
+    AnnotatedFormula =.. [Language,Name,Role,Formula|Rest],
     standardize_formula(Formula,StandardizedFormula),
+    StandardizedAnnotatedFormula =.. [Language,Name,Role,StandardizedFormula|
+Rest],
     standardize_formulae(RestOfFormulae,RestOfStandardizedFormulae).
 %------------------------------------------------------------------------------
 %----These quick tricks added by Ben Cockfield. Smokin'!
@@ -349,6 +350,12 @@
 ReplacedFormula).
 %------------------------------------------------------------------------------
 %----Make quantified variable unique (in a Prolog sense)
+%DEBUG unique_quantification(F,_):-write('=========='),nl,write(F),fail.
+
+unique_quantification(Variable,Variable):-
+    looks_like_a_variable(Variable),
+    !.
+
 unique_quantification(QuantifiedFormula,UniqueQuantifiedFormula):-
     tptp_quantified_formula(QuantifiedFormula,Quantifier,[Variable],Formula),
     !,
@@ -741,28 +748,28 @@
 %----Otter clausifying algorithm
 translate_formula_to_clauses(otter,Formula,Clauses,SkolemNumber,
 NextSkolemNumber):-
-%DEBUG write('translate '),write(Formula),nl,
+%DEBUG write('Translate '),write(Formula),nl,
 %----Remove implications
     and_or_not_limit(Formula,WithoutImplications),
-%DEBUG write('done and_or_not_limit'),nl,
+%DEBUG write('Simplified to '),write(WithoutImplications),nl,
 %----Make single variables in each quantification
     single_variable_quantification(WithoutImplications,SingleVariables),
-%DEBUG write('done single_variable_quantification'),nl,
+%DEBUG write('Expanded variables '),write(SingleVariables),nl,
 %----Make quantified variables unique
     unique_quantification(SingleVariables,UniqueQuantified),
-%DEBUG write('done unique_quantification'),nl,
+%DEBUG write('Renamed variables '),write(UniqueQuantified),nl,
 %----Negations moved in
     move_in_negations(UniqueQuantified,NegationsIn),
-%DEBUG write('done move_in_negations'),nl,
+%DEBUG write('Literal normal form '),write(NegationsIn),nl,
 %----Skolemize
     skolemize(NegationsIn,Skolemized,[],SkolemNumber,NextSkolemNumber),
-%DEBUG write('done skolemize'),nl,
+%DEBUG write('Skolem normal form '),write(Skolemized),nl,
 %----Move out universal quantification
     remove_universal_quantifiers(Skolemized,Universalized),
-%DEBUG write('done remove_universal_quantifiers'),nl,
+%DEBUG write('Removed quantifier '),write(Universalized),nl,
 %----Distribute conjunctions
     distribute_conjunctions(Universalized,Distributed),
-%DEBUG write('done distribute_conjunctions'),nl,
+%DEBUG write('Conjunctive normal form '),write(Distributed),nl,
 %----Convert to clauses
     make_clauses(Distributed,Clauses).
 
@@ -771,25 +778,25 @@
 NextSkolemNumber):-
 %----Remove implications
     and_or_not_limit(Formula,WithoutImplications),
-%DEBUG output_generic_formula(tptp,WithoutImplications),nl,nl,
+%DEBUG output_generic_formula(tptp,fof,WithoutImplications),nl,nl,
 %----Make single variables in each quantification
     single_variable_quantification(WithoutImplications,SingleVariables),
 %----Make quantified variables unique
     unique_quantification(SingleVariables,UniqueQuantified),
 %----Quantifiers moved out
     move_out_quantifiers(UniqueQuantified,QuantifiersOut),
-%DEBUG output_generic_formula(tptp,QuantifiersOut),nl,nl,
+%DEBUG output_generic_formula(tptp,fof,QuantifiersOut),nl,nl,
 %----Skolemize
     skolemize(QuantifiersOut,Skolemized,[],SkolemNumber,NextSkolemNumber),
-%DEBUG output_generic_formula(tptp,Skolemized),nl,nl,
+%DEBUG output_generic_formula(tptp,fof,Skolemized),nl,nl,
 %----Make literals
     move_in_negations(Skolemized,NegationsIn),
-%DEBUG output_generic_formula(tptp,NegationsIn),nl,nl,
+%DEBUG output_generic_formula(tptp,fof,NegationsIn),nl,nl,
 %----Move out universal quantification
     remove_universal_quantifiers(NegationsIn,Universalized),
 %----Distribute conjunctions
     distribute_conjunctions(Universalized,Distributed),
-%DEBUG output_generic_formula(tptp,Distributed),nl,nl,
+%DEBUG output_generic_formula(tptp,fof,Distributed),nl,nl,
 %----Convert to clauses
     make_clauses(Distributed,Clauses).
 
@@ -892,7 +899,7 @@
 rename_variables([FirstClause|RestOfClauses],CommonClauseDictionary,
 [FirstRenamedClause|RestOfRenamedClauses],[[numbervars=FirstRenamedClause]|
 RestOfClausesDictionary]):-
-    tptp2X_copy(FirstClause-CommonClauseDictionary,FirstRenamedClause-_),
+    copy_term(FirstClause-CommonClauseDictionary,FirstRenamedClause-_),
     rename_variables(RestOfClauses,CommonClauseDictionary,
 RestOfRenamedClauses,RestOfClausesDictionary).
 %------------------------------------------------------------------------------
@@ -908,15 +915,15 @@
     NegatedLiteral == AnotherLiteral.
 
 tautologous_clause(Literals):-
-    tptp2X_member(++ $(true),Literals).
+    tptp2X_member(++ '$true',Literals).
 
 tautologous_clause(Literals):-
-    tptp2X_member(-- $(false),Literals).
+    tptp2X_member(-- '$false',Literals).
 %------------------------------------------------------------------------------
 %----Remove tautologous clauses
 %----If none kept, then they were all tautologies => valid
 remove_tautologies([],[],0,[input_clause(satisfiable_dummy,negated_conjecture,
-[++ $true])],[[]]):-
+[++ '$true'])],[[]]):-
     !.
 
 remove_tautologies([],[],Kept,[],[]):-
@@ -939,12 +946,12 @@
 %------------------------------------------------------------------------------
 %----Remove constant false from literals
 remove_false_from_literals(Literals,FalseFreeLiterals):-
-    tptp2X_select(++ $(false),Literals,LessFalseLiterals),
+    tptp2X_select(++ '$false',Literals,LessFalseLiterals),
     !,
     remove_false_from_literals(LessFalseLiterals,FalseFreeLiterals).
 
 remove_false_from_literals(Literals,FalseFreeLiterals):-
-    tptp2X_select(-- $(true),Literals,LessFalseLiterals),
+    tptp2X_select(-- '$true',Literals,LessFalseLiterals),
     !,
     remove_false_from_literals(LessFalseLiterals,FalseFreeLiterals).
 
@@ -1046,7 +1053,7 @@
     !,
 %----Do occurs check
 %----Copy the term
-    tptp2X_copy(Term,TermCopy),
+    copy_term(Term,TermCopy),
 %----Count how many variables in the copy
     numbervars(TermCopy,0,NumberOfVariables),
     \+ ( \+ (
@@ -1109,7 +1116,7 @@
 %        tptp2X_select(SubsumingLiteral,Literals,OtherLiterals),
 %        tptp2X_member(SubsumingLiteral,OtherLiterals)),
 %----Create factor
-    tptp2X_copy(Literals,CopyOfLiterals),
+    copy_term(Literals,CopyOfLiterals),
     factor_literals(CopyOfLiterals,FactoredLiterals),
 %----Check that the literals are subsumed
     literals_subsume(FactoredLiterals,Literals),
@@ -1161,10 +1168,13 @@
 unit_subsumed_resolution(Clauses,Dictionary,UnitSubsumedClauses,
 UnitSubsumedDictionary):-
 %----Select a unit clause
+%DEBUG write('%=======clause are: '),write(Clauses),nl,
     tptp2X_member(input_clause(_,_,[UnitLiteral]),Clauses),
+%DEBUG write('%=======using unit '),write(UnitLiteral),nl,
 %----Do all unit subsumptions
     unit_subsumed_resolvants(UnitLiteral,Clauses,Dictionary,[_|_],
 ThisUnitSubsumedClauses,ThisUnitSubsumedDictionary),
+%DEBUG write('%=======after unitr: '),write(ThisUnitSubsumedClauses),nl,
 %----If some unit resolvants are done, then loop. Required as units
 %----may have been created. A bit inefficient.
     !,
@@ -1176,7 +1186,14 @@
 %------------------------------------------------------------------------------
 %----Check if the literal can complementarity unify with another
 can_resolve_on_literal(EqualityLiteral,_,yes):-
-    EqualityLiteral =.. [_,equal(_,_)].
+    EqualityLiteral =.. [_,'$tptp_equal'(_,_)].
+
+%----Can always resolve on arithmetic literals
+can_resolve_on_literal(ArithmeticLiteral,_,_):-
+    ArithmeticLiteral =.. [_,Atom],
+    functor(Atom,Predicate,_),
+    tptp2X_member(Predicate,['$int','$rat','$real','$less','$lesseq',
+'$greater','$greatereq','$is_int','$is_rat','$evaleq']).
 
 can_resolve_on_literal(Literal,OtherClauses,EqualityPresent):-
 %----Make a template for the literal to resolve against
@@ -1193,9 +1210,9 @@
 %------------------------------------------------------------------------------
 %----Check if a clause is pure, i.e., contains a literals that cannot
 %----complementarily unify with another
-%----If only one non_empty clause left, then make satisfiable clause
-eliminate_pure_literals([input_clause(_,_,[_|_])],[_],_,
-[input_clause(satisfiable_dummy,negated_conjecture,[++ $true])],
+%----If nothing left, then make satisfiable clause
+eliminate_pure_literals([],_,_,
+[input_clause(satisfiable_dummy,negated_conjecture,[++ '$true'])],
 [[]]):-
     !.
 
@@ -1227,10 +1244,11 @@
     DigitASCII =< 57,
     all_digits(RestOfDigitsASCII).
 %------------------------------------------------------------------------------
-find_largest_sk_number([],LargestSkNumber, LargestSkNumber).
+find_largest_sk_number([],LargestSkNumber,LargestSkNumber).
 
 find_largest_sk_number([FirstSymbol|RestOfSymbols],LargestSoFar,
 LargestSkNumber):-
+    atom(FirstSymbol),
     name(FirstSymbol,FirstASCII),
     tptp2X_append("sk",DigitsASCII,FirstASCII),
     \+ (
@@ -1255,19 +1273,27 @@
 %----Translate a list of formulae
 translate_to_oldtptp_clauses([],[],_,_,[],[]).
 
-translate_to_oldtptp_clauses([fof(Name,Status,FirstFormula)|
-RestOfFormulae],[FormulaDictionary|RestOfDictionary],Algorithm,
+translate_to_oldtptp_clauses([FirstAnnotatedFormula|
+RestOfAnnotatedFormulae],[FormulaDictionary|RestOfDictionary],Algorithm,
 SkolemNumber,OutputClauses,OutputDictionary):-
+    FirstAnnotatedFormula =.. [fof,Name,Status,FirstFormula|_],
+%DEBUG write('Translate FirstAnnotatedFormula '),nl,write(FirstAnnotatedFormula),nl,
+%DEBUG write('Translate FormulaDictionary '),nl,write(FormulaDictionary),nl,
     translate_formula_to_clauses(Algorithm,FirstFormula,FirstClauses,
 SkolemNumber,NextSkolemNumber),
+%DEBUG write('FirstClauses'),nl,write(FirstClauses),nl,
 %----Convert to tptp clauses
     convert_to_oldtptp_clauses(FirstClauses,Name,Status,FirstTPTPClauses),
+%DEBUG write('FirstTPTPClauses'),nl,write(FirstClauses),nl,
 %----Rename the variable in each clause (numbervars them now = shit)
     rename_variables(FirstTPTPClauses,FormulaDictionary,RenamedClauses,
 FirstClausesDictionary),
+%DEBUG write('FirstClausesDictionary'),nl,write(FirstClausesDictionary),nl,
 %----Do the rest of the formulae
-    translate_to_oldtptp_clauses(RestOfFormulae,RestOfDictionary,Algorithm,
-NextSkolemNumber,RestOfOutputClauses,RestOfOutputClausesDictionary),
+%DEBUG write('RestOfAnnotatedFormulae'),nl,write(RestOfAnnotatedFormulae),nl,
+%DEBUG write('RestOfDictionary'),nl,write(RestOfDictionary),nl,
+    translate_to_oldtptp_clauses(RestOfAnnotatedFormulae,RestOfDictionary,
+Algorithm,NextSkolemNumber,RestOfOutputClauses,RestOfOutputClausesDictionary),
     tptp2X_append(RenamedClauses,RestOfOutputClauses,OutputClauses),
     tptp2X_append(FirstClausesDictionary,RestOfOutputClausesDictionary,
 OutputDictionary).
@@ -1293,29 +1319,38 @@
 repeated_simplification(Clauses,Dictionary,EqualityPresent,_,SimplifiedClauses,
 SimplifiedDictionary):-
 %----Do my factor simplification
+%DEBUG write('%-------------------------------------'),nl,
+%DEBUG write('%-----before factor_simplify_clauses: '),write(Clauses),nl,
     factor_simplify_clauses(Clauses,Dictionary,FactoredClauses,
 FactoredDictionary),
 %----Do unit subsumed resolution
-%DEBUG write('before unit_subsumed_resolution'),nl,write(FactoredClauses),nl,
+%DEBUG write('%-----before unit_subsumed_resolution: '),write(FactoredClauses),nl,
     unit_subsumed_resolution(FactoredClauses,FactoredDictionary,
 UnitSubsumedClauses,UnitSubsumedDictionary),
 %----Remove subsumed clauses
-%DEBUG write('before subsume_clauses'),nl,write(UnitSubsumedClauses),nl,
+%DEBUG write('%-----before subsume_clauses: '),write(UnitSubsumedClauses),nl,
     subsume_clauses(UnitSubsumedClauses,UnitSubsumedDictionary,
 SubsumedClauses,SubsumedDictionary),
 %----Do pure literal elimination
-%DEBUG write('before eliminate_pure_literals'),nl,write(SubsumedClauses),nl,
+%DEBUG write('%-----before eliminate_pure_literals: '),write(SubsumedClauses),nl,
     eliminate_pure_literals(SubsumedClauses,SubsumedDictionary,EqualityPresent,
 PureClauses,PureDictionary),
-%DEBUG write('after eliminate_pure_literals'),nl,write(PureClauses),nl,
+%DEBUG write('%-----after eliminate_pure_literals: '),write(PureClauses),nl,
 %----Try to do more
     repeated_simplification(PureClauses,PureDictionary,EqualityPresent,
 Clauses,SimplifiedClauses,SimplifiedDictionary).
 %------------------------------------------------------------------------------
 detect_equality(Clauses,yes):-
-    tptp2X_member(input_clause(_,_,Literals),Clauses),
-    tptp2X_member(Literal,Literals),
-    Literal =.. [_,equal(_,_)],
+    examine_formulae_for_predicates(Clauses,_,_,PredicateSymbols),
+    tptp2X_member(Predicate,PredicateSymbols),
+    tptp2X_member(Predicate,['$tptp_equal']),
+% ,'$int','$rat','$real','$less','$lesseq','$greater','$greatereq','$evaleq']),
+    !.
+
+detect_equality(Clauses,yes):-
+    examine_formulae_for_functors(Clauses,_,Functors),
+    tptp2X_member(Functor,Functors),
+    looks_like_a_number(Functor),
     !.
 
 detect_equality(_,no).
@@ -1331,16 +1366,42 @@
     repeated_simplification(FixedSimplifiedClauses,FixedSimplifiedDictionary,
 EqualityPresent,_,SimplifiedClauses,SimplifiedDictionary).
 %------------------------------------------------------------------------------
-%----Negate a conjecture formula (assumed there is max one)
-negate_conjecture(Formulae,FormulaeToClausify):-
-    tptp2X_select(fof(Name,conjecture,Formula),Formulae,OtherFormulae),
+%----Negate a conjecture formula (max one)
+do_negate_conjecture(Formulae,_):-
+    tptp2X_select(Conjecture,Formulae,OtherFormulae),
+    Conjecture =.. [_,_,conjecture|_],
+    tptp2X_member(AnotherConjecture,OtherFormulae),
+    AnotherConjecture =.. [_,_,conjecture|_],
+    !,
+    write('ERROR : More than one conjecture'),
+    nl,
+    fail.
+
+do_negate_conjecture(Formulae,NegatedConjectureFormulae):-
+    tptp2X_select(Conjecture,Formulae,OtherFormulae),
+    Conjecture =.. [Language,Name,conjecture,Formula|Rest],
     !,
-    tptp2X_append(OtherFormulae,[fof(Name,negated_conjecture,~(Formula))],
-FormulaeToClausify).
+    NewFormula =.. [Language,Name,negated_conjecture,~(Formula)|Rest],
+    tptp2X_append(OtherFormulae,[NewFormula],NegatedConjectureFormulae).
 
 %----If none, e.g., checking satisfiable, then do nothing
-negate_conjecture(Formulae,Formulae).
+do_negate_conjecture(Formulae,Formulae).
 %------------------------------------------------------------------------------
+%do_varify([],[]).
+%
+%do_varify([AnnotatedFormula|RestOfAnnotatedFormulae],[VarifiedAnnotatedFormula|
+%RestOfVarifiedAnnotatedFormulae]):-
+%    AnnotatedFormula =.. [Form,Name,Role,Formula|Rest],
+%write('B4: '),write(Formula),nl,
+%    unique_quantification(Formula,VarifiedFormula),
+%write('AF: '),write(VarifiedFormula),nl,
+%    VarifiedAnnotatedFormula =.. [Form,Name,Role,VarifiedFormula|Rest],
+%    do_varify(RestOfAnnotatedFormulae,RestOfVarifiedAnnotatedFormulae).
+%------------------------------------------------------------------------------
+%----Rename variables apart
+%varify(Formulae,Dictionary,varify,UniqueVarFormulae,Dictionary,'+var'):-
+%    do_varify(Formulae,UniqueVarFormulae).
+ 
 %----Convert to propositional if HU is finite
 propify(Clauses,_,propify,PropositionalClauses,[],'+prop'):-
     tptp_clauses(Clauses),
@@ -1358,24 +1419,18 @@
 propify(Formulae,Dictionary,propify,Formulae,Dictionary,''):-
     tptp_formulae(Formulae).
 
-%----Negate conjecture in a FOF file
-negconj(Formulae,Dictionary,negconj,NegatedFormulae,Dictionary,'+negconj'):-
-    tptp_formulae(Formulae),
-    tptp2X_select(fof(Name,conjecture,LogicFormula),Formulae,OtherFormulae),
-    tptp2X_append(OtherFormulae,[fof(Name,conjecture,~(LogicFormula))],
-NegatedFormulae).
-
-negconj(Formulae,Dictionary,negconj,Formulae,Dictionary,''):-
-    tptp_clauses(Formulae).
-
 %----Formulae are standardized - removed <~> <= ~| and ~&
 stdfof(Formulae,Dictionary,stdfof,StandardizedFormulae,Dictionary,'+stdfof'):-
     tptp_formulae(Formulae),
+    !,
     remove_top_level_and(Formulae,NoAndFormulae),
     standardize_formulae(NoAndFormulae,StandardizedFormulae).
 
-stdfof(Formulae,Dictionary,stdfof,Formulae,Dictionary,''):-
-    tptp_clauses(Formulae).
+stdfof(Formulae,Dictionary,stdfof,Formulae,Dictionary,'').
+
+negate_conjecture(Formulae,Dictionary,negate_conjecture,
+NegatedConjectureFormulae,Dictionary,'+negated_conjecture'):-
+    do_negate_conjecture(Formulae,NegatedConjectureFormulae).
 
 %----Formulae are clausifed 
 clausify(Formulae,Dictionary,clausify:Algorithm,TPTPClauses,
@@ -1383,12 +1438,17 @@
     tptp_formulae(Formulae),
     get_first_skolem_number(Formulae,FirstSkolemNumber),
 %----Negate the conjecture formula (assume there is only one)
-    negate_conjecture(Formulae,FormulaeToClausify),
+    do_negate_conjecture(Formulae,FormulaeToClausify),
+%DEBUG write('FormulaeToClausify '),nl,write(FormulaeToClausify),nl,
+%DEBUG write('Dictionary '),nl,write(Dictionary),nl,
     translate_to_oldtptp_clauses(FormulaeToClausify,Dictionary,Algorithm,
 FirstSkolemNumber,OutputClauses,OutputDictionary),
+%DEBUG write('OutputClauses '),nl,write(OutputClauses),nl,
+%DEBUG write('OutputDictionary '),nl,write(OutputDictionary),nl,
 %----Remove dictionary entries instantiated by Skolemization and unification
     remove_instantiated_variables_from_dictionary_list(OutputDictionary,
 TPTPClausesDictionary),
+%DEBUG write('TPTPClausesDictionary '),nl,write(TPTPClausesDictionary),nl,
 %----Make new names for all the clauses
     make_unique_clause_names(OutputClauses,1,TPTPClauses),
     concatenate_atoms(['+cls_',Algorithm],NameSuffix).
@@ -1416,19 +1476,22 @@
 cnf(Formulae,Dictionary,cnf:Algorithm,TPTPClauses,TPTPClausesDictionary,
 NameSuffix):-
     tptp_formulae(Formulae),
+%DEBUG write('Formulae'),nl,write(Formulae),nl,
+%DEBUG write('Dictionary'),nl,write(Dictionary),nl,
     clausify(Formulae,Dictionary,clausify:Algorithm,Clauses,
 ClausesDictionary,_),
+%DEBUG write('Clauses'),nl,write(Clauses),nl,
+%DEBUG write('ClausesDictionary'),nl,write(ClausesDictionary),nl,
     simplify(Clauses,ClausesDictionary,simplify,TPTPClauses,
 TPTPClausesDictionary,_),
+%DEBUG write('TPTPClauses'),nl,write(TPTPClauses),nl,
+%DEBUG write('TPTPClausesDictionary'),nl,write(TPTPClausesDictionary),nl,
     concatenate_atoms(['+cnf_',Algorithm],NameSuffix).
 
 %----Clauses are not clausified
 cnf(Formulae,Dictionary,cnf:_,Formulae,Dictionary,''):-
     tptp_clauses(Formulae).
 %------------------------------------------------------------------------------
-reform_file_information(transform,negconj,
-'Negate conjecture - useful for testing things').
-
 reform_file_information(transform,stdfof,
 'Convert to standard FOF, without weird operators or top level &').
 
Only in 1/TPTP2X: transform.rfof
diff -ur 1/TPTP2X/transform.shorten 2/TPTP2X/transform.shorten
--- 1/TPTP2X/transform.shorten	2007-03-01 12:01:54.000000000 -0500
+++ 2/TPTP2X/transform.shorten	2012-08-13 14:45:12.000000000 -0400
@@ -11,6 +11,10 @@
 short_symbol_letter(_,term,0,c):-
     !.
 
+%----Types
+short_symbol_letter(_,type,0,t):-
+    !.
+
 %----Functors
 short_symbol_letter(_,term,Arity,f):-
     Arity > 0,
@@ -20,6 +24,20 @@
 short_symbol_letter(_,atom,_,p).
 %----------------------------------------------------------------------
 %----Make a shortened version of a symbol.
+%----Don't shorten reserved synbols
+shorten_symbol(Symbol,_,_,Index,Shortenings,Symbol,Index,Shortenings):-
+    name(Symbol,[36|_]),
+    !.
+
+%----Don't shorten numbers
+shorten_symbol(Number,_,_,Index,Shortenings,Number,Index,Shortenings):-
+    integer(Number),
+    !.
+
+%----Lists for strings
+shorten_symbol([H|T],_,_,Index,Shortenings,[H|T],Index,Shortenings):-
+    !.
+
 %----This symbol has been seen before.
 shorten_symbol(Symbol,_,_,Index,Shortenings,ShortenedSymbol,Index,
 Shortenings):-
@@ -40,15 +58,6 @@
     var(Variable),
     !.
 
-%----Don't shorten semantic constants
-shorten_expression($(Reserved),_,Index,Shortenings,$(Reserved),Index,
-Shortenings):-
-    !.
-
-shorten_expression(Number,_,Index,Shortenings,Number,Index,Shortenings):-
-    integer(Number),
-    !.
-
 shorten_expression(Expression,ExpressionType,NextIndex,Shortenings,
 ShortenedExpression,NewIndex,NewShortenings):-
 %----Break off the symbol and arguments
@@ -114,15 +123,19 @@
 ShortenedQuantifiedFormula,NewIndex,NewShortenings):-
     tptp_quantified_formula(QuantifiedFormula,Quantifier,Variables,
 Formula),
+%DEBUG write('qunatified '),write(QuantifiedFormula),nl,
     !,
     shorten_formula(Formula,Index,Shortenings,ShortenedFormula,
+MiddleIndex,MiddleShortenings),
+    shorten_terms(Variables,MiddleIndex,MiddleShortenings,ShortenedVariables,
 NewIndex,NewShortenings),
-    tptp_quantified_formula(ShortenedQuantifiedFormula,Quantifier,Variables,
-ShortenedFormula).
+    tptp_quantified_formula(ShortenedQuantifiedFormula,Quantifier,
+ShortenedVariables,ShortenedFormula).
 
 shorten_formula(BinaryFormula,Index,Shortenings,ShortenedBinaryFormula,
 NewIndex,NewShortenings):-
     tptp_binary_formula(BinaryFormula,BinaryConnective,LHS,RHS),
+%DEBUG write('binary '),write(BinaryFormula),nl,
     !,
     shorten_formula(LHS,Index,Shortenings,ShortenedLHS,MiddleIndex,
 MiddleShortenings),
@@ -134,14 +147,48 @@
 shorten_formula(UnaryFormula,Index,Shortenings,ShortenedUnaryFormula,
 NewIndex,NewShortenings):-
     tptp_unary_formula(UnaryFormula,UnaryConnective,Formula),
+%DEBUG write('unary '),write(UnaryFormula),nl,
     !,
     shorten_formula(Formula,Index,Shortenings,ShortenedFormula,
 NewIndex,NewShortenings),
     tptp_unary_formula(ShortenedUnaryFormula,UnaryConnective,
 ShortenedFormula).
 
+shorten_formula(Symbol: '$tType',Index,Shortenings,ShortenedSymbol : '$tType',
+NewIndex,NewShortenings):-
+    !,
+%DEBUG write('new type '),write(Symbol: Signature),nl,
+    shorten_expression(Symbol,type,Index,Shortenings,
+ShortenedSymbol,NewIndex,NewShortenings).
+
+shorten_formula(Symbol: '$o',Index,Shortenings,
+ShortenedSymbol : '$o',NewIndex,NewShortenings):-
+    !,
+%DEBUG write('proposition type '),write(Symbol: Signature),nl,
+    shorten_expression(Symbol,atom,Index,Shortenings,
+ShortenedSymbol,NewIndex,NewShortenings).
+
+shorten_formula(Symbol: Arguments > '$o',Index,Shortenings,
+ShortenedSymbol : ShortenedArguments > '$o',NewIndex,NewShortenings):-
+    !,
+%DEBUG write('predicate type '),write(Symbol: Signature),nl,
+    shorten_expression(Symbol,atom,Index,Shortenings,
+ShortenedSymbol,MiddleIndex,MiddleShortenings),
+    shorten_expression(Arguments,type,MiddleIndex,MiddleShortenings,
+ShortenedArguments,NewIndex,NewShortenings).
+
+shorten_formula(Symbol: Signature,Index,Shortenings,
+ShortenedSymbol : ShortenedSignature,NewIndex,NewShortenings):-
+    !,
+%DEBUG write('type '),write(Symbol: Signature),nl,
+    shorten_expression(Symbol,term,Index,Shortenings,
+ShortenedSymbol,MiddleIndex,MiddleShortenings),
+    shorten_expression(Signature,type,MiddleIndex,MiddleShortenings,
+ShortenedSignature,NewIndex,NewShortenings).
+
 shorten_formula(AtomicFormula,Index,Shortenings,ShortenedAtomicFormula,
 NewIndex,NewShortenings):-
+%DEBUG write('atom '),write(AtomicFormula),nl,
     shorten_expression(AtomicFormula,atom,Index,Shortenings,
 ShortenedAtomicFormula,NewIndex,NewShortenings).
 %--------------------------------------------------------------------
@@ -149,14 +196,16 @@
 Shortenings,Shortenings,[]):-
     !.
 
-shorten_formulae([fof(_Name,Status,Formula)|RestOfFormulae],
-FormulaIndex,NewFormulaIndex,NextIndex,NewIndex,Shortenings,
-NewShortenings,[fof(IndexedName,Status,ShortenedFormula)|
+shorten_formulae([FirstFormula|RestOfFormulae],FormulaIndex,NewFormulaIndex,
+NextIndex,NewIndex,Shortenings,NewShortenings,[FirstShortenedFormula|
 RestOfShortenedFormulae]):-
+    FirstFormula =.. [Type,_Name,Status,Formula|Rest],
+    tptp2X_member(Type,[fof,tff,thf]),
     concatenate_atoms([formula_,FormulaIndex],IndexedName),
     MiddleFormulaIndex is FormulaIndex + 1,
     shorten_formula(Formula,NextIndex,Shortenings,ShortenedFormula,
 MiddleIndex,MiddleShortenings),
+    FirstShortenedFormula =.. [Type,IndexedName,Status,ShortenedFormula|Rest],
     shorten_formulae(RestOfFormulae,MiddleFormulaIndex,NewFormulaIndex,
 MiddleIndex,NewIndex,MiddleShortenings,NewShortenings,
 RestOfShortenedFormulae).
@@ -190,14 +239,21 @@
 shorten(InputClauses,Dictionary,shorten,ShortenedClauses,NewDictionary,
 '+short'):-
     tptp_clauses(InputClauses),
-%----Prevent shortening equal/2
-    shorten_clauses(InputClauses,1,_,1,_,[equal-equal],_,ShortenedClauses),
+%----Prevent shortening '$tptp_equal'/2
+    shorten_clauses(InputClauses,1,_,1,_,['$tptp_equal'-'$tptp_equal'],_,
+ShortenedClauses),
     shorten_variables(Dictionary,NewDictionary).
 
 shorten(Formulae,Dictionary,shorten,ShortenedFormulae,NewDictionary,
 '+short'):-
     tptp_formulae(Formulae),
-    shorten_formulae(Formulae,1,_,1,_,[equal-equal],_,ShortenedFormulae),
+    shorten_formulae(Formulae,1,_,1,_,
+[
+'$tptp_equal'-'$tptp_equal',
+'*'-'*',
+'>'-'>',
+':'-':'
+],_,ShortenedFormulae),
     shorten_variables(Dictionary,NewDictionary).
 %--------------------------------------------------------------------
 shorten_file_information(transform,shorten,
Only in 2/TPTP2X: transform.xdb
