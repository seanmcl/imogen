
signature Term = sig

   datatype t =
      Var of Var.t
    | Param of Param.t
    | Fn of Func.t * t list

   include Comparable  where type comparable  = t
   include Showable    where type showable    = t
   include Printable   where type printable   = t
   include Parseable   where type parseable   = t
   include Fixable'    where type fixable     = t
                         and type atoms       = Atoms.t
   include Collectable where type collectable = t

   val parse : Parse.Term.t -> t

   val vars: t -> Var.set
   val params: t -> Param.set
   val funcs: t -> Func.set
   val size: t -> int
   val isVar : t -> bool
   val isUnfixedVar : t -> bool
   val getVarExn : t -> Var.t

   (* Substitute a term for a variable. *)
   val apply1: t * (Var.t * t) -> t

   (* [a/x] M --> M
      This is a "reverse" substitution, removing a parameter and
      replacing it with a variable.  Used for replacing fresh parameters
      generated by ∀-R and ∃-L with variables when constructing natural
      deduction proofs.  *)
   val paramSubst: t * (Param.t * Var.t) -> t

   (*** Freezing global parameters ***)

   (* Freeze all parameters wrt. unification by
      turning them into constants.  This happens after the
      first inversion phase, where the generated parameters are
      considered global constants. *)
   val freeze: t -> t

   (* Undo 'freeze' by thawing out the given function symbols.
      This happens at the very end of the proving phase, when all
      initial sequents have been proved. *)
   val thaw: Func.set -> t -> t

   (*** Fixing variables and parameters for unification ***)

   val atoms: t -> Atoms.t
   val atomsl: t list -> Atoms.t

   (*** Equations ***)

   type eq = t * t
   type eqs = eq list

end
